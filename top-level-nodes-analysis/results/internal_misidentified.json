[
  {
    "name": "resolve_calls",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/resolution_registry.ts",
    "start_line": 248,
    "signature": "resolve_calls(file_references: Map<FilePath, readonly SymbolReference[]>, scopes: ScopeRegistry, types: TypeRegistry, definitions: DefinitionRegistry): CallReference[]",
    "root_cause": "internal helper method called through this",
    "reasoning": "The method resolve_calls is called internally by resolve_calls_for_files at line 180 using this.resolve_calls(). This is a private implementation detail pattern where a public method delegates to an internal helper. The call exists but is not being tracked by our call graph analysis.",
    "triage_analysis": {
      "detection_gap": "Method calls on this (self-references within a class) are not captured or resolved during call graph analysis, so internal helper methods appear as uncalled functions",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Add support for tracking this.method() calls by capturing them in query files, resolving this to the containing class during reference resolution, and looking up method SymbolIds within that class scope."
    }
  },
  {
    "name": "resolve_scope_recursive",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/resolution_registry.ts",
    "start_line": 429,
    "signature": "resolve_scope_recursive(scope_id: ScopeId, parent_resolutions: ReadonlyMap<SymbolName, SymbolId>, file_path: FilePath, language: Language, languages: ReadonlyMap<FilePath, Language>, exports: ExportRegistry, imports: ImportGraph, definitions: DefinitionRegistry, scopes: ScopeRegistry, root_folder: FileSystemFolder): Map<ScopeId, Map<SymbolName, SymbolId>>",
    "root_cause": "method called through this - simple two-element property chain not handled",
    "reasoning": "The method resolve_scope_recursive is called via this.resolve_scope_recursive() at lines 122 and 497. Method resolution fails because the simple method call path (line 96-110) tries to resolve 'this' as a variable in scope, which returns null since 'this' is a keyword. Special handling for 'this' only exists in the property chain resolver for chains with length > 2.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call path does not recognize self-reference keywords, only the multi-step property chain path handles them",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and the property chain path (line 240+) in method_resolver.ts, ensuring this.method() calls are resolved correctly."
    }
  },
  {
    "name": "process",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/references/reference_builder.ts",
    "start_line": 424,
    "signature": "process(capture: CaptureNode): ReferenceBuilder",
    "root_cause": "method called through JavaScript built-in higher-order function callback",
    "reasoning": "The process method is called at line 587 inside a callback function passed to Array.reduce(): (builder, capture) => builder.process(capture). Our call graph analysis cannot infer that the builder parameter has type ReferenceBuilder because we lack type flow tracking through JavaScript built-in methods like Array.reduce. Without knowing builder's type, the method call cannot be resolved, causing process() to appear as an uncalled entry point.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis does not track type flow through JavaScript/TypeScript built-in methods (Array.reduce, Array.map, Promise.then, etc.), preventing resolution of method calls made on parameters whose types are inferred from built-in generic signatures",
      "existing_task_fixes": [
        "task-155",
        "task-155.1",
        "task-155.2",
        "task-155.3",
        "task-110"
      ],
      "suggested_new_task_fix": "Implement declarative type stub system (task-155) that describes how types flow through built-in methods, allowing the resolver to infer that builder has type ReferenceBuilder from Array.reduce's second argument and successfully resolve builder.process() calls."
    }
  },
  {
    "name": "extract_function_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/javascript_typescript_scope_boundary_extractor.ts",
    "start_line": 85,
    "signature": "extract_function_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called by parent class through this",
    "reasoning": "The protected method extract_function_boundaries is called by parent class CommonScopeBoundaryExtractor.extract_boundaries() at scope_boundary_base.ts:78 using this.extract_function_boundaries(), and by sibling method extract_constructor_boundaries at line 199. Method resolution fails because the simple method call path (line 96-110 in method_resolver.ts) tries to resolve 'this' as a variable in scope, which returns null since 'this' is a keyword. Only the multi-step property chain path (line 240+) has special handling for the 'this' keyword.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call resolution path does not recognize self-reference keywords, only the multi-step property chain path handles them",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and the property chain path (line 240+) in method_resolver.ts, ensuring this.method() calls are resolved correctly regardless of chain length."
    }
  },
  {
    "name": "resolve_type_metadata",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/type_registry.ts",
    "start_line": 172,
    "signature": "resolve_type_metadata(file_id: FilePath, extracted: ExtractedTypeData, definitions: DefinitionRegistry, resolutions: ResolutionRegistry): void",
    "root_cause": "method called by parent class through this",
    "reasoning": "The private method resolve_type_metadata is called at line 107 via this.resolve_type_metadata() by the public update_file() method. Method resolution fails because the simple method call path tries to resolve 'this' as a variable in scope, which returns null since 'this' is a keyword. Only the multi-step property chain path has special handling for the 'this' keyword.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call resolution path does not recognize self-reference keywords, only the multi-step property chain path handles them",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and the property chain path (line 240+) in method_resolver.ts, ensuring this.method() calls are resolved correctly regardless of chain length."
    }
  },
  {
    "name": "run_validation",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/validate_captures.ts",
    "start_line": 456,
    "signature": "run_validation(queries_dir: string): ValidationResult[]",
    "root_cause": "external CLI/script caller - outside analysis scope",
    "reasoning": "The function run_validation is called from /Users/chuck/workspace/ariadne/scripts/validate_captures.ts (line 42), which is outside the packages/core analysis scope. The call graph analysis only scans packages/core production code (excluding test files), so this legitimate external caller is not detected, making run_validation appear as an uncalled entry point within the analyzed scope.",
    "triage_analysis": {
      "detection_gap": "Analysis scope excludes external callers in scripts/ directory, so functions exported for CLI/tooling use appear as entry points even when they are called from outside the analyzed codebase",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Extend analysis scope to include scripts/ directory OR add classification category for 'CLI/tooling entry points' to distinguish legitimate external entry points from internal false positives that indicate call graph analysis bugs."
    }
  },
  {
    "name": "add_method_to_class",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 269,
    "signature": "add_method_to_class(class_id: SymbolId, definition: {\n      symbol_id: SymbolId;\n      name: SymbolName;\n      location: Location;\n      scope_id: ScopeId;\n      return_type?: SymbolName;\n      access_modifier?: \"public\" | \"private\" | \"protected\";\n      abstract?: boolean;\n      static?: boolean;\n      async?: boolean;\n      generics?: SymbolName[];\n      docstring?: string;\n    }, capture: CaptureNode, rest: any): DefinitionBuilder",
    "root_cause": "framework callback method",
    "reasoning": "The function is called extensively (15+ locations) inside anonymous 'process' callback functions stored in configuration Maps (TYPESCRIPT_BUILDER_CONFIG, etc.). These callbacks are invoked by the semantic indexing framework via dynamic dispatch (handler.process()), but the call graph only tracks direct syntactic calls, not higher-order function invocations.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis does not track function references stored in data structures (Maps/objects) or trace calls made inside callback functions back to their framework invocation points",
      "existing_task_fixes": [
        "task-110"
      ],
      "suggested_new_task_fix": "Expand Task 110 to add callback invocation tracking: when a function stored in a Map/object is retrieved and invoked, track all calls made inside that callback as reachable from the invocation site, creating potential call graph edges for configuration-driven dispatch patterns"
    }
  },
  {
    "name": "add_constructor_to_class",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 314,
    "signature": "add_constructor_to_class(class_id: SymbolId, definition: {\n      symbol_id: SymbolId;\n      name: SymbolName;\n      location: Location;\n      scope_id: ScopeId;\n      access_modifier?: \"public\" | \"private\" | \"protected\";\n    }, capture: CaptureNode, error: any, rest: any): DefinitionBuilder",
    "root_cause": "method called through inline anonymous arrow function",
    "reasoning": "add_constructor_to_class is called from anonymous arrow functions defined inline as object properties in PYTHON_BUILDER_CONFIG and JAVASCRIPT_BUILDER_CONFIG maps. These arrow functions serve as handlers but have no named definitions in our semantic index. Our call graph only tracks calls from named functions/methods/constructors, so calls from these anonymous handlers are not attributed to any caller.",
    "triage_analysis": {
      "detection_gap": "Anonymous/inline arrow functions are not captured as function definitions (only assigned arrow functions are). Calls made from anonymous functions have no caller in the call graph, making their callees appear as false-positive entry points.",
      "existing_task_fixes": [
        "task-110"
      ],
      "suggested_new_task_fix": "Extend tree-sitter queries to capture ALL arrow functions (including inline/anonymous ones) as function definitions with location-based synthetic names. Update CallableDefinition to include these anonymous functions in call graph detection."
    }
  },
  {
    "name": "add_function",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 387,
    "signature": "add_function(definition: {\n      symbol_id: SymbolId;\n      name: SymbolName;\n      location: Location;\n      scope_id: ScopeId;\n      generics?: SymbolName[];\n      is_exported?: boolean;\n      export?: ExportMetadata;\n      docstring?: string;\n      return_type?: SymbolName;\n    }, capture: CaptureNode, error: any): DefinitionBuilder",
    "root_cause": "method called through inline anonymous arrow function",
    "reasoning": "add_function is called from anonymous arrow functions defined inline as object properties in TYPESCRIPT_BUILDER_CONFIG, PYTHON_BUILDER_CONFIG, JAVASCRIPT_BUILDER_CONFIG, and RUST_BUILDER_CONFIG maps. These arrow functions serve as handlers invoked via dynamic dispatch (handler.process()), but our call graph only tracks calls from named functions/methods/constructors, so calls from these anonymous handlers are not attributed to any caller.",
    "triage_analysis": {
      "detection_gap": "Anonymous/inline arrow functions are not captured as function definitions (only assigned arrow functions are). Calls made from anonymous functions have no caller in the call graph, making their callees appear as false-positive entry points.",
      "existing_task_fixes": [
        "task-110"
      ],
      "suggested_new_task_fix": "Extend tree-sitter queries to capture ALL arrow functions (including inline/anonymous ones) as function definitions with location-based synthetic names. Update CallableDefinition to include these anonymous functions in call graph detection."
    }
  },
  {
    "name": "process_use_list_items",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/rust_builder_helpers.ts",
    "start_line": 908,
    "signature": "process_use_list_items(): unknown",
    "root_cause": "nested arrow function assigned to local variable",
    "reasoning": "The function process_use_list_items is a nested arrow function assigned to a const variable inside extract_imports_from_use_declaration. It is called at lines 938 (recursively) and 973 (from parent scope), but these calls are not tracked. The call graph captures the function definition and call expressions but fails to resolve the call identifier to the function's SymbolId through local variable lookup.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis does not track calls to locally-scoped arrow functions stored in variables. While arrow function definitions and call expressions are captured, the resolution step fails to connect call identifiers to function-valued variable definitions, preventing call edges from being created.",
      "existing_task_fixes": [
        "task-110"
      ],
      "suggested_new_task_fix": "Extend task-110 to ensure lexical scope resolution connects call identifiers to arrow function variable definitions, creating call graph edges from the parent scope to nested arrow functions stored in local variables."
    }
  },
  {
    "name": "extract_type_data",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/type_registry.ts",
    "start_line": 119,
    "signature": "extract_type_data(index: SemanticIndex): ExtractedTypeData",
    "root_cause": "method called by same class (intra-class call)",
    "reasoning": "The private method extract_type_data is called by the public method update_file within the same TypeRegistry class via this.extract_type_data(index) at line 104. The call graph analysis failed to detect this intra-class method invocation, treating the private method as an entry point when it is actually an internal implementation detail.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis fails to track same-class method invocations via 'this' (TypeScript/JavaScript), 'self' (Python/Rust). The resolution system resolves method calls on typed external receivers but does not handle calls where the receiver is the implicit 'this' within the same class, causing these internal method calls to be invisible in the call graph.",
      "existing_task_fixes": [
        "task-110"
      ],
      "suggested_new_task_fix": "Add intra-class method call tracking: when resolving method calls with 'this'/'self' as receiver, determine the containing class of the caller method and resolve the target method within that same class, creating proper call references for internal method decomposition patterns."
    }
  },
  {
    "name": "extract_class_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/javascript_typescript_scope_boundary_extractor.ts",
    "start_line": 19,
    "signature": "extract_class_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called by parent class through this",
    "reasoning": "The protected method extract_class_boundaries is called by parent class CommonScopeBoundaryExtractor.extract_boundaries() at scope_boundary_base.ts:75 using this.extract_class_boundaries(), and by child class TypeScriptScopeBoundaryExtractor via super.extract_class_boundaries() at lines 44, 58, 61. Method resolution fails because the simple method call path (line 96-110 in method_resolver.ts) tries to resolve 'this' as a variable in scope, which returns null since 'this' is a keyword. Only the multi-step property chain path (line 240+) has special handling for the 'this' keyword.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call resolution path does not recognize self-reference keywords, only the multi-step property chain path handles them. Additionally, super.method() calls to parent class methods are not tracked at all.",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and the property chain path (line 240+) in method_resolver.ts, ensuring this.method() calls are resolved correctly. Additionally, add super.method() call tracking by recognizing the super keyword and resolving calls to parent class methods using inheritance relationships."
    }
  },
  {
    "name": "extract_class_body_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/javascript_typescript_scope_boundary_extractor.ts",
    "start_line": 62,
    "signature": "extract_class_body_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called by another method in the same class via this",
    "reasoning": "The method extract_class_body_boundaries is called by extract_class_boundaries at line 25 using this.extract_class_body_boundaries(). Method resolution fails because the simple method call path (method_resolver.ts:96-110) tries to resolve 'this' as a variable in scope, which returns null since 'this' is a keyword. Only the multi-step property chain path (line 240+) has special handling for the 'this' keyword.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call resolution path does not recognize self-reference keywords, only the multi-step property chain path handles them",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and the property chain path (line 240+) in method_resolver.ts, ensuring this.method() calls are resolved correctly regardless of chain length."
    }
  },
  {
    "name": "extract_struct_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/rust_scope_boundary_extractor.ts",
    "start_line": 68,
    "signature": "extract_struct_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called through this - simple two-element property chain not handled",
    "reasoning": "The method extract_struct_boundaries is called via this.extract_struct_boundaries() at line 45 by extract_rust_class_like_boundaries in the same class. Method resolution fails because the simple method call path (line 96-110 in method_resolver.ts) tries to resolve 'this' as a variable in scope, which returns null since 'this' is a keyword. Special handling for 'this' only exists in the property chain resolver for chains with length > 2.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call resolution path does not recognize self-reference keywords, only the multi-step property chain path handles them",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and the property chain path (line 240+) in method_resolver.ts, ensuring this.method() calls are resolved correctly regardless of chain length."
    }
  },
  {
    "name": "extract_impl_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/rust_scope_boundary_extractor.ts",
    "start_line": 142,
    "signature": "extract_impl_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called through this keyword",
    "reasoning": "The method is called via this.extract_impl_boundaries() on line 51 of the same file. Our call graph analysis detects it as a method call and extracts 'this' as the receiver, but fails to resolve it because the method resolver attempts to look up 'this' as a symbol in the resolution registry. The special handling for 'this' keyword only executes for property chains with length > 2, so simple this.method() calls (chain length = 2) fail to resolve.",
    "triage_analysis": {
      "detection_gap": "Method resolver does not handle 'this' keyword for simple method calls (property chain length ≤ 2). The this-keyword resolution logic exists in resolve_property_chain() but is only invoked for longer chains. For simple this.method() calls, the resolver tries to resolve 'this' as a regular symbol name, which returns null.",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Add 'this' keyword detection before symbol resolution in resolve_single_method_call() for all property chain lengths. Extract and reuse the this-resolution logic from resolve_property_chain() (lines 240-297) to handle both simple and complex this-based method calls."
    }
  },
  {
    "name": "extract_module_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/rust_scope_boundary_extractor.ts",
    "start_line": 167,
    "signature": "extract_module_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "dead code path - method on intentionally filtered execution branch",
    "reasoning": "The method extract_module_boundaries is called from extract_boundaries when scope_type === 'module', but scope_processor.ts:157 explicitly skips module scopes with a continue statement. This means the call site at line 31 is never executed in production code, only in tests. Our call graph analysis correctly identifies this method as never called.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis does not distinguish between 'never called due to bugs/missing features' vs 'never called due to intentional filtering'. Methods on dead code paths that are kept for testing or future use appear as false entry points.",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Add classification for methods that are: (1) private/internal, (2) only reachable from test files, or (3) on code paths explicitly filtered before execution. Mark these as 'dead-code-path' or 'test-only' rather than true entry points."
    }
  },
  {
    "name": "has_query",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/query_loader.ts",
    "start_line": 211,
    "signature": "has_query(language: Language): boolean",
    "root_cause": "exported for testing only",
    "reasoning": "The function has_query is exported from query_loader.ts but is ONLY called from test files (query_loader.test.ts, 33+ calls). It is never imported or used by any production code in packages/core/src. The production code only imports load_query, not has_query.",
    "triage_analysis": {
      "detection_gap": "Analysis scope excludes test files, so functions exported for testing purposes appear as uncalled entry points even when they are legitimately used by tests",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Add 'test_only_exports' classification category by running call graph analysis on both production and test code, then identifying functions called exclusively from test files to distinguish them from true internal false positives."
    }
  },
  {
    "name": "extract_arrow_function_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/javascript_typescript_scope_boundary_extractor.ts",
    "start_line": 218,
    "signature": "extract_arrow_function_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called through this - simple two-element property chain not handled",
    "reasoning": "The protected method extract_arrow_function_boundaries is called by extract_function_boundaries at line 91 using this.extract_arrow_function_boundaries(). Method resolution fails because the simple method call path (method_resolver.ts:96-110) tries to resolve 'this' as a variable in scope, which returns null since 'this' is a keyword. Special handling for 'this' only exists in the property chain resolver for chains with length > 2.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call resolution path does not recognize self-reference keywords, only the multi-step property chain path handles them",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and the property chain path (line 240+) in method_resolver.ts, ensuring this.method() calls are resolved correctly regardless of chain length."
    }
  },
  {
    "name": "extract_enum_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/rust_scope_boundary_extractor.ts",
    "start_line": 96,
    "signature": "extract_enum_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called through this - simple two-element property chain not handled",
    "reasoning": "The private method extract_enum_boundaries is called via this.extract_enum_boundaries() at line 47 by extract_rust_class_like_boundaries in the same class. Method resolution fails because the simple method call path (method_resolver.ts:96-110) tries to resolve 'this' as a variable in scope, which returns null since 'this' is a keyword. Special handling for 'this' only exists in the property chain resolver for chains with length > 2.",
    "triage_analysis": {
      "detection_gap": "Method resolver does not handle 'this' keyword for simple method calls (property chain length ≤ 2). The this-keyword resolution logic exists in resolve_property_chain() but is only invoked for longer chains. For simple this.method() calls, the resolver tries to resolve 'this' as a regular symbol name, which returns null.",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Add 'this' keyword detection before symbol resolution in resolve_single_method_call() for all property chain lengths. Extract and reuse the this-resolution logic from resolve_property_chain() (lines 240-297) to handle both simple and complex this-based method calls."
    }
  },
  {
    "name": "extract_trait_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/rust_scope_boundary_extractor.ts",
    "start_line": 119,
    "signature": "extract_trait_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called through this - simple two-element property chain not handled",
    "reasoning": "The private method extract_trait_boundaries is called via this.extract_trait_boundaries() at line 49 by extract_rust_class_like_boundaries in the same class. Method resolution fails because the simple method call path (method_resolver.ts:96-110) tries to resolve 'this' as a variable in scope, which returns null since 'this' is a keyword. Special handling for 'this' only exists in the property chain resolver for chains with length > 2.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call resolution path does not recognize self-reference keywords, only the multi-step property chain path handles them",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and the property chain path (line 240+) in method_resolver.ts, ensuring this.method() calls are resolved correctly regardless of chain length."
    }
  },
  {
    "name": "extract_interface_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/typescript_scope_boundary_extractor.ts",
    "start_line": 71,
    "signature": "extract_interface_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called through this - simple two-element property chain not handled",
    "reasoning": "The private method extract_interface_boundaries is called at line 49 via this.extract_interface_boundaries() by extract_typescript_class_like_boundaries in the same class. Method resolution fails because the simple method call path (method_resolver.ts:96-110) tries to resolve 'this' as a variable in scope, which returns null since 'this' is a keyword. Special handling for 'this' only exists in the property chain resolver for chains with length > 2.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call resolution path does not recognize self-reference keywords, only the multi-step property chain path handles them",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and the property chain path (line 240+) in method_resolver.ts, ensuring this.method() calls are resolved correctly regardless of chain length."
    }
  },
  {
    "name": "extract_enum_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/typescript_scope_boundary_extractor.ts",
    "start_line": 95,
    "signature": "extract_enum_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called through self-reference (this/self)",
    "reasoning": "The method extract_enum_boundaries is called at line 53 via this.extract_enum_boundaries() from within the same class. The call graph analysis failed to resolve method calls where the receiver is 'this', which requires looking up the enclosing class scope and matching the method name to a definition within that class.",
    "triage_analysis": {
      "detection_gap": "Method call resolution does not handle 'this' receiver - when receiver_location points to 'this' keyword, the system fails to find the enclosing class scope and resolve the method name within that class's definitions, preventing the call from being registered in resolved_calls_by_file",
      "existing_task_fixes": [
        "task-epic-11.152",
        "task-epic-11.136",
        "task-epic-11.133",
        "task-epic-11.109.6"
      ],
      "suggested_new_task_fix": "Implement self-reference receiver resolution: detect when receiver is 'this'/'self'/equivalent, walk up scope tree to find enclosing class, and resolve method by name within class scope definitions. Should handle this.method(), super.method(), and ClassName.staticMethod() patterns."
    }
  },
  {
    "name": "extract_interface_body_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/typescript_scope_boundary_extractor.ts",
    "start_line": 120,
    "signature": "extract_interface_body_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called through this - simple two-element property chain not handled",
    "reasoning": "The private method extract_interface_body_boundaries is called at line 51 via this.extract_interface_body_boundaries() by extract_typescript_class_like_boundaries in the same class. Method resolution fails because the simple method call path (method_resolver.ts:96-110) tries to resolve 'this' as a variable in scope, which returns null since 'this' is a keyword. Special handling for 'this' only exists in the property chain resolver for chains with length > 2.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call resolution path does not recognize self-reference keywords, only the multi-step property chain path handles them",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and the property chain path (line 240+) in method_resolver.ts, ensuring this.method() calls are resolved correctly regardless of chain length."
    }
  },
  {
    "name": "extract_enum_body_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/typescript_scope_boundary_extractor.ts",
    "start_line": 145,
    "signature": "extract_enum_body_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called through this within same class",
    "reasoning": "extract_enum_body_boundaries is a private method called via this.extract_enum_body_boundaries() at line 55 in the same class. Our call graph analysis captures this. method calls but fails to resolve them when this refers to the containing class, preventing the call from being tracked.",
    "triage_analysis": {
      "detection_gap": "Method resolver fails to resolve this.method() calls where the caller method is inside the same class as the callee method, likely due to this keyword resolution failing to find the containing class type in the method's own scope context",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Add test coverage and fix for this.method() resolution within class methods by improving the containing class lookup in resolve_property_chain() to handle cases where the call site is inside a method of the same class being resolved"
    }
  },
  {
    "name": "extract_namespace_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/typescript_scope_boundary_extractor.ts",
    "start_line": 170,
    "signature": "extract_namespace_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called through this - simple two-element property chain not handled",
    "reasoning": "The private method extract_namespace_boundaries is called at line 30 via this.extract_namespace_boundaries() by extract_boundaries in the same class. Method resolution fails because the simple method call path (method_resolver.ts:96-110) tries to resolve 'this' as a variable in scope, which returns null since 'this' is a keyword. Special handling for 'this' only exists in the property chain resolver for chains with length > 2.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call resolution path does not recognize self-reference keywords, only the multi-step property chain path handles them",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Add 'this' keyword detection before symbol resolution in resolve_single_method_call() for all property chain lengths. Extract and reuse the this-resolution logic from resolve_property_chain() (lines 240-297) to handle both simple and complex this-based method calls."
    }
  },
  {
    "name": "extract_class_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/scope_boundary_base.ts",
    "start_line": 97,
    "signature": "extract_class_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "protected method called by parent class",
    "reasoning": "extract_class_boundaries is a protected template method called only by extract_boundaries (line 75) within the same class hierarchy via this.extract_class_boundaries(). Internal method calls using 'this' or 'super' are not captured as SymbolReferences during semantic indexing, so they never appear in ResolutionRegistry.resolved_calls_by_file and are excluded from get_all_referenced_symbols().",
    "triage_analysis": {
      "detection_gap": "Call graph analysis only tracks calls that create SymbolReference objects during semantic indexing. Internal OOP method calls (this.method(), super.method()) are not captured by tree-sitter queries as references, so they never enter the resolution pipeline and appear as uncalled functions.",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Create task to capture internal method calls (this/self/super) in tree-sitter queries and process them as SymbolReferences during semantic indexing. Add resolution strategy to look up methods within the caller's enclosing class and parent classes."
    }
  },
  {
    "name": "extract_function_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/scope_boundary_base.ts",
    "start_line": 126,
    "signature": "extract_function_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called by parent class",
    "reasoning": "The protected method extract_function_boundaries is called internally via this.extract_function_boundaries() from the public extract_boundaries method (line 78) and extract_constructor_boundaries method (line 160) within the same class. These internal polymorphic method calls via the 'this' reference are not being tracked in the call graph, causing the method to appear as an entry point despite being actively used.",
    "triage_analysis": {
      "detection_gap": "Internal method calls via 'this' reference are not being resolved and tracked in the call graph. The method resolver can handle 'this' keyword, but internal same-class method calls are not creating proper call graph edges, so they don't appear in get_all_referenced_symbols().",
      "existing_task_fixes": [
        "task-110",
        "task-43"
      ],
      "suggested_new_task_fix": "Add specific handling for internal method calls (same-class calls via 'this') to ensure they are captured as references and included in the call graph before tackling the larger polymorphic dispatch problem."
    }
  },
  {
    "name": "format_all_results",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/validate_captures.ts",
    "start_line": 393,
    "signature": "format_all_results(results: ValidationResult[]): string",
    "root_cause": "external CLI/script caller - outside analysis scope",
    "reasoning": "The function format_all_results is called from /Users/chuck/workspace/ariadne/scripts/validate_captures.ts (lines 53 and 57), which is outside the packages/core analysis scope. The call graph analysis only scans packages/core production code (excluding test files), so this legitimate external caller is not detected, making format_all_results appear as an uncalled entry point within the analyzed scope.",
    "triage_analysis": {
      "detection_gap": "Analysis scope excludes external callers in scripts/ directory, so functions exported for CLI/tooling use appear as entry points even when they are called from outside the analyzed codebase",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Extend analysis scope to include scripts/ directory OR add classification category for 'CLI/tooling entry points' to distinguish legitimate external entry points from internal false positives that indicate call graph analysis bugs."
    }
  },
  {
    "name": "extract_block_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/javascript_typescript_scope_boundary_extractor.ts",
    "start_line": 202,
    "signature": "extract_block_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called by parent class through this",
    "reasoning": "The protected method extract_block_boundaries is called by parent class CommonScopeBoundaryExtractor.extract_boundaries() at scope_boundary_base.ts:82 using this.extract_block_boundaries(). Method resolution fails because the simple method call path (line 96-110 in method_resolver.ts) tries to resolve 'this' as a variable in scope, which returns null since 'this' is a keyword. Only the multi-step property chain path (line 240+) has special handling for the 'this' keyword.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call resolution path does not recognize self-reference keywords, only the multi-step property chain path handles them",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and the property chain path (line 240+) in method_resolver.ts, ensuring this.method() calls are resolved correctly regardless of chain length."
    }
  },
  {
    "name": "extract_class_boundaries_from_definition",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/python_scope_boundary_extractor.ts",
    "start_line": 56,
    "signature": "extract_class_boundaries_from_definition(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called through this - simple two-element property chain not handled",
    "reasoning": "The private method extract_class_boundaries_from_definition is called at lines 46 and 48 via this.extract_class_boundaries_from_definition() by extract_class_boundaries in the same class. Method resolution fails because the simple method call path (method_resolver.ts:96-110) tries to resolve 'this' as a variable in scope, which returns null since 'this' is a keyword. Special handling for 'this' only exists in the property chain resolver for chains with length > 2.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call resolution path does not recognize self-reference keywords, only the multi-step property chain path handles them",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and the property chain path (line 240+) in method_resolver.ts, ensuring this.method() calls are resolved correctly regardless of chain length."
    }
  },
  {
    "name": "extract_regular_function_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/python_scope_boundary_extractor.ts",
    "start_line": 115,
    "signature": "extract_regular_function_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called through this - simple two-element property chain not handled",
    "reasoning": "The private method extract_regular_function_boundaries is called at line 103 via this.extract_regular_function_boundaries() by extract_function_boundaries in the same class. Method resolution fails because the simple method call path (method_resolver.ts:96-110) tries to resolve 'this' as a variable in scope, which returns null since 'this' is a keyword. Special handling for 'this' only exists in the property chain resolver for chains with length > 2.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call resolution path does not recognize self-reference keywords, only the multi-step property chain path handles them",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and the property chain path (line 240+) in method_resolver.ts, ensuring this.method() calls are resolved correctly regardless of chain length."
    }
  },
  {
    "name": "extract_block_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/python_scope_boundary_extractor.ts",
    "start_line": 166,
    "signature": "extract_block_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called by parent class through polymorphic dispatch",
    "reasoning": "The protected method extract_block_boundaries is called by its parent class CommonScopeBoundaryExtractor.extract_boundaries() at line 82 via this.extract_block_boundaries(). This is a Template Method pattern where the base class dispatches to protected methods overridden by subclasses. The call graph analysis doesn't track polymorphic dispatch through 'this.methodName()' calls within class hierarchies.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis fails to resolve polymorphic method dispatch where parent class methods call this.methodName() - it doesn't track which concrete implementations (parent or child) will be invoked at runtime, and doesn't create edges to all possible override implementations in the class hierarchy",
      "existing_task_fixes": [
        "task-110"
      ],
      "suggested_new_task_fix": "Add visibility tracking (public/protected/private) to method definitions in semantic index, and exclude protected/private methods from entry point detection since they are internal APIs not external entry points."
    }
  },
  {
    "name": "extract_lambda_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/python_scope_boundary_extractor.ts",
    "start_line": 248,
    "signature": "extract_lambda_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "investigation error - function not actually misidentified",
    "reasoning": "The function extract_lambda_boundaries does not appear in internal_misidentified.json, indicating the call graph analysis correctly detected it is called via this.extract_lambda_boundaries() at line 105. Structurally identical methods (extract_regular_function_boundaries, extract_decorated_function_boundaries) in the same file were misidentified, suggesting either intermittent resolution success or an error in the investigation task data.",
    "triage_analysis": {
      "detection_gap": "None - this function was correctly identified as called. However, similar this.method() calls in the same class were not resolved, indicating possible non-deterministic behavior in the method resolver for simple two-element property chains (this.method).",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Investigate why some this.method() calls in PythonScopeBoundaryExtractor are resolved correctly (extract_lambda_boundaries) while others fail (extract_regular_function_boundaries, extract_decorated_function_boundaries) despite identical call patterns. Add test coverage to prevent regression."
    }
  },
  {
    "name": "extract_field_list_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/rust_scope_boundary_extractor.ts",
    "start_line": 195,
    "signature": "extract_field_list_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called through this keyword",
    "reasoning": "The function extract_field_list_boundaries is called from extract_rust_class_like_boundaries using this.extract_field_list_boundaries(). The call graph analysis has infrastructure to resolve this.method() calls (tree-sitter captures, method resolver with this handling), but resolution is failing, likely because the semantic index isn't capturing the call with proper receiver_location context or the class scope lookup is failing.",
    "triage_analysis": {
      "detection_gap": "this.method() call resolution fails - either the reference builder doesn't capture this as receiver with proper context (receiver_location, property_chain), or the method resolver's class scope walking/definition lookup fails for TypeScript classes",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Add comprehensive testing and debugging for this.method() call resolution across all languages. Debug the exact failure point in the resolution pipeline (semantic index capture vs method resolver) and fix the root cause with integration tests for internal class method calls."
    }
  },
  {
    "name": "extract_enum_variant_list_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/rust_scope_boundary_extractor.ts",
    "start_line": 209,
    "signature": "extract_enum_variant_list_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called through this - simple two-element property chain not handled",
    "reasoning": "The private method extract_enum_variant_list_boundaries is called via this.extract_enum_variant_list_boundaries() at line 55 by extract_rust_class_like_boundaries in the same class. Method resolution fails because the simple method call path (method_resolver.ts:96-110) tries to resolve 'this' as a variable in scope, which returns null since 'this' is a keyword. Special handling for 'this' only exists in the property chain resolver for chains with length > 2.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call resolution path does not recognize self-reference keywords, only the multi-step property chain path handles them",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and the property chain path (line 240+) in method_resolver.ts, ensuring this.method() calls are resolved correctly regardless of chain length."
    }
  },
  {
    "name": "extract_declaration_list_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/rust_scope_boundary_extractor.ts",
    "start_line": 223,
    "signature": "extract_declaration_list_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called by parent class through this",
    "reasoning": "The private method extract_declaration_list_boundaries is called at line 57 via this.extract_declaration_list_boundaries() from the extract_rust_class_like_boundaries method in the same class. Method resolution fails because the simple method call path (line 96-110 in method_resolver.ts) tries to resolve 'this' as a variable in scope, which returns null since 'this' is a keyword. Only the multi-step property chain path (line 240+) has special handling for the 'this' keyword.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call resolution path does not recognize self-reference keywords, only the multi-step property chain path handles them",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and the property chain path (line 240+) in method_resolver.ts, ensuring this.method() calls are resolved correctly regardless of chain length."
    }
  },
  {
    "name": "extract_block_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/scope_boundary_base.ts",
    "start_line": 168,
    "signature": "extract_block_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called by parent class through this",
    "reasoning": "The protected method extract_block_boundaries is called by parent class CommonScopeBoundaryExtractor.extract_boundaries() at scope_boundary_base.ts:82 using this.extract_block_boundaries(). Method resolution fails because the simple method call path (line 96-110 in method_resolver.ts) tries to resolve 'this' as a variable in scope, which returns null since 'this' is a keyword. Only the multi-step property chain path (line 240+) has special handling for the 'this' keyword.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call resolution path does not recognize self-reference keywords, only the multi-step property chain path handles them",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and the property chain path (line 240+) in method_resolver.ts, ensuring this.method() calls are resolved correctly regardless of chain length."
    }
  },
  {
    "name": "create_simple_mock_node",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/test_utils.ts",
    "start_line": 45,
    "signature": "create_simple_mock_node(nodeType: string, text: string, additionalProps: Partial<SyntaxNode>): SyntaxNode",
    "root_cause": "dead code - exported but unused test utility",
    "reasoning": "The function create_simple_mock_node is exported from test_utils.ts but has ZERO callers anywhere in the codebase - not in production code, not even in test files. Git history confirms it was never imported or used since creation. This is genuinely unused dead code, not a false positive detection.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis correctly identifies the function as uncalled, but lacks classification to distinguish between legitimate API entry points, test-only exports, CLI entry points, and dead code that should be removed from the codebase.",
      "existing_task_fixes": [
        "task-158"
      ],
      "suggested_new_task_fix": "Create entry point classification system with categories (PUBLIC_API, CLI_SCRIPT, TEST_ONLY_EXPORT, DEAD_CODE, MODULE_INITIALIZATION) and optionally run call graph analysis on test files to identify functions only used in tests versus genuinely unused code."
    }
  },
  {
    "name": "has_cycle",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/project/import_graph.ts",
    "start_line": 275,
    "signature": "has_cycle(): unknown",
    "root_cause": "nested function within parent function scope",
    "reasoning": "The function has_cycle is a nested arrow function defined at line 275 inside the detect_cycle method (line 271). It is called recursively at line 291 and from the parent scope at line 301. Our call graph analysis captures nested functions as CallableDefinitions but fails to resolve calls to them through lexical scope lookup, causing them to appear as uncalled entry points.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis captures nested/inner function definitions as CallableDefinitions but does not resolve call identifiers to locally-scoped function definitions during reference resolution, preventing call graph edges from being created for nested function invocations",
      "existing_task_fixes": [
        "task-110"
      ],
      "suggested_new_task_fix": "Extend task-110 to ensure lexical scope resolution connects call identifiers to nested function definitions in the same scope, OR add classification filter to exclude functions whose defining_scope_id is a function/method scope from entry point detection since nested functions can never be external entry points."
    }
  },
  {
    "name": "detect_cycle",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/project/import_graph.ts",
    "start_line": 271,
    "signature": "detect_cycle(file_path: FilePath): FilePath[]",
    "root_cause": "test-only public method",
    "reasoning": "The detect_cycle method is a public method on the exported ImportGraph class, but it is never called by any production code in packages/core. All 4 calls to detect_cycle exist only in import_graph.test.ts. Since test files are excluded from the analysis scope, the method correctly appears as an entry point.",
    "triage_analysis": {
      "detection_gap": "Not a detection gap - this is correct behavior. The method is legitimately uncalled within the production code scope and is part of the public API available to external consumers.",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Add classification category to distinguish test-only API methods from core API methods, helping differentiate legitimate public entry points from internal functions incorrectly detected as entry points."
    }
  },
  {
    "name": "add_class",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 234,
    "signature": "add_class(definition: {\n    symbol_id: SymbolId;\n    name: SymbolName;\n    location: Location;\n    scope_id: ScopeId;\n    is_exported?: boolean;\n    export?: ExportMetadata;\n    extends?: SymbolName[];\n    generics?: SymbolName[];\n    docstring?: readonly string[];\n  }): DefinitionBuilder",
    "root_cause": "method called through functional callback stored in Map",
    "reasoning": "The add_class method is called from arrow functions stored as values in LanguageBuilderConfig Maps (typescript_builder_config.ts:378, python_builder_config.ts:58, javascript_builder_config.ts:112, rust_builder.ts:62,89). These callbacks are retrieved via config.get() and invoked via handler.process(), creating multiple layers of indirection. Our call graph analysis only detects direct function calls from tree-sitter captures, not calls inside callback function bodies stored in data structures.",
    "triage_analysis": {
      "detection_gap": "Reference detection only captures direct call expressions in the syntax tree. We don't track function values stored in Maps, don't analyze callback function bodies to find nested calls, and don't connect method calls through parameters (builder.add_class) to their definitions (DefinitionBuilder.add_class).",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Implement higher-order function analysis to track function values stored in data structures, analyze callback/arrow function bodies, and connect calls inside callbacks to their definitions. Alternatively, create a whitelist for builder/handler pattern methods to exclude them from entry point detection."
    }
  },
  {
    "name": "find_class_by_name",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 363,
    "signature": "find_class_by_name(name: SymbolName): SymbolId | undefined",
    "root_cause": "method called inside anonymous function callbacks stored in configuration Map",
    "reasoning": "The find_class_by_name method is called 4 times from anonymous arrow functions that are stored as values in RUST_BUILDER_CONFIG Map (rust_builder.ts:471,507,577,612). These anonymous functions are invoked via dynamic dispatch (handler.process()), but our call graph analysis does not capture inline arrow functions as CallableDefinitions, so calls made inside these closures have no caller attribution.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis does not track calls made inside anonymous/inline arrow functions that are stored in data structures (Maps, objects) and invoked via dynamic dispatch patterns. Inline arrow functions are not captured as function definitions, and calls inside these closures have no enclosing_function_scope_id linking them to a named caller.",
      "existing_task_fixes": [
        "task-110"
      ],
      "suggested_new_task_fix": "Extend task-110 to capture ALL arrow functions (including inline/anonymous ones) as CallableDefinitions with synthetic location-based names, and attribute calls inside arrow function bodies to that arrow function's SymbolId to create proper call graph edges for configuration-driven callback patterns."
    }
  },
  {
    "name": "find_interface_by_name",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 375,
    "signature": "find_interface_by_name(name: SymbolName): SymbolId | undefined",
    "root_cause": "method called through interface",
    "reasoning": "find_interface_by_name is called from within inline arrow function callbacks defined in RUST_BUILDER_CONFIG. These arrow functions are invoked via handler.process(), but the arrow functions themselves are not tracked as callable definitions in our semantic index. Therefore, calls made from within them have no caller attribution.",
    "triage_analysis": {
      "detection_gap": "Arrow functions and lambda expressions are not tracked as CallableDefinition types. When build_function_nodes() creates call graph nodes, it only processes named functions/methods/constructors. Calls made from arrow function scopes cannot be attributed to any caller, making their callees appear uncalled.",
      "existing_task_fixes": [
        "task-158",
        "task-110"
      ],
      "suggested_new_task_fix": "Add LambdaDefinition to CallableDefinition union type and update language builders to extract arrow functions/lambdas as callable definitions with body_scope_id tracking, enabling proper call attribution for functional programming patterns."
    }
  },
  {
    "name": "add_parameter_to_callable",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 444,
    "signature": "add_parameter_to_callable(callable_id: SymbolId, definition: {\n      symbol_id: SymbolId;\n      name: SymbolName;\n      location: Location;\n      scope_id: ScopeId;\n      type?: SymbolName;\n      default_value?: string;\n      optional?: boolean;\n    }, rest: any): DefinitionBuilder",
    "root_cause": "method called through callback parameter",
    "reasoning": "The method is called inside callback functions that receive a DefinitionBuilder instance as a parameter. These callbacks are stored in language config Maps and invoked by semantic_index.ts. The call graph tracks the callback invocation but does not analyze what methods the callback calls on its parameters, causing false positive entry point detection.",
    "triage_analysis": {
      "detection_gap": "No type flow tracking through function parameters - when objects are passed to callbacks, method calls on those parameters inside the callback body are not attributed to the calling context",
      "existing_task_fixes": [
        "task-155",
        "task-epic-11.140"
      ],
      "suggested_new_task_fix": "Add callback body analysis to track method calls on function parameters and link them back to the invocation site where the parameter is passed."
    }
  },
  {
    "name": "add_variable",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 501,
    "signature": "add_variable(definition: {\n    kind: \"variable\" | \"constant\";\n    symbol_id: SymbolId;\n    name: SymbolName;\n    location: Location;\n    scope_id: ScopeId;\n    is_exported?: boolean;\n    export?: ExportMetadata;\n    type?: SymbolName;\n    initial_value?: string;\n    docstring?: string;\n  }): DefinitionBuilder",
    "root_cause": "method called from anonymous function/closure callback",
    "reasoning": "The add_variable method is called exclusively from arrow function callbacks defined in language builder configs (python_builder_config.ts, javascript_builder_config.ts, rust_builder.ts). These callbacks are passed to the process_definitions function but are not tracked as callable definitions in the semantic index, so calls made from within them have no associated caller scope.",
    "triage_analysis": {
      "detection_gap": "Anonymous functions and closures (arrow functions, function expressions, lambdas) are not tracked as CallableDefinition types, so calls made from within these scopes cannot be associated with a caller in the call graph, causing called methods to appear as entry points",
      "existing_task_fixes": [
        "task-158"
      ],
      "suggested_new_task_fix": "Create task to track function expressions, arrow functions, and closures as callable definitions in the semantic index, ensuring calls made from these scopes are properly attributed to their enclosing callable in call graph detection."
    }
  },
  {
    "name": "add_import",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 531,
    "signature": "add_import(definition: {\n    symbol_id: SymbolId;\n    name: SymbolName;\n    location: Location;\n    scope_id: ScopeId;\n    import_path: ModulePath;\n    original_name?: SymbolName;\n    import_kind: \"named\" | \"default\" | \"namespace\";\n    is_type_only?: boolean;\n    export?: ExportMetadata;\n  }): DefinitionBuilder",
    "root_cause": "callback function invocation through object map lookup",
    "reasoning": "The add_import method is called 23 times in production code from arrow functions stored in LanguageBuilderConfig Maps. These arrow functions are invoked dynamically via handler.process(capture, builder, context) pattern in semantic_index.ts:219. The call graph analysis cannot trace calls through this callback pattern because it only tracks direct AST references, not function references stored in data structures and invoked through dynamic property access.",
    "triage_analysis": {
      "detection_gap": "No data flow analysis for function references stored in Maps/objects - the resolution registry only tracks direct calls from the AST, missing the indirect invocation path: process_definitions() → config.get(name).process() → builder.add_import()",
      "existing_task_fixes": [
        "task-110"
      ],
      "suggested_new_task_fix": "Implement configuration-pattern recognition that detects Map<string, {process: Function}> patterns and creates call graph edges from the dispatcher loop to all registered handler callbacks, specifically handling the LanguageBuilderConfig pattern used throughout index_single_file."
    }
  },
  {
    "name": "add_property_to_class",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 560,
    "signature": "add_property_to_class(class_id: SymbolId, definition: {\n      symbol_id: SymbolId;\n      name: SymbolName;\n      location: Location;\n      scope_id: ScopeId;\n      type?: SymbolName;\n      initial_value?: string;\n      access_modifier?: \"public\" | \"private\" | \"protected\";\n      static?: boolean;\n      readonly?: boolean;\n      abstract?: boolean;\n    }, rest: any): DefinitionBuilder",
    "root_cause": "method called through configuration callback",
    "reasoning": "The function is called from 9+ locations inside anonymous arrow functions stored in Map configuration objects (typescript_builder_config.ts, javascript_builder_config.ts, python_builder_config.ts, rust_builder.ts). These arrow functions are invoked via dynamic dispatch (config.get(key).process()), and our call graph analysis only tracks direct syntactic calls, not calls from within dynamically-invoked anonymous functions.",
    "triage_analysis": {
      "detection_gap": "Anonymous arrow functions stored in data structures are not tracked as callable nodes, so calls made from within their bodies are never attributed to a caller, causing the called functions to appear as entry points",
      "existing_task_fixes": [
        "task-110"
      ],
      "suggested_new_task_fix": "Extend build_function_nodes() to create synthetic callable nodes for anonymous arrow functions in object/map values, tracking their enclosed calls and attributing them to the dynamic dispatch call site"
    }
  },
  {
    "name": "add_interface",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 593,
    "signature": "add_interface(definition: {\n    symbol_id: SymbolId;\n    name: SymbolName;\n    location: Location;\n    scope_id: ScopeId;\n    is_exported?: boolean;\n    export?: ExportMetadata;\n    extends?: SymbolName[];\n    generics?: SymbolName[];\n  }): DefinitionBuilder",
    "root_cause": "framework callback method",
    "reasoning": "add_interface is NOT actually in internal_misidentified.json - it appears to have been correctly identified as called. However, 7+ sibling methods from the same DefinitionBuilder class using identical callback patterns ARE misidentified. These methods are called from anonymous arrow functions stored in language config Maps and invoked via handler.process() dynamic dispatch.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis does not track function references stored in data structures (Maps/objects) or trace calls made inside callback functions back to their framework invocation points. Anonymous/inline arrow functions are not captured as CallableDefinitions, so calls from their bodies have no caller attribution.",
      "existing_task_fixes": [
        "task-110",
        "task-158",
        "task-155"
      ],
      "suggested_new_task_fix": "Extend task-110 to detect Map<string, {process: Function}> configuration patterns and create call graph edges from dispatcher loops (semantic_index.ts:219) to all registered handler callbacks, tracking calls made inside those anonymous arrow function bodies as reachable from the dynamic invocation site."
    }
  },
  {
    "name": "add_method_signature_to_interface",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 624,
    "signature": "add_method_signature_to_interface(interface_id: SymbolId, definition: {\n      symbol_id: SymbolId;\n      name: SymbolName;\n      location: Location;\n      scope_id: ScopeId;\n      generics?: SymbolName[];\n      return_type?: SymbolName;\n    }): DefinitionBuilder",
    "root_cause": "NOT MISIDENTIFIED - function correctly detected as called",
    "reasoning": "The function add_method_signature_to_interface does not appear in internal_misidentified.json, meaning the call graph analysis correctly identified it as called. The function is invoked from anonymous arrow functions in configuration maps (typescript_builder_config.ts:100, python_builder_config.ts:91, rust_builder.ts:258), and despite this indirect invocation pattern, the call was successfully tracked.",
    "triage_analysis": {
      "detection_gap": "No detection gap for this specific function - it was correctly identified. However, similar DefinitionBuilder methods (add_method_to_class, add_function, add_class) ARE misidentified because anonymous/inline arrow functions are not captured as CallableDefinitions, preventing proper caller attribution for calls made inside arrow function bodies stored in configuration Maps.",
      "existing_task_fixes": [
        "task-110",
        "task-158",
        "task-155"
      ],
      "suggested_new_task_fix": "Extend tree-sitter queries to capture ALL arrow functions (including inline/anonymous ones) as CallableDefinitions with synthetic location-based SymbolIds, and include them in build_function_nodes() processing to ensure calls from arrow function bodies are properly attributed to a caller in the call graph."
    }
  },
  {
    "name": "add_property_signature_to_interface",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 657,
    "signature": "add_property_signature_to_interface(interface_id: SymbolId, definition: {\n      symbol_id: SymbolId;\n      name: SymbolName;\n      location: Location;\n      type?: SymbolName;\n      scope_id: ScopeId;\n    }): DefinitionBuilder",
    "root_cause": "method called through callback function in configuration object",
    "reasoning": "The method is called from anonymous arrow functions stored in TYPESCRIPT_BUILDER_CONFIG and PYTHON_BUILDER_CONFIG Maps. These callbacks are invoked indirectly via handler.process(capture, builder, context) in semantic_index.ts. The call graph only tracks direct call expressions, not invocations through callback functions.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis does not track function value references or callback invocations. The get_all_referenced_symbols() method only captures direct call expressions from tree-sitter queries, missing methods invoked through higher-order functions, callbacks, or function pointers stored in data structures.",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Add tracking for function value references (when functions are passed as arguments or stored in objects without being called) and mark functions with such references as 'potentially called indirectly' to exclude them from entry point detection."
    }
  },
  {
    "name": "add_type_alias",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 685,
    "signature": "add_type_alias(definition: {\n    kind: \"type\" | \"type_alias\";\n    symbol_id: SymbolId;\n    name: SymbolName;\n    location: Location;\n    scope_id: ScopeId;\n    is_exported?: boolean;\n    export?: ExportMetadata;\n    type_expression?: SymbolName;\n    generics?: SymbolName[];\n  }): DefinitionBuilder",
    "root_cause": "framework callback method",
    "reasoning": "The method is called from anonymous arrow functions stored in language configuration Maps (typescript_builder_config.ts:150, python_builder_config.ts:1112, rust_builder.ts:899,928,953). These callbacks are invoked via dynamic dispatch (handler.process()) in semantic_index.ts:219, but the call graph only tracks direct syntactic calls, not higher-order function invocations.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis does not track function references stored in data structures (Maps/objects) or trace calls made inside callback functions back to their framework invocation points",
      "existing_task_fixes": [
        "task-110"
      ],
      "suggested_new_task_fix": "Expand Task 110 to add callback invocation tracking: when a function stored in a Map/object is retrieved and invoked, track all calls made inside that callback as reachable from the invocation site, creating potential call graph edges for configuration-driven dispatch patterns"
    }
  },
  {
    "name": "add_enum",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 707,
    "signature": "add_enum(definition: {\n    symbol_id: SymbolId;\n    name: SymbolName;\n    location: Location;\n    scope_id: ScopeId;\n    is_exported?: boolean;\n    export?: ExportMetadata;\n    is_const?: boolean;\n    generics?: SymbolName[];\n  }): DefinitionBuilder",
    "root_cause": "method called through configuration-driven callback pattern",
    "reasoning": "The add_enum method is called within anonymous arrow functions stored in LanguageBuilderConfig Maps. These handlers are invoked dynamically via config.get(name).process(capture, builder, context), creating indirection. The call graph analysis only tracks direct method calls captured by tree-sitter queries, not calls made inside callbacks stored in data structures.",
    "triage_analysis": {
      "detection_gap": "Call graph does not track method calls within anonymous functions stored in configuration objects and invoked through dynamic dispatch patterns",
      "existing_task_fixes": [
        "task-110"
      ],
      "suggested_new_task_fix": "Add builder pattern detection heuristic: exclude methods that return 'this' and follow add_*/set_*/with_* naming from entry point analysis, as these are typically called indirectly through fluent interfaces."
    }
  },
  {
    "name": "add_enum_member",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 738,
    "signature": "add_enum_member(enum_id: SymbolId, definition: {\n      symbol_id: SymbolId;\n      name: SymbolName;\n      location: Location;\n      value?: string | number;\n    }): DefinitionBuilder",
    "root_cause": "Anonymous arrow function callback stored in configuration object",
    "reasoning": "The method is called inside anonymous arrow functions used as property values in configuration Maps (e.g., typescript_builder_config.ts:209). These arrow functions create scopes but are not captured as function definitions because tree-sitter queries only capture arrow functions assigned to variables. Therefore, calls inside them are orphaned—tracked to a scope but not associated with any caller function node in the call graph.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis only includes functions captured as @definition.function, which excludes anonymous arrow functions used as object properties, passed as arguments, or used in IIFEs. The get_callable_definitions() method filters by kind='function'|'method'|'constructor', missing 125+ builder method calls across language config files.",
      "existing_task_fixes": [
        "task-110"
      ],
      "suggested_new_task_fix": "Extend tree-sitter queries to capture all arrow functions regardless of context (not just variable assignments), generate synthetic names for anonymous functions, and include them in callable definitions to track their internal calls in the call graph."
    }
  },
  {
    "name": "add_namespace",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 761,
    "signature": "add_namespace(definition: {\n    symbol_id: SymbolId;\n    name: SymbolName;\n    location: Location;\n    scope_id: ScopeId;\n    is_exported?: boolean;\n    export?: ExportMetadata;\n  }): DefinitionBuilder",
    "root_cause": "method called through dynamically-invoked callbacks",
    "reasoning": "add_namespace is called from anonymous arrow functions stored in Map values (TYPESCRIPT_BUILDER_CONFIG, RUST_BUILDER_CONFIG). These arrow functions are invoked indirectly via handler.process() at semantic_index.ts:219,232. Our call graph analysis only tracks direct call expressions, not calls made through stored function references or inside callback functions.",
    "triage_analysis": {
      "detection_gap": "No data flow analysis to track function values through data structures (Maps, objects) and no detection of indirect invocations where stored callbacks are invoked through interface methods like handler.process()",
      "existing_task_fixes": [
        "task-110"
      ],
      "suggested_new_task_fix": "Implement basic callback flow tracking: detect arrow functions stored in object/Map literals, track when those stored functions are retrieved and invoked (e.g., handler.process()), and attribute calls made inside callbacks to the callback invocation site."
    }
  },
  {
    "name": "add_decorator_to_target",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 787,
    "signature": "add_decorator_to_target(target_id: SymbolId, decorator: {\n      defining_scope_id: ScopeId;\n      name: SymbolName;\n      arguments?: string[];\n      location: Location;\n    }): DefinitionBuilder",
    "root_cause": "method called through configuration callback pattern",
    "reasoning": "add_decorator_to_target is called from anonymous arrow functions stored as 'process' properties in language builder configuration Maps (TYPESCRIPT_BUILDER_CONFIG, PYTHON_BUILDER_CONFIG). These anonymous arrow functions are not tracked as CallableDefinition entries in our semantic index, so calls made from them are invisible to call graph analysis. The method appears uncalled because its only callers (7 anonymous process functions across language configs) don't exist in the call graph.",
    "triage_analysis": {
      "detection_gap": "Anonymous arrow functions and inline function expressions are not tracked as callable definitions. Only named functions, methods, and constructors are captured by get_callable_definitions(), causing any calls made from anonymous functions to be invisible to entry point detection.",
      "existing_task_fixes": [
        "task-110",
        "task-158"
      ],
      "suggested_new_task_fix": "Extend semantic index to track arrow function definitions and anonymous function expressions as first-class CallableDefinition entries, creating synthetic symbol IDs based on location and capturing their body_scope_id for call graph analysis."
    }
  },
  {
    "name": "build_class",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 849,
    "signature": "build_class(state: ClassBuilderState): ClassDefinition",
    "root_cause": "method called through callback function",
    "reasoning": "build_class is called at line 202 inside an arrow function callback passed to forEach(). The call graph analysis does not track calls made within arrow function/lambda callbacks, so the call to build_class was never detected, making it appear as an uncalled entry point.",
    "triage_analysis": {
      "detection_gap": "Does not track calls made within arrow function or lambda callback bodies passed to higher-order functions like forEach, map, filter",
      "existing_task_fixes": [
        "task-110"
      ],
      "suggested_new_task_fix": "Enhance tree-sitter queries to capture calls within arrow function bodies and associate them with the enclosing function scope that contains the higher-order function call"
    }
  },
  {
    "name": "build_method",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 874,
    "signature": "build_method(state: MethodBuilderState): MethodDefinition",
    "root_cause": "method called through this - simple two-element property chain not handled",
    "reasoning": "The build_method function is called internally at lines 851, 936, and 952 using this.build_method(). The method resolution system has special handling for 'this' keyword only in the property chain path (line 240+), which requires chain length > 2. Simple two-element chains like this.build_method() fall through to the simple method call path (lines 96-110), which tries to resolve 'this' as a variable and fails because it's a keyword, not a variable.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call path does not recognize self-reference keywords, only the multi-step property chain path handles them",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and the property chain path (line 240+) in method_resolver.ts, ensuring this.method() calls are resolved correctly."
    }
  },
  {
    "name": "build_constructor",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 889,
    "signature": "build_constructor(state: ConstructorBuilderState): ConstructorDefinition",
    "root_cause": "method called through JavaScript built-in higher-order function callback",
    "reasoning": "The build_constructor method is called at line 859 inside an anonymous arrow function passed to Array.map(): Array.from(state.constructors.values()).map((c) => this.build_constructor(c)). Our call graph analysis does not capture inline/anonymous arrow functions as CallableDefinitions, so calls made within these arrow function bodies have no caller attribution in the call graph, causing build_constructor to appear as an uncalled entry point.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis excludes anonymous/inline arrow functions from callable definitions (only captures arrow functions assigned to variables). Calls made inside these anonymous function bodies cannot be attributed to any caller, making their callees appear as false-positive entry points.",
      "existing_task_fixes": [
        "task-110",
        "task-155",
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend tree-sitter queries to capture ALL arrow functions (including inline/anonymous ones) as CallableDefinitions with synthetic location-based SymbolIds. Include them in build_function_nodes() to ensure calls from arrow function bodies are properly attributed to a caller in the call graph."
    }
  },
  {
    "name": "build_property",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 907,
    "signature": "build_property(state: PropertyBuilderState): PropertyDefinition",
    "root_cause": "cascading false positive from parent caller in arrow function callback",
    "reasoning": "build_property is called by build_class (line 854) via this.build_property(p). However, build_class itself is misidentified as an entry point because it's called at line 202 inside an arrow function callback passed to forEach(). Since build_class appears uncalled in the call graph, all functions it calls (including build_property) also have no traceable caller, creating a cascading false positive.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis does not track calls made within arrow function callback bodies passed to higher-order functions like forEach(). Additionally, this.method() calls are not resolved, preventing detection of the call from build_class to build_property even if build_class were correctly identified as called.",
      "existing_task_fixes": [
        "task-110",
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend build_function_nodes() to capture calls made inside arrow function bodies by associating them with the enclosing function scope that contains the higher-order function invocation (e.g., forEach call site), creating proper call graph edges through callback indirection."
    }
  },
  {
    "name": "build_function",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 915,
    "signature": "build_function(state: FunctionBuilderState): FunctionDefinition",
    "root_cause": "method called through this keyword",
    "reasoning": "build_function is a private method called via this.build_function(state) at line 199. The method resolver has a bug where property chains with length <= 2 try to resolve 'this' as a regular symbol instead of using special keyword handling. Only chains with length > 2 use the special this handling in resolve_property_chain().",
    "triage_analysis": {
      "detection_gap": "Property chain length check at method_resolver.ts:82 incorrectly routes short this.method() calls (length=2) to code path that tries to resolve 'this' as a symbol in scope, which fails because 'this' is a keyword. Special this handling only applies to longer chains (length > 2).",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Fix method_resolver.ts line 82 condition to route all property chains starting with 'this' to resolve_property_chain() regardless of length, or extract this handling into a shared function used by both code paths."
    }
  },
  {
    "name": "build_interface",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 934,
    "signature": "build_interface(state: InterfaceBuilderState): InterfaceDefinition",
    "root_cause": "method called through JavaScript built-in higher-order function callback",
    "reasoning": "The build_interface method is called at line 205 inside an anonymous arrow function callback passed to forEach(): this.interfaces.forEach((state, id) => { interfaces.set(id, this.build_interface(state)); }). Anonymous arrow functions create scopes but are not captured as CallableDefinitions in our tree-sitter queries (only arrow functions assigned to variables are captured). When find_enclosing_function_scope() attributes the call to build_interface to the arrow function's scope_id, that scope has no corresponding CallableNode in the call graph, so the call is never tracked as being made by any caller.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis excludes anonymous/inline arrow functions from callable definitions (only captures arrow functions assigned to variables). Calls made inside these anonymous function bodies cannot be attributed to any caller, making their callees appear as false-positive entry points.",
      "existing_task_fixes": [
        "task-110"
      ],
      "suggested_new_task_fix": "Modify find_enclosing_function_scope() to skip anonymous arrow function scopes and continue walking up the scope tree until finding a named callable (function/method/constructor with a corresponding CallableDefinition), ensuring calls inside arrow function callbacks are attributed to the enclosing named function rather than the anonymous callback scope."
    }
  },
  {
    "name": "build_enum",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 949,
    "signature": "build_enum(state: EnumBuilderState): EnumDefinition",
    "root_cause": "method called through this",
    "reasoning": "The method build_enum is called at line 208 via this.build_enum(state) within the DefinitionBuilder.build() method. Method resolution fails because the simple method call path (line 96-110 in method_resolver.ts) tries to resolve 'this' as a variable in scope, which returns null since 'this' is a keyword. Only the multi-step property chain path (line 240+) has special handling for the 'this' keyword.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call resolution path does not recognize self-reference keywords, only the multi-step property chain path handles them",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and the property chain path (line 240+) in method_resolver.ts, ensuring this.method() calls are resolved correctly regardless of chain length."
    }
  },
  {
    "name": "build_namespace",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 964,
    "signature": "build_namespace(state: NamespaceBuilderState): NamespaceDefinition",
    "root_cause": "investigation error - function not actually misidentified",
    "reasoning": "The function build_namespace does not appear in internal_misidentified.json, indicating the call graph analysis correctly detected it is called via this.build_namespace() at line 211. Structurally identical methods (build_class, build_enum, build_interface) in the same file were misidentified, suggesting either intermittent resolution success or an error in the investigation task data.",
    "triage_analysis": {
      "detection_gap": "None - this function was correctly identified as called. However, similar this.method() calls in the same class were not resolved, indicating possible non-deterministic behavior in the method resolver for simple two-element property chains (this.method).",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Investigate why some this.method() calls in DefinitionBuilder are resolved correctly (build_namespace) while others fail (build_class, build_enum, build_interface) despite identical call patterns. Add test coverage to prevent regression."
    }
  },
  {
    "name": "constructor",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/definitions/definition_builder.ts",
    "start_line": 185,
    "signature": "constructor(context: ProcessingContext)",
    "root_cause": "constructor call not tracked in call graph",
    "reasoning": "The DefinitionBuilder constructor IS called via 'new DefinitionBuilder(context)' in semantic_index.ts:207. However, our call graph analysis only tracks function and method calls, not constructor instantiations via 'new' expressions. Constructor call references are captured (type: 'construct') but not processed by detect_call_graph, making constructors appear uncalled.",
    "triage_analysis": {
      "detection_gap": "detect_call_graph does not process constructor call references (type: 'construct', call_type: 'constructor') when building call edges, only processing regular function/method calls (type: 'call')",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Update detect_call_graph.ts to process constructor call references (type: 'construct') and create call edges from instantiation sites to constructor/class symbols. Infrastructure exists (references captured, resolution works), just need to wire constructor references into call graph edge building."
    }
  },
  {
    "name": "is_valid_capture",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/capture_schema.ts",
    "start_line": 822,
    "signature": "is_valid_capture(capture_name: string): boolean",
    "root_cause": "exported for external use - CLI/script entry point",
    "reasoning": "The function is_valid_capture is called via the chain: scripts/validate_captures.ts → run_validation() → validate_all_languages() → validate_scm_file() → collect_stats() → is_valid_capture(). The root caller (scripts/validate_captures.ts) is outside the analysis scope which only covers packages/core/src production code, excluding scripts and test files. All functions in this chain are legitimate entry points exported for CLI/tooling use.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis does not track import relationships or module-level code as callable entities. Functions imported and called from files outside the analysis scope (scripts, external consumers) appear as uncalled even though they are part of legitimate entry point chains. The get_all_referenced_symbols() method only collects symbols from call references within analyzed files, missing import-based usage.",
      "existing_task_fixes": [
        "task-158"
      ],
      "suggested_new_task_fix": "Extend get_all_referenced_symbols() to include symbols that are imported (not just called) by tracking resolved import paths in ImportGraph. This would mark exported functions as referenced even when callers are outside analysis scope, distinguishing between true unused code and external API entry points."
    }
  },
  {
    "name": "get_capture_errors",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/capture_schema.ts",
    "start_line": 842,
    "signature": "get_capture_errors(capture_name: string): string[]",
    "root_cause": "CLI/script entry point called from outside analysis scope",
    "reasoning": "The function get_capture_errors is called by validate_captures (line 111), which is part of a call chain: get_capture_errors ← validate_captures ← validate_scm_file ← validate_all_languages ← run_validation. The top-level function run_validation is only called from scripts/validate_captures.ts (line 42), which is outside the packages/core analysis scope, making the entire chain appear as internal entry points within the analyzed scope.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis is scope-bound to packages/core production code and cannot track calls originating from scripts/ directory, causing functions that serve as CLI entry points to appear as uncalled internal functions even though they are legitimately called from outside the analysis boundary",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Implement multi-tier entry point classification system (Public API / CLI / Test / Internal) to distinguish between true internal entry points and functions called from outside the analysis scope boundary, with optional scope expansion to include scripts/ directory in analysis."
    }
  },
  {
    "name": "extract_type_from_annotation",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/metadata_types.ts",
    "start_line": 24,
    "signature": "extract_type_from_annotation(node: SyntaxNode, file_path: FilePath): TypeInfo | undefined",
    "root_cause": "method called through interface",
    "reasoning": "This is an interface method signature (MetadataExtractors.extract_type_from_annotation) with no body implementation. It's called via interface reference in reference_builder.ts:207, but the call graph doesn't track which concrete implementations (PYTHON_METADATA_EXTRACTORS, RUST_METADATA_EXTRACTORS, etc.) actually execute. Interface methods are correctly skipped from call graph nodes due to missing body_scope_id, but calls through interfaces aren't resolved to their concrete implementations.",
    "triage_analysis": {
      "detection_gap": "No interface-to-implementation mapping: calls made through interface types resolve only to the abstract interface method signature, not to concrete implementations that actually execute at runtime. Each call creates a single edge to the static type's method rather than multiple edges to all possible implementations.",
      "existing_task_fixes": [
        "task-110",
        "task-43"
      ],
      "suggested_new_task_fix": "Add explicit filtering in detect_entry_points() to exclude interface method signatures (is_interface_method flag) from entry point candidates, since abstract methods without bodies cannot be entry points."
    }
  },
  {
    "name": "extract_call_receiver",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/metadata_types.ts",
    "start_line": 44,
    "signature": "extract_call_receiver(node: SyntaxNode, file_path: FilePath): Location | undefined",
    "root_cause": "method called through interface",
    "reasoning": "The method extract_call_receiver is defined in the MetadataExtractors interface (metadata_types.ts:44) and implemented by four concrete objects (JAVASCRIPT_METADATA_EXTRACTORS, PYTHON_METADATA_EXTRACTORS, RUST_METADATA_EXTRACTORS, TYPESCRIPT_METADATA_EXTRACTORS). It is called at reference_builder.ts:257 via extractors.extract_call_receiver(), but the call graph cannot resolve interface method calls to their concrete implementations, making all four implementations appear as uncalled entry points.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis does not track interface implementations or resolve polymorphic method calls through interface types to their concrete implementing methods, preventing detection of calls made through interface abstractions",
      "existing_task_fixes": [
        "task-43"
      ],
      "suggested_new_task_fix": "Extend task-43 to implement interface implementation tracking in the semantic index and resolve interface method calls to all possible concrete implementations, creating call graph edges to each implementation when a method is called through an interface type."
    }
  },
  {
    "name": "extract_property_chain",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/metadata_types.ts",
    "start_line": 63,
    "signature": "extract_property_chain(node: SyntaxNode): SymbolName[] | undefined",
    "root_cause": "method called through interface, implemented in object literal",
    "reasoning": "extract_property_chain is defined as a method in object literals (PYTHON_METADATA_EXTRACTORS, JAVASCRIPT_METADATA_EXTRACTORS, etc.) that implement the MetadataExtractors interface. It is called from reference_builder.ts:290 through an interface-typed parameter (extractors.extract_property_chain), but the call graph cannot resolve interface method calls to object literal implementations, only to class methods.",
    "triage_analysis": {
      "detection_gap": "Call graph resolution does not track object literal methods as callable definitions and cannot map interface method calls to their object literal implementations. The resolution registry (get_all_referenced_symbols) only tracks resolved calls that have a symbol_id, but interface method calls through parameters are not resolved to the concrete object literal methods that implement them.",
      "existing_task_fixes": [
        "task-110"
      ],
      "suggested_new_task_fix": "Add capability to extract object literal methods as callable definitions and build an interface-to-implementation registry that maps interface method signatures to all object literals implementing them. When resolving method calls through interface-typed variables, create call edges to all registered object literal implementations (similar to polymorphic dispatch for classes)."
    }
  },
  {
    "name": "extract_assignment_parts",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/metadata_types.ts",
    "start_line": 82,
    "signature": "extract_assignment_parts(node: SyntaxNode, file_path: FilePath): {\n    source: Location | undefined;\n    target: Location | undefined;\n  }",
    "root_cause": "method called through interface",
    "reasoning": "extract_assignment_parts is an interface method signature in MetadataExtractors with concrete implementations in PYTHON_METADATA_EXTRACTORS, JAVASCRIPT_METADATA_EXTRACTORS, and RUST_METADATA_EXTRACTORS. Unlike other interface methods in the same interface that ARE called from reference_builder.ts, this method has no callers in production code—it's only called from test files which are excluded from analysis scope.",
    "triage_analysis": {
      "detection_gap": "Interface method signatures without body_scope_id are incorrectly extracted as callable definitions. Additionally, call graph analysis cannot resolve interface method calls to their concrete implementations, and methods only called from test files (outside analysis scope) correctly appear as entry points but should be classified separately from true unused code.",
      "existing_task_fixes": [
        "task-110",
        "task-43"
      ],
      "suggested_new_task_fix": "Add explicit filtering in definition_builder to exclude interface method signatures (methods without body_scope_id) from callable definitions, and implement multi-tier entry point classification (Public API / Internal / Test-only / Orphaned) to distinguish genuinely unused code from methods called outside the analysis scope."
    }
  },
  {
    "name": "extract_construct_target",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/metadata_types.ts",
    "start_line": 105,
    "signature": "extract_construct_target(node: SyntaxNode, file_path: FilePath): Location | undefined",
    "root_cause": "method called through interface",
    "reasoning": "The method extract_construct_target is defined in the MetadataExtractors interface and called via extractors.extract_construct_target() where extractors is a parameter. The call happens through property access on an interface-typed object that points to implementation objects (JAVASCRIPT_METADATA_EXTRACTORS, etc.). The call graph doesn't track that these object literal properties are callable definitions or resolve calls through interface-typed object properties.",
    "triage_analysis": {
      "detection_gap": "The call graph system fails to: (1) detect object literal methods as callable definitions, (2) track calls through object property access when the object is a parameter/variable, and (3) resolve interface method calls to their concrete implementations in object literals.",
      "existing_task_fixes": [
        "task-110",
        "task-43"
      ],
      "suggested_new_task_fix": "Add detection of object literal methods as callable definitions. When an object literal property is a function (e.g., const obj = { method() {} }), create a SymbolDefinition for that method so it can be tracked in the call graph."
    }
  },
  {
    "name": "extract_type_arguments",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/metadata_types.ts",
    "start_line": 122,
    "signature": "extract_type_arguments(node: SyntaxNode): string[] | undefined",
    "root_cause": "method called through interface",
    "reasoning": "The extract_type_arguments method at line 122 is an interface method signature in MetadataExtractors. It is implemented in object literals (PYTHON_METADATA_EXTRACTORS, JAVASCRIPT_METADATA_EXTRACTORS, RUST_METADATA_EXTRACTORS) and called via extractors.extract_type_arguments() at reference_builder.ts:382. However, investigation reveals this method does NOT appear in internal_misidentified.json, unlike 5 sibling methods from the same interface, suggesting it may already be correctly handled or filtered out.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis does not track object literal methods as callable definitions and cannot resolve interface method calls through parameters to their concrete object literal implementations. Interface method signatures without body_scope_id are incorrectly extracted as callable definitions despite having no implementation.",
      "existing_task_fixes": [
        "task-110",
        "task-43"
      ],
      "suggested_new_task_fix": "Add filtering in definition_builder to exclude interface method signatures (methods without body_scope_id) from callable definitions, and implement object literal method extraction so methods defined in const OBJ = { method() {} } patterns are tracked as callable definitions for call graph analysis."
    }
  },
  {
    "name": "extract_is_optional_chain",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/metadata_types.ts",
    "start_line": 148,
    "signature": "extract_is_optional_chain(node: SyntaxNode): boolean",
    "root_cause": "object literal method not captured as callable definition",
    "reasoning": "The function is a method defined within an object literal (JAVASCRIPT_METADATA_EXTRACTORS = { extract_is_optional_chain() {...} }). Tree-sitter queries capture function declarations, class methods, and arrow functions, but not methods defined inside object literals. The function is actually called from reference_builder.ts and recursively calls itself, but isn't registered as a callable definition.",
    "triage_analysis": {
      "detection_gap": "Tree-sitter query patterns in javascript.scm lack captures for object literal methods (shorthand method syntax and function-valued properties). Only function declarations, function expressions, arrow functions, and class methods are captured as callable definitions.",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Add tree-sitter query patterns to javascript.scm and typescript.scm to capture object literal methods (both shorthand syntax and function-valued properties) as callable definitions, then update language builders to process these captures and register them in the definition registry."
    }
  },
  {
    "name": "is_method_call",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/metadata_types.ts",
    "start_line": 190,
    "signature": "is_method_call(node: SyntaxNode): boolean",
    "root_cause": "interface method signature - not actually misidentified",
    "reasoning": "is_method_call at line 190 is an interface method signature in MetadataExtractors, called via extractors.is_method_call() at reference_builder.ts:90. However, unlike 7 sibling interface methods that ARE misidentified, is_method_call does NOT appear in the internal_misidentified.json results, suggesting it was correctly filtered or never captured as a callable definition.",
    "triage_analysis": {
      "detection_gap": "Object literal methods implementing interfaces are not captured as callable definitions by tree-sitter queries, and interface method calls through typed parameters cannot be resolved to their concrete object literal implementations, preventing call graph edges from being created.",
      "existing_task_fixes": [
        "task-110",
        "task-43"
      ],
      "suggested_new_task_fix": "Add tree-sitter query patterns to capture object literal methods (shorthand and method definition syntax) as callable definitions, and add filtering in definition_builder to exclude interface method signatures (methods without body_scope_id) from callable definitions."
    }
  },
  {
    "name": "extract_call_name",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/metadata_types.ts",
    "start_line": 235,
    "signature": "extract_call_name(node: SyntaxNode): SymbolName | undefined",
    "root_cause": "method called through interface - polymorphic call not resolved to concrete implementations",
    "reasoning": "The function extract_call_name at line 235 is an interface method signature in MetadataExtractors, not a concrete implementation. It is called from reference_builder.ts at lines 351 and 470 through the extractors interface parameter. Our call graph analysis resolves the call to the interface method signature instead of tracing it to the concrete implementations in JAVASCRIPT_METADATA_EXTRACTORS, TYPESCRIPT_METADATA_EXTRACTORS, PYTHON_METADATA_EXTRACTORS, and RUST_METADATA_EXTRACTORS.",
    "triage_analysis": {
      "detection_gap": "Interface method calls are resolved to interface method signatures rather than to concrete implementations. We lack a registry mapping interfaces to their implementations and polymorphic call resolution that would create call edges from interface method invocations to all concrete implementations of that interface method.",
      "existing_task_fixes": [
        "task-43",
        "task-100.21",
        "task-67"
      ],
      "suggested_new_task_fix": "Build an interface implementation registry that tracks which classes/objects implement which interfaces, then enhance method resolution to create polymorphic call edges from interface method calls to all concrete implementations of that method."
    }
  },
  {
    "name": "extract_lifetime_parameters",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/rust_builder_helpers.ts",
    "start_line": 232,
    "signature": "extract_lifetime_parameters(node: SyntaxNode): SymbolName[]",
    "root_cause": "dead code - unused internal helper",
    "reasoning": "The function extract_lifetime_parameters is exported from rust_builder_helpers.ts but is never imported or called anywhere in packages/core. It is part of a pattern of unused helper functions (extract_trait_bounds, extract_impl_trait, is_async_function, etc.) that were written but never integrated into the rust_builder configuration. The call graph correctly identifies it as an entry point (no callers), but it is actually dead code that should be removed.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis does not distinguish between legitimate public API entry points, internal functions with missing call edges (bugs), and exported-but-unused functions (dead code). All uncalled functions are classified as entry points without categorization by export status or import relationships.",
      "existing_task_fixes": [
        "task-150"
      ],
      "suggested_new_task_fix": "Add entry point classification that tracks export/import relationships to distinguish: (1) public API entry points exported from main files, (2) internal entry points indicating missing call edges, (3) dead code exported but never imported, and (4) external callers from outside analysis scope. Output separate categories to help users identify unused exports for removal versus legitimate entry points."
    }
  },
  {
    "name": "extract_trait_bounds",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/rust_builder_helpers.ts",
    "start_line": 247,
    "signature": "extract_trait_bounds(node: SyntaxNode): SymbolName[]",
    "root_cause": "dead code - exported but unused internal helper",
    "reasoning": "The function extract_trait_bounds is exported from rust_builder_helpers.ts but is never imported or called anywhere in packages/core production code. It is part of a pattern of unused helper functions that were written but never integrated into the rust_builder configuration. The call graph correctly identifies it as an entry point (no callers), but it is actually dead code that should be removed or integrated.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis does not distinguish between legitimate public API entry points, internal functions with missing call edges (bugs), and exported-but-unused functions (dead code). All uncalled functions are classified as entry points without categorization by export status or import relationships.",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Add entry point classification that tracks export/import relationships to distinguish: (1) public API entry points exported from main files, (2) internal entry points indicating missing call edges, (3) dead code exported but never imported, and (4) external callers from outside analysis scope. Output separate categories to help users identify unused exports for removal versus legitimate entry points."
    }
  },
  {
    "name": "is_async_function",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/rust_builder_helpers.ts",
    "start_line": 313,
    "signature": "is_async_function(node: SyntaxNode): boolean",
    "root_cause": "dead code - exported but unused internal helper",
    "reasoning": "The function is_async_function is exported from rust_builder_helpers.ts but is never imported or called anywhere in packages/core production code. A separate, nearly identical function with the same name exists in python_builder.ts and is used by python_builder_config.ts. The Rust version was written but never integrated into the rust_builder configuration and has zero callers.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis does not distinguish between legitimate public API entry points, internal functions with missing call edges (bugs), and exported-but-unused functions (dead code). All uncalled functions are classified as entry points without categorization by export status or import relationships.",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Add entry point classification that tracks export/import relationships to distinguish: (1) public API entry points exported from main files, (2) internal entry points indicating missing call edges, (3) dead code exported but never imported, and (4) external callers from outside analysis scope. Output separate categories to help users identify unused exports for removal versus legitimate entry points."
    }
  },
  {
    "name": "is_const_function",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/rust_builder_helpers.ts",
    "start_line": 322,
    "signature": "is_const_function(node: SyntaxNode): boolean",
    "root_cause": "dead code - exported but never used",
    "reasoning": "The function is_const_function is exported from rust_builder_helpers.ts but is not imported or called anywhere in packages/core production code. Unlike is_async_function which Python uses, Rust's builder configuration doesn't track const/async/unsafe modifiers. This is not a call graph bug - the function genuinely has no callers.",
    "triage_analysis": {
      "detection_gap": "No detection gap - call graph analysis correctly identifies this as uncalled. This is a true positive for 'uncalled function', not a false positive for entry point detection.",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Add entry point classification system to distinguish 'dead code exports' from 'misidentified internals'. Functions exported but never imported/called should be flagged for removal or documented as intentionally unused API surface."
    }
  },
  {
    "name": "is_unsafe_function",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/rust_builder_helpers.ts",
    "start_line": 331,
    "signature": "is_unsafe_function(node: SyntaxNode): boolean",
    "root_cause": "dead code - exported but unused internal helper",
    "reasoning": "The function is_unsafe_function is exported from rust_builder_helpers.ts but is never imported or called anywhere in packages/core production code. Unlike is_async_function which Python uses, Rust's builder configuration doesn't track const/async/unsafe modifiers. This is not a call graph bug - the function genuinely has no callers.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis does not distinguish between legitimate public API entry points, internal functions with missing call edges (bugs), and exported-but-unused functions (dead code). All uncalled functions are classified as entry points without categorization by export status or import relationships.",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Add entry point classification that tracks export/import relationships to distinguish: (1) public API entry points exported from main files, (2) internal entry points indicating missing call edges, (3) dead code exported but never imported, and (4) external callers from outside analysis scope. Output separate categories to help users identify unused exports for removal versus legitimate entry points."
    }
  },
  {
    "name": "has_generic_parameters",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/rust_builder_helpers.ts",
    "start_line": 389,
    "signature": "has_generic_parameters(node: SyntaxNode): boolean",
    "root_cause": "exported dead code - never called or imported",
    "reasoning": "The function has_generic_parameters is exported from rust_builder_helpers.ts but is never imported or called anywhere in the codebase. The only file that imports from rust_builder_helpers.ts (rust_builder.ts) does not import this function. This is not a call graph analysis bug - the function correctly has zero callers and was correctly identified as an entry point because it is exported and uncalled.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis does not distinguish between legitimate public API entry points (in project.ts) and dead code entry points (exported from internal modules but never imported). Both appear as uncalled functions, but dead code should be flagged for removal rather than classified as intentional entry points.",
      "existing_task_fixes": [
        "task-100.24"
      ],
      "suggested_new_task_fix": "Add dead code classification to entry point analysis: flag exported functions in non-API modules that are never imported as dead code candidates for removal, distinguishing them from legitimate public API entry points in project.ts."
    }
  },
  {
    "name": "extract_use_path",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/rust_builder_helpers.ts",
    "start_line": 558,
    "signature": "extract_use_path(capture: CaptureNode): ModulePath",
    "root_cause": "exported but unused dead code",
    "reasoning": "The function extract_use_path is exported from rust_builder_helpers.ts and imported in rust_builder.ts but never actually called anywhere in the codebase. It was superseded by extract_imports_from_use_declaration() during refactoring but the old helper function and its import were not removed. The call graph correctly identifies it as uncalled.",
    "triage_analysis": {
      "detection_gap": "No detection gap - the function is correctly identified as uncalled. However, there is a classification gap: the analysis cannot distinguish between legitimate public API entry points, dead code that should be removed, and external entry points called from scripts/CLI outside the analysis scope.",
      "existing_task_fixes": [
        "task-100.24",
        "task-epic-11.96.4"
      ],
      "suggested_new_task_fix": "Add export usage analysis to track which exported functions are actually imported and used, enabling automatic classification of entry points into categories: public API, dead exports, and external entry points."
    }
  },
  {
    "name": "extract_use_alias",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/rust_builder_helpers.ts",
    "start_line": 612,
    "signature": "extract_use_alias(capture: CaptureNode): SymbolName | undefined",
    "root_cause": "dead code - exported but unused internal helper",
    "reasoning": "The function extract_use_alias is exported from rust_builder_helpers.ts and imported in rust_builder.ts but never actually called anywhere in the codebase. The functionality it was intended to provide is instead handled inline within extract_imports_from_use_declaration() at lines 869-891 and 940-963. This is not a call graph bug - the function genuinely has zero callers.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis does not distinguish between legitimate public API entry points, internal functions with missing call edges (bugs), and exported-but-unused functions (dead code). All uncalled functions are classified as entry points without categorization by export status or import relationships.",
      "existing_task_fixes": [
        "task-100.24",
        "task-150"
      ],
      "suggested_new_task_fix": "Add entry point classification that tracks export/import relationships to distinguish: (1) public API entry points exported from main files, (2) internal entry points indicating missing call edges, (3) dead code exported but never imported or imported but never called, and (4) external callers from outside analysis scope. Output separate categories to help users identify unused exports for removal versus legitimate entry points."
    }
  },
  {
    "name": "is_wildcard_import",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/rust_builder_helpers.ts",
    "start_line": 659,
    "signature": "is_wildcard_import(capture: CaptureNode): boolean",
    "root_cause": "dead code leftover from refactoring",
    "reasoning": "The function was originally called by old import handlers but was left behind when commit 4e75b45 refactored the entire import handling system to use extract_imports_from_use_declaration instead. The new implementation handles wildcard detection inline (checking argument.type === 'use_wildcard' directly). A recent cleanup in commit 01e6052 removed 5 other unused functions from this same file but missed is_wildcard_import.",
    "triage_analysis": {
      "detection_gap": "None - this is not a detection gap. The call graph analysis correctly identified is_wildcard_import as an uncalled function. This is legitimate dead code that should be removed, not a false positive.",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Remove is_wildcard_import from rust_builder_helpers.ts:659-671 and its import from rust_builder.ts:24 as part of code quality maintenance."
    }
  },
  {
    "name": "extract_implements",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/typescript_builder.ts",
    "start_line": 212,
    "signature": "extract_implements(node: SyntaxNode): SymbolName[]",
    "root_cause": "exported dead code - orphaned function after refactoring",
    "reasoning": "The function extract_implements is exported from typescript_builder.ts:212 but has zero callers in the codebase. Git history (commit 857d1cde, Oct 7 2025) shows it was removed from typescript_builder_config.ts:359 during a refactoring that eliminated class metadata features (implements, abstract, availability), but the export was not cleaned up.",
    "triage_analysis": {
      "detection_gap": "No detection gap - call graph correctly identifies this as uncalled. This is a code quality issue (dead code) not a call graph analysis bug. The function should be deleted entirely.",
      "existing_task_fixes": [
        "task-100.24"
      ],
      "suggested_new_task_fix": "Integrate automated dead code detection tooling (ts-prune/knip) into CI to identify exported-but-unused functions, and extend task-100.24 to specifically scan for and remove orphaned exports that are not part of the public API."
    }
  },
  {
    "name": "is_optional_member",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/typescript_builder.ts",
    "start_line": 267,
    "signature": "is_optional_member(node: SyntaxNode): boolean",
    "root_cause": "exported for testing only",
    "reasoning": "The function is_optional_member is exported from typescript_builder.ts but never imported or used in production code. It was likely written to support optional member tracking but never integrated into typescript_builder_config.ts processing logic. This is dead code that should be removed.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis cannot distinguish between public API exports, internal module exports, and unused dead code exports. It treats all exported-but-uncalled functions as entry points without tracking whether exports are actually imported anywhere.",
      "existing_task_fixes": [
        "task-100.24"
      ],
      "suggested_new_task_fix": "Add unused export detection by tracking export/import relationships across files, then classify symbols as: public API (from project.ts), internal (exported and imported within package), or dead code (exported but never imported)."
    }
  },
  {
    "name": "is_abstract_class",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/typescript_builder.ts",
    "start_line": 281,
    "signature": "is_abstract_class(node: SyntaxNode): boolean",
    "root_cause": "exported for testing only",
    "reasoning": "The function is_abstract_class was previously used to set the 'abstract' field when building class definitions. During refactoring, the 'abstract' field was removed from the class definition interface and all call sites were deleted, but the exported function definition was left behind as dead code. It is exported but never imported or called anywhere in the production codebase.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis does not distinguish between true entry points (public API functions) and dead exports (exported functions that are never imported or called). Both appear as 'not called by any function' but have different meanings.",
      "existing_task_fixes": [
        "task-epic-11.96.4"
      ],
      "suggested_new_task_fix": "Add export usage analysis to track which exported functions are actually imported elsewhere. Classify uncalled functions into categories: public_api (exported from project.ts), dead_export (exported but never imported), test_only (only called from test files), and framework_callback."
    }
  },
  {
    "name": "format_json_output",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/validate_captures.ts",
    "start_line": 444,
    "signature": "format_json_output(results: ValidationResult[]): string",
    "root_cause": "exported for external use - caller outside analysis scope",
    "reasoning": "The function format_json_output is exported from packages/core/src/index_single_file/query_code_tree/validate_captures.ts and called by scripts/validate_captures.ts at line 47. The analysis scope was intentionally limited to packages/core production code only, excluding the scripts/ directory at the repository root. Within the analyzed scope, this function is correctly identified as an entry point since no internal caller exists.",
    "triage_analysis": {
      "detection_gap": "Analysis scope boundary limitation - callers in scripts/ directory (outside packages/core) are not included in the analyzed codebase, so exported functions called only from external scripts appear as uncalled entry points",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Add analysis scope metadata to distinguish 'exported API for external callers' from 'true uncalled entry points' by tracking which exported functions are only called from known external locations (scripts/, tests/, other packages)."
    }
  },
  {
    "name": "constructor",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/references/reference_builder.ts",
    "start_line": 414,
    "signature": "constructor(context: ProcessingContext, extractors: MetadataExtractors | undefined, file_path: FilePath)",
    "root_cause": "Constructor resolution bug - looking in wrong field",
    "reasoning": "The constructor call `new ReferenceBuilder()` at line 588 IS captured and resolution IS attempted, but the constructor resolver searches for constructors in `class_def.methods` array when they are actually stored in the separate `class_def.constructor` field. This causes the resolver to fall back to returning the class symbol instead of the constructor symbol, so the constructor's symbol_id never appears in the referenced symbols set.",
    "triage_analysis": {
      "detection_gap": "Constructor call resolution fails because resolve_single_constructor_call() searches class_def.methods.find(m => m.name === 'constructor') but constructors are stored in class_def.constructor field (ClassDefinition line 75). This causes all explicit constructors to resolve to their parent class symbol instead of the constructor symbol, leaving constructor symbols unmarked as 'called' in get_all_referenced_symbols().",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Fix constructor_resolver.ts line 73-75 to use `class_def.constructor?.[0]?.symbol_id` instead of searching the methods array. Add test coverage verifying that constructors called within the same file are NOT detected as entry points."
    }
  },
  {
    "name": "extract_constructor_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/javascript_typescript_scope_boundary_extractor.ts",
    "start_line": 194,
    "signature": "extract_constructor_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called by parent class through this",
    "reasoning": "The protected method extract_constructor_boundaries is called by parent class CommonScopeBoundaryExtractor.extract_boundaries() at scope_boundary_base.ts:80 using this.extract_constructor_boundaries(). This is a polymorphic override pattern where the parent class's public method dispatches to the child class's protected implementation via the this keyword.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call resolution path does not recognize self-reference keywords, only the multi-step property chain path handles them",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and the property chain path (line 240+) in method_resolver.ts, ensuring this.method() calls are resolved correctly regardless of chain length."
    }
  },
  {
    "name": "extract_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/python_scope_boundary_extractor.ts",
    "start_line": 11,
    "signature": "extract_boundaries(node: Parser.SyntaxNode, scope_type: ScopeType, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called through interface/factory pattern",
    "reasoning": "The extract_boundaries method is called at scope_processor.ts:161 through the ScopeBoundaryExtractor interface type returned by get_scope_boundary_extractor() factory function. Our call graph analysis does not resolve interface method calls to concrete implementations, so all language-specific extractor classes (PythonScopeBoundaryExtractor, TypeScriptScopeBoundaryExtractor, etc.) appear to have uncalled extract_boundaries methods.",
    "triage_analysis": {
      "detection_gap": "Interface and abstract class method calls are not resolved to concrete implementation methods during call graph analysis. Factory patterns that return interface types prevent tracking which concrete classes receive method invocations.",
      "existing_task_fixes": [
        "task-43",
        "task-110",
        "task-100.12"
      ],
      "suggested_new_task_fix": "Implement interface implementation tracking in TypeRegistry and extend method_resolver to create call graph edges to ALL concrete implementations when a method is called on an interface type. For factory patterns, use control flow analysis to narrow possible implementations."
    }
  },
  {
    "name": "extract_class_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/python_scope_boundary_extractor.ts",
    "start_line": 31,
    "signature": "extract_class_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called by parent class through this",
    "reasoning": "The protected method extract_class_boundaries is called by PythonScopeBoundaryExtractor.extract_boundaries() at line 18 using this.extract_class_boundaries(node, file_path). Method resolution fails because the simple method call path (method_resolver.ts:96-110) tries to resolve 'this' as a variable in scope, which returns null since 'this' is a keyword. Only the multi-step property chain path (line 240+) has special handling for the 'this' keyword.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call resolution path does not recognize self-reference keywords, only the multi-step property chain path handles them",
      "existing_task_fixes": [
        "task-152"
      ],
      "suggested_new_task_fix": "Extend task-152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and the property chain path (line 240+) in method_resolver.ts, ensuring this.method() calls are resolved correctly regardless of chain length."
    }
  },
  {
    "name": "extract_function_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/python_scope_boundary_extractor.ts",
    "start_line": 97,
    "signature": "extract_function_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called by parent class through this",
    "reasoning": "The protected method extract_function_boundaries is called by its parent class CommonScopeBoundaryExtractor.extract_boundaries() at scope_boundary_base.ts:78 via this.extract_function_boundaries(), and by sibling methods extract_constructor_boundaries (line 163) and extract_decorated_function_boundaries (line 241) in the same class. Method resolution fails because the simple method call path (method_resolver.ts:96-110) tries to resolve 'this' as a variable in scope, which returns null since 'this' is a keyword. Special handling for 'this' only exists in the property chain resolver for chains with length > 2.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call resolution path does not recognize self-reference keywords, only the multi-step property chain path handles them",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and the property chain path (line 240+) in method_resolver.ts, ensuring this.method() calls are resolved correctly regardless of chain length."
    }
  },
  {
    "name": "extract_constructor_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/python_scope_boundary_extractor.ts",
    "start_line": 158,
    "signature": "extract_constructor_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called by parent class",
    "reasoning": "extract_constructor_boundaries is a protected method called internally by extract_boundaries (line 23) within the same class. This is an intra-class method invocation using this.extract_constructor_boundaries(). The call graph analysis failed to detect this internal method call within the class hierarchy.",
    "triage_analysis": {
      "detection_gap": "We don't track this.methodName() calls within method bodies - the call graph analysis misses internal instance method invocations where methods call other methods in the same class or parent class hierarchy.",
      "existing_task_fixes": [
        "task-110",
        "task-epic-11.113",
        "task-43"
      ],
      "suggested_new_task_fix": "Add intra-class method call detection by parsing method bodies to extract this.method() invocations and resolving them to class method definitions. This requires ensuring method implementations are scanned for internal method calls during call graph construction."
    }
  },
  {
    "name": "find_colon_after_name",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/python_scope_boundary_extractor.ts",
    "start_line": 187,
    "signature": "find_colon_after_name(class_node: Parser.SyntaxNode, name_node: Parser.SyntaxNode): Parser.Point",
    "root_cause": "method called through this - simple two-element property chain not handled",
    "reasoning": "The method find_colon_after_name is called at line 82 via this.find_colon_after_name(node, name_node). Method resolution fails because the resolver attempts to resolve 'this' as a variable through lexical scope, which returns null since 'this' is a keyword. Without the receiver's SymbolId, the method call cannot be resolved and doesn't appear in the referenced symbols set.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords are not resolved because the method resolver does not recognize self-reference keywords - it attempts lexical scope lookup which fails for language keywords, preventing resolution of internal class method calls",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add special handling for 'this' keyword in method_resolver.ts: when receiver is 'this', find the enclosing class scope and resolve the method within that class's definitions rather than attempting lexical scope resolution."
    }
  },
  {
    "name": "extract_decorated_function_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/python_scope_boundary_extractor.ts",
    "start_line": 230,
    "signature": "extract_decorated_function_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called through this keyword",
    "reasoning": "The function extract_decorated_function_boundaries is called from line 107 via this.extract_decorated_function_boundaries(). The method resolver has two code paths: one for multi-step property chains (length > 2) that correctly handles 'this' by finding the containing class, and one for simple calls (length ≤ 2) that incorrectly tries to resolve 'this' as a variable in the scope symbol table, causing resolution to fail since 'this' is a keyword, not a defined symbol.",
    "triage_analysis": {
      "detection_gap": "The simple method call resolution path (method_resolver.ts:96-110) lacks self-reference keyword handling. It attempts to resolve 'this' as a variable using resolutions.resolve(), which returns null since keywords are not in the scope symbol table. This causes all simple this.method() calls to fail resolution, while this.prop.method() calls succeed via the property chain resolver that has special 'this' handling.",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Add self-reference keyword detection (is_self_reference_keyword) to the simple method call path in method_resolver.ts:96-110, mirroring the 'this' handling logic from the property chain resolver (lines 240-297). This should resolve the containing class scope and set receiver_type accordingly before attempting variable lookup."
    }
  },
  {
    "name": "extract_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/rust_scope_boundary_extractor.ts",
    "start_line": 21,
    "signature": "extract_boundaries(node: Parser.SyntaxNode, scope_type: ScopeType, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called through interface/factory pattern",
    "reasoning": "The extract_boundaries method is called at scope_processor.ts:161 through the ScopeBoundaryExtractor interface type returned by get_scope_boundary_extractor() factory function. Our call graph analysis does not resolve interface method calls to concrete implementations, so all language-specific extractor classes (PythonScopeBoundaryExtractor, TypeScriptScopeBoundaryExtractor, RustScopeBoundaryExtractor, etc.) appear to have uncalled extract_boundaries methods.",
    "triage_analysis": {
      "detection_gap": "Interface and abstract class method calls are not resolved to concrete implementation methods during call graph analysis. Factory patterns that return interface types prevent tracking which concrete classes receive method invocations.",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Build an interface implementation registry mapping InterfaceId → Set<ConcreteClassId> during semantic indexing by tracking 'implements' and 'extends' clauses. When resolving method calls on interface types, create call graph edges to ALL concrete implementations to ensure no implementations appear as false entry points."
    }
  },
  {
    "name": "extract_rust_class_like_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/rust_scope_boundary_extractor.ts",
    "start_line": 38,
    "signature": "extract_rust_class_like_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called through this reference - internal class method call",
    "reasoning": "The private method extract_rust_class_like_boundaries is called on line 29 via this.extract_rust_class_like_boundaries() from within the same class's public extract_boundaries method. Our call graph analysis fails to detect this self-referential method call using the this keyword.",
    "triage_analysis": {
      "detection_gap": "Method call resolution does not properly handle this keyword references to resolve internal class method calls to their SymbolIds, causing these calls to be invisible to the call graph",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Enhance tree-sitter queries to capture this.methodName() patterns as method call references with proper receiver_location tracking, and ensure method_resolver.ts resolves this to the containing class scope for internal method lookup."
    }
  },
  {
    "name": "extract_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/typescript_scope_boundary_extractor.ts",
    "start_line": 19,
    "signature": "extract_boundaries(node: Parser.SyntaxNode, scope_type: ScopeType, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called through interface",
    "reasoning": "The method is called by scope_processor.ts via a factory function that returns a ScopeBoundaryExtractor interface. Our call graph analysis cannot resolve polymorphic method calls through interface references to their concrete implementations, so it never connects the caller to this concrete method implementation.",
    "triage_analysis": {
      "detection_gap": "Polymorphic method dispatch through interfaces and abstract classes - we fail to resolve interface method calls to concrete implementations and don't track that factory functions can return multiple possible concrete types",
      "existing_task_fixes": [
        "task-110",
        "task-43",
        "task-epic-11.91.3.2"
      ],
      "suggested_new_task_fix": "Integrate the already-implemented polymorphism_handler.ts and interface_resolver.ts infrastructure into code_graph.ts call graph building to create edges to all possible concrete implementations when encountering polymorphic method calls."
    }
  },
  {
    "name": "extract_typescript_class_like_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/extractors/typescript_scope_boundary_extractor.ts",
    "start_line": 37,
    "signature": "extract_typescript_class_like_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called through this keyword - intra-class method call",
    "reasoning": "The private method extract_typescript_class_like_boundaries is called via this.extract_typescript_class_like_boundaries() from the public extract_boundaries method (line 27). Our method call resolution fails to properly resolve this.method() calls within the same class, so the call is not tracked in the call graph, making the private method appear as an entry point.",
    "triage_analysis": {
      "detection_gap": "Method resolution for this.method() calls fails to resolve the receiver (this keyword) to the containing class and look up the method in that class's members. The resolution pipeline requires type information for the receiver, but this is a lexical scope lookup that should use the containing class scope directly.",
      "existing_task_fixes": [
        "task-152"
      ],
      "suggested_new_task_fix": "Add special-case handling in method_resolver.ts for self-reference keywords (this/self): when receiver is this, find the containing class scope and look up the method directly in that class's members, bypassing the type resolution step entirely."
    }
  },
  {
    "name": "extract_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/scope_boundary_base.ts",
    "start_line": 68,
    "signature": "extract_boundaries(node: Parser.SyntaxNode, scope_type: ScopeType, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called through interface",
    "reasoning": "The method is called via polymorphic dispatch through the ScopeBoundaryExtractor interface in scope_processor.ts:161. The call graph tracks the static interface type but doesn't resolve to concrete implementations (CommonScopeBoundaryExtractor, PythonScopeBoundaryExtractor, etc.), so all implementing methods appear uncalled.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis doesn't track polymorphic method dispatch - it only records calls to the static type, missing that interface methods resolve to multiple concrete implementations at runtime.",
      "existing_task_fixes": [
        "task-110",
        "task-epic-11.113",
        "task-43"
      ],
      "suggested_new_task_fix": "Track interface-implementation and parent-override relationships during definition building, then expand get_all_referenced_symbols() to include all implementations/overrides of called interface/parent methods."
    }
  },
  {
    "name": "extract_constructor_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/scope_boundary_base.ts",
    "start_line": 156,
    "signature": "extract_constructor_boundaries(node: Parser.SyntaxNode, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called by parent class through this",
    "reasoning": "The protected method extract_constructor_boundaries is called by the public extract_boundaries method at line 80 using this.extract_constructor_boundaries(). This is a template method pattern where the base class dispatches to protected methods that can be overridden by subclasses (JavaScriptTypescriptScopeBoundaryExtractor, PythonScopeBoundaryExtractor). The call graph analysis fails to track this internal method invocation.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call resolution path (method_resolver.ts lines 96-110) does not recognize self-reference keywords - it tries to resolve 'this' as a variable in scope which returns null. Only the multi-step property chain path (line 240+) has special handling for the 'this' keyword.",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and the property chain path (line 240+) in method_resolver.ts, ensuring this.method() and self.method() calls are resolved correctly regardless of chain length."
    }
  },
  {
    "name": "extract_boundaries",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/scopes/scope_boundary_base.ts",
    "start_line": 43,
    "signature": "extract_boundaries(node: Parser.SyntaxNode, scope_type: ScopeType, file_path: FilePath): ScopeBoundaries",
    "root_cause": "method called through interface",
    "reasoning": "extract_boundaries is an interface method called polymorphically through the ScopeBoundaryExtractor interface. The factory function get_scope_boundary_extractor() returns different concrete implementations (PythonScopeBoundaryExtractor, TypeScriptScopeBoundaryExtractor, etc.) based on language, but our call graph doesn't track interface-to-implementation mappings. Since no direct calls to the concrete implementations are detected, they appear as entry points.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis does not resolve interface method calls to their concrete implementing classes, missing polymorphic dispatch patterns and factory-returned implementations.",
      "existing_task_fixes": [
        "task-43",
        "task-110",
        "task-155.7",
        "task-epic-11.113"
      ],
      "suggested_new_task_fix": "Build interface-to-implementation registry during indexing and create multiple call edges for each interface method invocation to all implementing classes, marking them as polymorphic dispatch."
    }
  },
  {
    "name": "get_child_scope_with_symbol_name",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/semantic_index.ts",
    "start_line": 254,
    "signature": "get_child_scope_with_symbol_name(scope_id: ScopeId, name: SymbolName): ScopeId",
    "root_cause": "dead code - unused interface method",
    "reasoning": "The method is defined in the ProcessingContext interface and implemented in scope_processor.ts:250, but has ZERO production calls. It only appears in test mocks. The call graph analysis correctly identified it as never being called - this is genuine dead code that should be removed, not a detection error.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis cannot distinguish between 'legitimate entry points' (public API, framework callbacks) and 'dead code' (unused internal methods). It treats all uncalled functions identically, lacking classification based on export status, file location, or API boundaries.",
      "existing_task_fixes": [
        "task-epic-11.96.4",
        "task-100.24"
      ],
      "suggested_new_task_fix": "Add entry point classification to distinguish public API entry points from dead code. Check if entry points are exported from project.ts, match framework callback patterns, or are internal-only uncalled functions that should be flagged for removal."
    }
  },
  {
    "name": "extract_name_from_symbol_id",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/type_preprocessing/member_extraction.ts",
    "start_line": 28,
    "signature": "extract_name_from_symbol_id(symbol_id: SymbolId): SymbolName",
    "root_cause": "dead code - refactoring artifact",
    "reasoning": "The function extract_name_from_symbol_id was added in commit 3529a87 to parse PropertySignature.name (incorrectly assumed to be a SymbolId). Commit fa4000b fixed the bug by directly using prop.name and prop.symbol_id from PropertyDefinition, removing the only call to this helper function. The function definition was left in place but is never called anywhere in the codebase.",
    "triage_analysis": {
      "detection_gap": "No detection gap - call graph analysis correctly identified this as an uncalled function. This is dead code that should be removed, not a false positive.",
      "existing_task_fixes": [
        "task-100.24"
      ],
      "suggested_new_task_fix": "Add extract_name_from_symbol_id deletion to task-100.24. Consider adding a new analysis category 'dead_code_detected' to distinguish correctly-identified unused code from actual call graph detection failures."
    }
  },
  {
    "name": "get_dependencies",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/project/import_graph.ts",
    "start_line": 156,
    "signature": "get_dependencies(file_path: FilePath): Set<FilePath>",
    "root_cause": "test-only public API method",
    "reasoning": "The get_dependencies method is a public method on the exported ImportGraph class, but it is never called by any production code in packages/core. All calls to get_dependencies exist only in project.python.integration.test.ts. Since test files are excluded from the analysis scope, the method correctly appears as an entry point.",
    "triage_analysis": {
      "detection_gap": "Not a detection gap - this is correct behavior. The method is legitimately uncalled within the production code scope and is part of the public API available to external consumers.",
      "existing_task_fixes": [
        "task-158"
      ],
      "suggested_new_task_fix": "Implement task-158's entry point classification system with categories (PUBLIC_API, CLI_SCRIPT, TEST_ONLY_EXPORT, DEAD_CODE, MODULE_INITIALIZATION) to distinguish legitimate public API methods from internal functions incorrectly detected as entry points."
    }
  },
  {
    "name": "get_transitive_dependencies",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/project/import_graph.ts",
    "start_line": 180,
    "signature": "get_transitive_dependencies(file_path: FilePath): Set<FilePath>",
    "root_cause": "exported for testing only",
    "reasoning": "The method get_transitive_dependencies is a public method on the exported ImportGraph class (accessible via project.imports), but it is only called in test files, never in production code. Within the analysis scope (packages/core production code excluding tests), this is correctly identified as an entry point. Sibling methods like get_dependents() ARE used in production, confirming this is a test utility exposed through the public API.",
    "triage_analysis": {
      "detection_gap": "Analysis scope correctly excludes test files, but cannot distinguish between legitimate test-utility entry points (public methods exposed for testing) and false-positive entry points (internal methods that indicate call graph bugs)",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Add classification system to categorize entry points as 'test-utility-entry' (public methods only called in tests), 'internal-false-positive' (bugs in call graph), or 'public-api-entry' (true external entry points). Use heuristics: public method on exported class + zero production calls + has test calls + sibling methods ARE called in production = test-utility-entry."
    }
  },
  {
    "name": "get_transitive_dependents",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/project/import_graph.ts",
    "start_line": 220,
    "signature": "get_transitive_dependents(file_path: FilePath): Set<FilePath>",
    "root_cause": "exported for testing only",
    "reasoning": "The method get_transitive_dependents is a public method on the exported ImportGraph class, but it is only called from test files (import_graph.test.ts lines 264, 285, 299), not from any production code in packages/core/src. This is not a detection failure - the call graph analysis correctly identifies that no production code calls this method.",
    "triage_analysis": {
      "detection_gap": "Analysis does not distinguish between unused public API methods (part of intentional API surface) and internal methods that should be called but aren't detected due to resolution failures. Both appear as entry points, but have different root causes and remediation paths.",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Add classification logic to distinguish 'unused public API' (public methods on exported classes with no production usage) from 'internal misidentified' (private/internal methods that ARE called but not detected). Check if method is public, class has other methods called in production, and only test files reference it."
    }
  },
  {
    "name": "has_dependency",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/project/import_graph.ts",
    "start_line": 260,
    "signature": "has_dependency(importer: FilePath, imported: FilePath): boolean",
    "root_cause": "exported for testing only",
    "reasoning": "The has_dependency method is a public method on the ImportGraph class, which is exported through the main package API (packages/core/src/index.ts). However, it is only called in test files (import_graph.test.ts), not in any production code. Since the analysis scope excludes test files, the method appears as an uncalled entry point.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis does not distinguish between internal implementation functions (which should be called internally) and public API methods (which are legitimately exported for external consumers but may not be used internally). All uncalled functions are treated as entry points regardless of their public API status.",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Implement public API filtering: parse the main package entry point (index.ts) to identify exported symbols, mark these as public API, and exclude them from internal entry point detection to focus only on uncalled internal implementation functions."
    }
  },
  {
    "name": "get_all_files",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/project/import_graph.ts",
    "start_line": 315,
    "signature": "get_all_files(): Set<FilePath>",
    "root_cause": "method called by same class (internal)",
    "reasoning": "The method get_all_files() is only called internally within ImportGraph class by the get_stats() method at line 406 via this.get_all_files(). Both methods are internal implementation details never called from production code (only tests). The call graph failed to detect this simple intra-class method call.",
    "triage_analysis": {
      "detection_gap": "Simple this.method() calls within the same class are not resolved. Method call resolution only handles multi-step property chains with 'this', not direct method invocations like this.get_all_files(). Language-specific self-reference keywords (this/self) are not uniformly detected across all call patterns.",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend method_call_resolver.ts to treat simple this.method_name() calls identically to multi-step property access chains. Add language-agnostic self-reference detection (this for TS/JS, self for Python/Rust) and ensure call graph edges are created for all intra-class method calls."
    }
  },
  {
    "name": "get_stats",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/project/import_graph.ts",
    "start_line": 400,
    "signature": "get_stats(): {\n    file_count: number;\n    edge_count: number;\n    avg_dependencies: number;\n    avg_dependents: number;\n  }",
    "root_cause": "exported for testing only",
    "reasoning": "ImportGraph.get_stats() is a public method only called by test files (project.test.ts, import_graph.test.ts, project.bench.test.ts), never by production code. Since the analysis scope excludes test files, the method correctly appears to have zero callers. This is not a bug—it's a test-only utility method that is genuinely unused in production.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis includes all public methods as potential entry points but excludes test file callers, causing test-only utility methods to appear as entry points even though they serve their intended purpose.",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Scope entry point detection to only the public API surface (methods exported from project.ts), excluding internal component methods. Alternatively, add metadata to track test-only vs production usage and categorize findings accordingly."
    }
  },
  {
    "name": "get_file_imports",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/project/import_graph.ts",
    "start_line": 439,
    "signature": "get_file_imports(file_path: FilePath): readonly ImportDefinition[]",
    "root_cause": "exported but unused public method",
    "reasoning": "get_file_imports is a public method on the exported ImportGraph class that is never called in production code. The call graph analysis correctly identified it as uncalled. This is not a detection failure but reveals unused code - ImportGraph provides symmetric file-level and scope-level query methods, but only get_scope_imports() is actually used.",
    "triage_analysis": {
      "detection_gap": "No detection gap - analysis is correct. The issue is semantic: the method is on an internal infrastructure class (ImportGraph) rather than the true public API (Project class), but our analysis doesn't distinguish between 'public API entry points' and 'unused methods on internal utility classes'.",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Add configurable API boundary detection that allows specifying which classes/modules constitute the 'public API' (e.g., only Project class), then filter entry points to exclude unused methods on internal infrastructure classes while still reporting genuinely unused internal functions."
    }
  },
  {
    "name": "build_file_tree",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/file_folders_test_helper.ts",
    "start_line": 40,
    "signature": "build_file_tree(file_paths: FilePath[]): FileSystemFolder",
    "root_cause": "exported for testing only",
    "reasoning": "The function build_file_tree is a test utility in file_folders_test_helper.ts, called exclusively by test files (*.test.ts). The analysis script's file filter only excludes files matching '.test.' or '.spec.' patterns, missing test helpers named with '_test_helper' pattern. The call graph correctly identified it as having no callers within the analyzed scope, but the scope itself was wrong because test utilities were included.",
    "triage_analysis": {
      "detection_gap": "File scope filtering in detect_entrypoints_using_ariadne.ts line 100-112 uses overly narrow pattern matching that only excludes '.test.' and '.spec.' files, failing to exclude test helper files, test utilities, and other test-related support files that use different naming conventions like '*_test_helper.ts', '*_test_utils.ts', or 'test_fixtures.ts'.",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Expand test file detection patterns in detect_entrypoints_using_ariadne.ts to exclude test helper files and utilities. Add patterns for '_test_helper', '_test_utils', 'test_fixtures', 'testing_utils', '__tests__/', and '__mocks__/' to should_load_file() function."
    }
  },
  {
    "name": "has",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/definition_registry.ts",
    "start_line": 208,
    "signature": "has(symbol_id: SymbolId): boolean",
    "root_cause": "exported for testing only",
    "reasoning": "The has() method is a public API method on DefinitionRegistry that is never called in production code - only in test files (definition_registry.test.ts). Search through all production TypeScript files in packages/core/src found zero calls to this method outside of tests. The call graph analysis correctly identifies it as uncalled within the production code scope.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis treats all public class methods equally, without distinguishing between internal implementation methods and public API methods that may be legitimately unused in production but exist for external consumers or testing",
      "existing_task_fixes": [
        "task-106"
      ],
      "suggested_new_task_fix": "Add export/visibility analysis to categorize uncalled methods as either 'internal unused' (potential bugs) or 'public API unused' (expected). Track whether methods are part of exported class APIs and exclude them from internal entry point detection."
    }
  },
  {
    "name": "get_all_files",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/definition_registry.ts",
    "start_line": 217,
    "signature": "get_all_files(): FilePath[]",
    "root_cause": "exported for testing only",
    "reasoning": "The method get_all_files() in DefinitionRegistry is only called from test files (definition_registry.test.ts, project.*.integration.test.ts), never from production code. Since the analysis scope excludes test files, this method correctly appears as an entry point within the analyzed codebase scope.",
    "triage_analysis": {
      "detection_gap": "Analysis scope excludes test file callers, so public methods used exclusively for testing appear as entry points even though they are legitimately called from tests. This is correct behavior within the defined scope, not a detection gap.",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Add classification category for 'test-only API methods' to distinguish legitimate test infrastructure from false positives, helping prioritize investigation of entry points that indicate actual call graph analysis bugs."
    }
  },
  {
    "name": "get_all_definitions",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/definition_registry.ts",
    "start_line": 226,
    "signature": "get_all_definitions(): AnyDefinition[]",
    "root_cause": "method called through public property access",
    "reasoning": "get_all_definitions() is accessed via project.definitions (public property exposing DefinitionRegistry). All calls in packages/core are in test files, which are excluded from analysis scope. The method is part of the effective public API surface through the registry pattern.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis only tracks direct function call expressions, not methods invoked on objects exposed as public properties (property access chains like object.property.method())",
      "existing_task_fixes": [
        "task-150",
        "task-110",
        "task-43"
      ],
      "suggested_new_task_fix": "Implement public API surface analysis: traverse exported classes to find methods accessible via public properties, exclude these from entry point detection as they constitute the effective public API even if not called internally."
    }
  },
  {
    "name": "build_scope_to_definitions_index",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/definition_registry.ts",
    "start_line": 269,
    "signature": "build_scope_to_definitions_index(definitions: AnyDefinition[]): Map<ScopeId, Map<SymbolKind, AnyDefinition[]>>",
    "root_cause": "method called through `this.` but not tracked by call resolution",
    "reasoning": "The private method `build_scope_to_definitions_index` is called on line 134 via `this.build_scope_to_definitions_index(definitions)` within the same class. The call graph analysis fails to resolve `this.method()` calls, likely because `this` type resolution fails or the method call resolution doesn't properly handle same-class invocations. When resolution fails, the call never gets added to `resolved_calls_by_file`, so it doesn't appear in `get_all_referenced_symbols()`, causing the method to be misidentified as an entry point.",
    "triage_analysis": {
      "detection_gap": "Method call resolution (resolve_single_method_call) fails to resolve calls where the receiver is `this` within a class method. The system doesn't track that `this` refers to the enclosing class type, so it can't look up the method in the class's member index. This causes legitimate internal method calls to be completely missing from the resolved calls registry.",
      "existing_task_fixes": [
        "task-155.7",
        "task-152"
      ],
      "suggested_new_task_fix": "Add explicit `this` keyword type binding during method body scope processing - when indexing a method, record that `this` within that method's body scope resolves to the parent class type. Update method call resolution to use this binding when the receiver is the `this` keyword."
    }
  },
  {
    "name": "add_to_registry",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/export_registry.ts",
    "start_line": 77,
    "signature": "add_to_registry(): unknown",
    "root_cause": "closure called from enclosing scope",
    "reasoning": "add_to_registry is a nested arrow function (closure) defined at line 77 inside the update_file method and called at line 175 from the same enclosing scope. While nested functions are indexed as callable definitions, calls to locally-defined closures are not being resolved because scope name resolution does not include function expressions/arrow functions assigned to const/let in the scope's symbol bindings.",
    "triage_analysis": {
      "detection_gap": "Reference resolution does not find nested function definitions (arrow functions, function expressions) in lexical scope lookups because scope bindings only include imported symbols and function declarations, not locally-defined closures assigned to variables",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Extend scope name resolution in resolve_names() to register arrow functions and function expressions assigned to const/let variables in their enclosing scope's symbol bindings, enabling reference resolution to find and resolve calls to locally-defined helper functions through lexical scope lookup."
    }
  },
  {
    "name": "exports_symbol",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/export_registry.ts",
    "start_line": 208,
    "signature": "exports_symbol(file_id: FilePath, symbol_id: SymbolId): boolean",
    "root_cause": "dead code - unused public method",
    "reasoning": "The exports_symbol method is never called anywhere in the production codebase or tests. Search results confirm only the definition exists at line 208, with zero call sites. This is not a detection gap - the call graph analysis correctly identified an uncalled method. The functionality is redundant since callers use get_exports() and check set membership directly.",
    "triage_analysis": {
      "detection_gap": "No detection gap exists. This is a true positive detection of dead code. The terminology 'entry point' is misleading for unused methods that should be removed rather than methods that are legitimate external API entry points.",
      "existing_task_fixes": [
        "task-100.24",
        "task-epic-11.96.4"
      ],
      "suggested_new_task_fix": "Add dead code classification to distinguish between true public API entry points (exported via project/index.ts) and unused methods that should be removed. Audit all Registry class public methods for usage and remove or make private those never called in production code."
    }
  },
  {
    "name": "get_all_files",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/export_registry.ts",
    "start_line": 218,
    "signature": "get_all_files(): FilePath[]",
    "root_cause": "exported for testing only",
    "reasoning": "The method ExportRegistry.get_all_files() is never called in production code, only from test files which are excluded from the analysis scope. This is a true positive detection within the defined scope - the method genuinely has no production callers. It follows a common registry pattern where all registry classes expose get_all_files() as part of their public API surface.",
    "triage_analysis": {
      "detection_gap": "Analysis scope excludes test file callers, so public methods used exclusively for testing appear as entry points even though they are legitimately called from tests. This is correct behavior within the defined scope, not a detection gap.",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Add classification category for 'test-only API methods' to distinguish legitimate test infrastructure from false positives, helping prioritize investigation of entry points that indicate actual call graph analysis bugs."
    }
  },
  {
    "name": "get_file_count",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/export_registry.ts",
    "start_line": 227,
    "signature": "get_file_count(): number",
    "root_cause": "dead code - unused query/getter method",
    "reasoning": "The method get_file_count() is never called anywhere in packages/core production code. It was likely added as part of a 'complete API surface' pattern but serves no purpose in the current codebase. This is correctly detected as an entry point - it genuinely has no callers and represents dead code that should be removed.",
    "triage_analysis": {
      "detection_gap": "Not a detection gap - this is correct behavior. The method genuinely has no production callers. The issue is architectural (dead code) rather than a call graph analysis limitation.",
      "existing_task_fixes": [
        "task-100.24"
      ],
      "suggested_new_task_fix": "Add classification categories for entry points (true API, test-only, dead code, internal helpers) to distinguish genuine call graph bugs from architectural issues like unused methods, helping prioritize investigation efforts."
    }
  },
  {
    "name": "get_total_export_count",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/export_registry.ts",
    "start_line": 236,
    "signature": "get_total_export_count(): number",
    "root_cause": "dead code - unused utility method",
    "reasoning": "The function get_total_export_count() is genuinely never called anywhere in the packages/core production or test code. This is not a false positive - the call graph analysis correctly identified it as an uncalled function. Similar utility methods like get_file_count() are also unused, while get_exports() is the actual method used throughout the codebase.",
    "triage_analysis": {
      "detection_gap": "Not a detection gap - this is correct behavior. The function is legitimately dead code that should be removed rather than a missed call that should be detected.",
      "existing_task_fixes": [
        "task-100.24"
      ],
      "suggested_new_task_fix": "Add classification to entry point analysis distinguishing between public API methods (legitimate entry points), internal utilities never called (dead code candidates for removal), and internal implementation methods called via this/self (detection gaps requiring fixes)."
    }
  },
  {
    "name": "find_exporters",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/export_registry.ts",
    "start_line": 251,
    "signature": "find_exporters(symbol_id: SymbolId): FilePath[]",
    "root_cause": "dead code - unused public method",
    "reasoning": "The function find_exporters() is genuinely never called anywhere in the packages/core production or test code. This is not a false positive - the call graph analysis correctly identified it as an uncalled function. Similar utility methods like get_file_count() and get_total_export_count() are also unused, while get_exports() is the actual method used throughout the codebase.",
    "triage_analysis": {
      "detection_gap": "Not a detection gap - this is correct behavior. The function is legitimately dead code that should be removed rather than a missed call that should be detected.",
      "existing_task_fixes": [
        "task-100.24",
        "task-epic-11.96.4"
      ],
      "suggested_new_task_fix": "Add classification to entry point analysis distinguishing between public API methods (legitimate entry points), internal utilities never called (dead code candidates for removal), and internal implementation methods called via this/self (detection gaps requiring fixes)."
    }
  },
  {
    "name": "get_export",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/export_registry.ts",
    "start_line": 270,
    "signature": "get_export(file_path: FilePath, export_name: SymbolName): EnhancedExportMetadata | undefined",
    "root_cause": "method called through this - simple two-element property chain not handled",
    "reasoning": "The method get_export is called via this.get_export() at line 347 within resolve_export_chain. Method resolution fails because the simple method call path (lines 96-110 in method_resolver.ts) tries to resolve 'this' as a variable in scope, which returns null since 'this' is a keyword. Special handling for 'this' only exists in the property chain resolver for chains with length > 2, but this.get_export() has a two-element chain.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call path does not recognize self-reference keywords, only the multi-step property chain path handles them",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and modify the condition at line 82 to include two-element chains when the first element is a self-reference keyword (this/self), ensuring this.method() calls are resolved correctly."
    }
  },
  {
    "name": "get_default_export",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/export_registry.ts",
    "start_line": 283,
    "signature": "get_default_export(file_path: FilePath): EnhancedExportMetadata | undefined",
    "root_cause": "method called by same-class method via 'this'",
    "reasoning": "get_default_export is called by resolve_export_chain (same class) at line 346 via this.get_default_export(). The call chain traces to public API: get_default_export <- resolve_export_chain <- resolve_scope_recursive <- resolve_names <- Project.update_file/remove_file. This is a same-class method call that should be detected but isn't appearing in the referenced symbols set.",
    "triage_analysis": {
      "detection_gap": "Same-class method calls via 'this' keyword are either not being captured as references during semantic indexing, or not being resolved successfully during call resolution, causing them to be excluded from the get_all_referenced_symbols() set used for entry point detection",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Create task to verify and fix 'this.method()' call tracking: ensure semantic indexing captures same-class method call references with correct receiver_location context, and verify resolve_single_method_call() correctly handles 'this' keyword resolution to class type and method lookup. Add test coverage for same-class call chains across all supported languages."
    }
  },
  {
    "name": "get_all_files",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/reference_registry.ts",
    "start_line": 54,
    "signature": "get_all_files(): FilePath[]",
    "root_cause": "exported for testing only",
    "reasoning": "ReferenceRegistry.get_all_files() is never called in production code within packages/core. The method follows a 'complete API surface' pattern where all registry classes expose similar query methods, but this particular instance serves no purpose in production. Similar unused get_all_files() methods exist in other registry classes.",
    "triage_analysis": {
      "detection_gap": "Analysis scope excludes test file callers, so public methods used exclusively for testing (or not at all) appear as entry points even though this is correct behavior within the defined scope. This creates noise when distinguishing genuine call graph bugs from architectural issues like dead code.",
      "existing_task_fixes": [
        "task-100.24"
      ],
      "suggested_new_task_fix": "Add classification categories for entry points (true API exported from project.ts, test-only utilities, dead code, internal helpers) to distinguish genuine call graph analysis bugs from architectural issues, helping prioritize investigation efforts."
    }
  },
  {
    "name": "size",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/reference_registry.ts",
    "start_line": 63,
    "signature": "size(): number",
    "root_cause": "exported for testing only",
    "reasoning": "ReferenceRegistry.size() is never called in production code. Unlike sibling registries (DefinitionRegistry.size() and ResolutionRegistry.size() are called in project.ts:378-379), this method exists for API completeness but serves no production purpose. It's genuinely uncalled within the analysis scope.",
    "triage_analysis": {
      "detection_gap": "Analysis scope excludes test file callers, so public methods used exclusively for testing (or not at all) appear as entry points even though this is correct behavior within the defined scope. This creates noise when distinguishing genuine call graph bugs from architectural issues like dead code.",
      "existing_task_fixes": [
        "task-100.24"
      ],
      "suggested_new_task_fix": "Add classification categories for entry points (true API exported from project.ts, test-only utilities, dead code, internal helpers) to distinguish genuine call graph analysis bugs from architectural issues, helping prioritize investigation efforts."
    }
  },
  {
    "name": "get_all_files",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/scope_registry.ts",
    "start_line": 95,
    "signature": "get_all_files(): FilePath[]",
    "root_cause": "exported for testing only",
    "reasoning": "ScopeRegistry.get_all_files() is never called in production code within packages/core. The method is only called from test files (scope_registry.test.ts) which are excluded from the analysis scope. This is correct behavior - the method genuinely has no production callers and follows a common registry pattern where all registry classes expose get_all_files() as part of their public API surface.",
    "triage_analysis": {
      "detection_gap": "Analysis scope excludes test file callers, so public methods used exclusively for testing appear as entry points even though they are legitimately called from tests. This is correct behavior within the defined scope, not a detection gap.",
      "existing_task_fixes": [
        "task-100.24"
      ],
      "suggested_new_task_fix": "Add classification categories for entry points (true API exported from project.ts, test-only utilities, dead code, internal helpers) to distinguish genuine call graph analysis bugs from architectural issues, helping prioritize investigation efforts."
    }
  },
  {
    "name": "remove_scopes_recursively",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/scope_registry.ts",
    "start_line": 122,
    "signature": "remove_scopes_recursively(scope: LexicalScope): void",
    "root_cause": "method called through this - simple two-element property chain not handled",
    "reasoning": "The method remove_scopes_recursively is called at lines 111 and 129 via this.remove_scopes_recursively(). Method resolution has two code paths: one for property chains with length > 2 (which handles 'this' keyword) and one for chains with length <= 2 (which does not). For this.method() calls, the chain length is 2, so it takes the simple path which tries to resolve 'this' as a variable, fails, and returns null.",
    "triage_analysis": {
      "detection_gap": "Method calls on this/self keywords with two-element property chains (this.method) are not resolved because the simple method call resolution path (method_resolver.ts:96-110) does not recognize self-reference keywords, only the multi-step property chain path (line 240+) handles them",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to add self-reference keyword handling to BOTH the simple method call path (line 96-110) and the property chain path (line 240+) in method_resolver.ts, ensuring this.method() calls are resolved correctly regardless of chain length."
    }
  },
  {
    "name": "size",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/scope_registry.ts",
    "start_line": 140,
    "signature": "size(): number",
    "root_cause": "exported for testing only",
    "reasoning": "ScopeRegistry.size() is never called by production code in packages/core/src - only used in test files. This is a TRUE POSITIVE, not a false positive. The analysis correctly identified it as an entry point within the defined scope (production code excluding tests).",
    "triage_analysis": {
      "detection_gap": "The call graph correctly detects that ScopeRegistry.size() is never called in production. No detection gap exists - the method genuinely is not called. Confusion arose from method name collision: DefinitionRegistry.size() and ResolutionRegistry.size() ARE called, but ScopeRegistry.size() is not.",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Add entry point report metadata to distinguish test-only methods and flag method name collisions across unrelated classes. Reports should indicate when identically-named methods exist across multiple classes with different call patterns."
    }
  },
  {
    "name": "get_parent_class",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/type_registry.ts",
    "start_line": 337,
    "signature": "get_parent_class(class_id: SymbolId): SymbolId | null",
    "root_cause": "unused public API method",
    "reasoning": "The method get_parent_class is a legitimate public API accessor method exposed through TypeRegistry, but it's never called in production code. Internal usage (walk_inheritance_chain) directly accesses this.parent_classes.get() instead of calling the method. This is NOT a detection bug - the method is genuinely unused.",
    "triage_analysis": {
      "detection_gap": "Entry point detection doesn't distinguish between public API methods (intentionally exposed but unused) and internal methods (unexpectedly uncalled). All uncalled functions are classified as entry points regardless of their visibility or purpose.",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Add public API classification to entry point detection by filtering out public methods of exported Registry classes (TypeRegistry, DefinitionRegistry, etc.) or using ExportRegistry to identify public API surface, creating separate categories for 'unused public API' vs 'internal uncalled functions'."
    }
  },
  {
    "name": "get_implemented_interfaces",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/type_registry.ts",
    "start_line": 356,
    "signature": "get_implemented_interfaces(class_id: SymbolId): readonly SymbolId[]",
    "root_cause": "internal utility function - direct property access bypasses public getter",
    "reasoning": "The method get_implemented_interfaces() is a public getter that wraps access to the private property this.implemented_interfaces. Internal code (get_type_member at line 440) directly accesses this.implemented_interfaces.get() instead of calling the getter method. The getter exists only for external API consumers (tests), while internal implementation bypasses it for direct property access.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis does not track direct property access (this.property_name) on class instances, only method calls (this.method_name()). It cannot recognize that accessing a private property directly is semantically equivalent to calling its public getter wrapper.",
      "existing_task_fixes": [
        "task-epic-11.152"
      ],
      "suggested_new_task_fix": "Extend task-epic-11.152 to track this.property access patterns in addition to this.method() calls. Add tree-sitter queries to capture property member access expressions and resolve them to understand that direct property access (this.implemented_interfaces) represents usage of the data source exposed by the getter method (get_implemented_interfaces)."
    }
  },
  {
    "name": "walk_inheritance_chain",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/type_registry.ts",
    "start_line": 378,
    "signature": "walk_inheritance_chain(class_id: SymbolId): readonly SymbolId[]",
    "root_cause": "method called through this keyword - simple chain",
    "reasoning": "The method walk_inheritance_chain is called by get_type_member using this.walk_inheritance_chain(). The semantic index captures this call with property_chain ['this', 'walk_inheritance_chain'], but the method resolver only handles this keyword for chains longer than 2. It tries to resolve 'this' as a regular symbol, fails, and returns null without resolving the call.",
    "triage_analysis": {
      "detection_gap": "Method resolver (method_resolver.ts:82) only invokes resolve_property_chain for chains with length > 2. Simple this.method() calls (length=2) attempt to resolve 'this' as a symbol via resolutions.resolve(), which fails because 'this' is a keyword. The special this-handling logic exists only in resolve_property_chain and is unreachable for simple same-class method calls.",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Change method_resolver.ts:82 condition from 'chain.length > 2' to 'chain.length >= 2 && chain[0] === \"this\"' to route all this-prefixed calls through resolve_property_chain, which has the proper keyword handling logic. This will resolve internal method calls and prevent them from being misidentified as entry points."
    }
  },
  {
    "name": "get_namespace_member",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/type_registry.ts",
    "start_line": 469,
    "signature": "get_namespace_member(_namespace_id: SymbolId, _member_name: SymbolName): SymbolId | null",
    "root_cause": "exported for testing only",
    "reasoning": "get_namespace_member is a public method on TypeRegistry that is only called from test files, not production code. The call graph analysis correctly identifies it as 'never called' within the production codebase scope, but this is not a true entry point since it's an internal class method, not part of the public API surface exposed through project.ts.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis cannot distinguish between public methods on internal classes (TypeRegistry) versus true public API methods on the Project class. All public methods that are never called in production appear as entry points, regardless of whether they're part of the intended API surface or just test-only utilities.",
      "existing_task_fixes": [],
      "suggested_new_task_fix": "Add API surface classification to distinguish between external API (Project class methods callable by library users), internal API (methods called only within production code), and test-only API (methods called only from tests). Only external API methods that are never called should be classified as true entry points."
    }
  },
  {
    "name": "size",
    "file_path": "/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/registries/type_registry.ts",
    "start_line": 506,
    "signature": "size(): number",
    "root_cause": "exported for testing only",
    "reasoning": "TypeRegistry.size() is never called in production code within packages/core/src. Unlike sibling registries (DefinitionRegistry.size() and ResolutionRegistry.size() are called in project.ts:378-379), this method exists for API completeness but serves no production purpose. The analysis correctly identifies it as uncalled within the production codebase scope.",
    "triage_analysis": {
      "detection_gap": "Call graph analysis cannot distinguish between public methods on internal classes (TypeRegistry) versus true public API methods on the Project class. All public methods that are never called in production appear as entry points, regardless of whether they're part of the intended API surface or just test-only utilities.",
      "existing_task_fixes": [
        "task-100.24"
      ],
      "suggested_new_task_fix": "Add API surface classification to distinguish between external API (Project class methods), internal API (methods called within production), and test-only API (methods called only from tests). Add entry point report metadata to flag method name collisions across unrelated classes where identically-named methods have different call patterns."
    }
  }
]
