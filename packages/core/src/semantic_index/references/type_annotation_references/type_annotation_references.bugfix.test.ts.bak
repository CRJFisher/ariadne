/**
 * Bug fix tests for type annotation syntax extraction
 */

import { describe, it, expect, vi, beforeEach } from "vitest";
import type {
  Location,
  FilePath,
  ScopeId,
  LexicalScope,
  SymbolName,
} from "@ariadnejs/types";
import type { NormalizedCapture } from "../../capture_types";
import { SemanticEntity, SemanticCategory } from "../../capture_types";
import {
  LocalTypeAnnotation,
  process_type_annotations,
  process_type_annotation_references,
} from "./type_annotation_references";

// Mock dependencies
vi.mock("../../scope_tree", () => ({
  find_containing_scope: vi.fn(),
}));

import { find_containing_scope } from "../../scope_tree";

const mockFindContainingScope = vi.mocked(find_containing_scope);

describe("Type Annotation References - Bug Fixes", () => {
  const mockFilePath = "bugfix.ts" as FilePath;
  const mockLocation: Location = {
    file_path: mockFilePath,
    line: 1,
    column: 0,
    end_line: 1,
    end_column: 10,
  };

  const mockScope: LexicalScope = {
    id: "scope_1" as ScopeId,
    type: "function",
    location: mockLocation,
    parent_id: null,
    child_ids: [],
    symbols: new Map(),
    name: "testFunction" as SymbolName,
  };

  const mockScopes = new Map<ScopeId, LexicalScope>([
    [mockScope.id, mockScope],
  ]);

  beforeEach(() => {
    vi.clearAllMocks();
    mockFindContainingScope.mockReturnValue(mockScope);
  });

  describe("Bug Fix 1: Annotation Kind Detection", () => {
    it("should correctly map CONSTANT entity to variable annotation kind", () => {
      const capture: NormalizedCapture = {
        entity: SemanticEntity.CONSTANT,
        category: null,
        text: "MY_CONSTANT",
        node_location: mockLocation,
        modifiers: {},
        context: null,
      };

      const annotations = process_type_annotations(
        [capture],
        mockScope,
        mockScopes,
        mockFilePath
      );

      expect(annotations).toHaveLength(1);
      expect(annotations[0].annotation_kind).toBe("variable");
    });

    it("should default unknown entities to variable annotation kind", () => {
      const capture: NormalizedCapture = {
        entity: 999 as SemanticEntity, // Unknown entity
        category: null,
        text: "UnknownType",
        node_location: mockLocation,
        modifiers: {},
        context: null,
      };

      const annotations = process_type_annotations(
        [capture],
        mockScope,
        mockScopes,
        mockFilePath
      );

      expect(annotations).toHaveLength(1);
      expect(annotations[0].annotation_kind).toBe("variable");
    });
  });

  describe("Bug Fix 2: Constraint Text Extraction", () => {
    it("should extract extends constraints from capture context", () => {
      const capture: NormalizedCapture = {
        entity: SemanticEntity.TYPE,
        category: null,
        text: "MyClass",
        node_location: mockLocation,
        modifiers: {},
        context: { extends_class: "BaseClass" },
      };

      const annotations = process_type_annotations(
        [capture],
        mockScope,
        mockScopes,
        mockFilePath
      );

      expect(annotations).toHaveLength(1);
      expect(annotations[0].constraint_text).toBe("extends BaseClass");
    });

    it("should extract implements constraints from capture context", () => {
      const capture: NormalizedCapture = {
        entity: SemanticEntity.TYPE,
        category: null,
        text: "MyClass",
        node_location: mockLocation,
        modifiers: {},
        context: { implements_interface: "IDisposable" },
      };

      const annotations = process_type_annotations(
        [capture],
        mockScope,
        mockScopes,
        mockFilePath
      );

      expect(annotations).toHaveLength(1);
      expect(annotations[0].constraint_text).toBe("implements IDisposable");
    });

    it("should extract multiple implements constraints", () => {
      const capture: NormalizedCapture = {
        entity: SemanticEntity.TYPE,
        category: null,
        text: "MyClass",
        node_location: mockLocation,
        modifiers: {},
        context: { implements_interfaces: ["IFoo", "IBar"] },
      };

      const annotations = process_type_annotations(
        [capture],
        mockScope,
        mockScopes,
        mockFilePath
      );

      expect(annotations).toHaveLength(1);
      expect(annotations[0].constraint_text).toBe("implements IFoo, implements IBar");
    });

    it("should extract satisfies constraints from capture context", () => {
      const capture: NormalizedCapture = {
        entity: SemanticEntity.TYPE_PARAMETER,
        category: null,
        text: "T",
        node_location: mockLocation,
        modifiers: {},
        context: { constraint_type: "Record<string, unknown>" },
      };

      const annotations = process_type_annotations(
        [capture],
        mockScope,
        mockScopes,
        mockFilePath
      );

      expect(annotations).toHaveLength(1);
      expect(annotations[0].constraint_text).toBe("satisfies Record<string, unknown>");
    });

    it("should handle captures without context gracefully", () => {
      const capture: NormalizedCapture = {
        entity: SemanticEntity.TYPE,
        category: null,
        text: "SimpleType",
        node_location: mockLocation,
        modifiers: {},
        context: null,
      };

      const annotations = process_type_annotations(
        [capture],
        mockScope,
        mockScopes,
        mockFilePath
      );

      expect(annotations).toHaveLength(1);
      expect(annotations[0].constraint_text).toBeUndefined();
    });
  });

  describe("Bug Fix 3: Error Handling", () => {
    it("should throw error for invalid type_captures input", () => {
      expect(() =>
        process_type_annotations(
          null as any,
          mockScope,
          mockScopes,
          mockFilePath
        )
      ).toThrow("Invalid input: type_captures must be an array");
    });

    it("should throw error for invalid root_scope input", () => {
      expect(() =>
        process_type_annotations(
          [],
          null as any,
          mockScopes,
          mockFilePath
        )
      ).toThrow("Invalid input: root_scope must have an id");
    });

    it("should throw error for invalid scopes input", () => {
      expect(() =>
        process_type_annotations(
          [],
          mockScope,
          null as any,
          mockFilePath
        )
      ).toThrow("Invalid input: scopes must be a Map");
    });

    it("should throw error for missing file_path", () => {
      expect(() =>
        process_type_annotations(
          [],
          mockScope,
          mockScopes,
          null as any
        )
      ).toThrow("Invalid input: file_path is required");
    });

    it("should skip invalid captures gracefully", () => {
      const consoleWarn = vi.spyOn(console, "warn").mockImplementation(() => {});

      const captures: NormalizedCapture[] = [
        {
          entity: SemanticEntity.TYPE,
          category: null,
          text: "",  // Invalid: empty text
          node_location: mockLocation,
          modifiers: {},
          context: null,
        },
        {
          entity: SemanticEntity.TYPE,
          category: null,
          text: "GoodType",
          node_location: mockLocation,
          modifiers: {},
          context: null,
        },
        {
          entity: SemanticEntity.TYPE,
          category: null,
          text: "NoLocation",
          node_location: null as any, // Invalid: no location
          modifiers: {},
          context: null,
        },
      ];

      const annotations = process_type_annotations(
        captures,
        mockScope,
        mockScopes,
        mockFilePath
      );

      expect(annotations).toHaveLength(1);
      expect(annotations[0].annotation_text).toBe("GoodType");

      consoleWarn.mockRestore();
    });

    it("should handle missing scope gracefully", () => {
      mockFindContainingScope.mockReturnValue(null);

      const capture: NormalizedCapture = {
        entity: SemanticEntity.TYPE,
        category: null,
        text: "TypeWithNoScope",
        node_location: mockLocation,
        modifiers: {},
        context: null,
      };

      const annotations = process_type_annotations(
        [capture],
        mockScope,
        mockScopes,
        mockFilePath
      );

      expect(annotations).toHaveLength(0);
    });
  });

  describe("Bug Fix 4: Target Location Context", () => {
    it("should use target location from context when available", () => {
      const targetLocation: Location = {
        ...mockLocation,
        line: 10,
      };

      const capture: NormalizedCapture = {
        entity: SemanticEntity.TYPE,
        category: null,
        text: "string",
        node_location: mockLocation,
        modifiers: {},
        context: { target_location: targetLocation },
      };

      const annotations = process_type_annotations(
        [capture],
        mockScope,
        mockScopes,
        mockFilePath
      );

      expect(annotations).toHaveLength(1);
      expect(annotations[0].annotates_location).toEqual(targetLocation);
    });

    it("should fallback to annotation location when no target context", () => {
      const capture: NormalizedCapture = {
        entity: SemanticEntity.TYPE,
        category: null,
        text: "string",
        node_location: mockLocation,
        modifiers: {},
        context: null,
      };

      const annotations = process_type_annotations(
        [capture],
        mockScope,
        mockScopes,
        mockFilePath
      );

      expect(annotations).toHaveLength(1);
      expect(annotations[0].annotates_location).toEqual(mockLocation);
    });
  });

  describe("Bug Fix 5: Optional Parameter Handling", () => {
    it("should correctly capture optional parameter modifiers", () => {
      const capture: NormalizedCapture = {
        entity: SemanticEntity.PARAMETER,
        category: null,
        text: "string",
        node_location: mockLocation,
        modifiers: { is_optional: true },
        context: null,
      };

      const annotations = process_type_annotations(
        [capture],
        mockScope,
        mockScopes,
        mockFilePath
      );

      expect(annotations).toHaveLength(1);
      expect(annotations[0].is_optional).toBe(true);
    });

    it("should handle missing modifiers object", () => {
      const capture: NormalizedCapture = {
        entity: SemanticEntity.PARAMETER,
        category: null,
        text: "string",
        node_location: mockLocation,
        modifiers: undefined as any,
        context: null,
      };

      const annotations = process_type_annotations(
        [capture],
        mockScope,
        mockScopes,
        mockFilePath
      );

      expect(annotations).toHaveLength(1);
      expect(annotations[0].is_optional).toBeUndefined();
    });
  });

  describe("Bug Fix 6: Annotation Text Extraction", () => {
    it("should preserve complex generic type syntax", () => {
      const complexType = "Map<string, Array<Promise<T>>>";
      const capture: NormalizedCapture = {
        entity: SemanticEntity.VARIABLE,
        category: null,
        text: complexType,
        node_location: mockLocation,
        modifiers: {},
        context: null,
      };

      const annotations = process_type_annotations(
        [capture],
        mockScope,
        mockScopes,
        mockFilePath
      );

      expect(annotations).toHaveLength(1);
      expect(annotations[0].annotation_text).toBe(complexType);
    });

    it("should preserve union type syntax", () => {
      const unionType = "string | number | boolean | null";
      const capture: NormalizedCapture = {
        entity: SemanticEntity.VARIABLE,
        category: null,
        text: unionType,
        node_location: mockLocation,
        modifiers: {},
        context: null,
      };

      const annotations = process_type_annotations(
        [capture],
        mockScope,
        mockScopes,
        mockFilePath
      );

      expect(annotations).toHaveLength(1);
      expect(annotations[0].annotation_text).toBe(unionType);
    });

    it("should preserve intersection type syntax", () => {
      const intersectionType = "Readable & Writable & Closeable";
      const capture: NormalizedCapture = {
        entity: SemanticEntity.VARIABLE,
        category: null,
        text: intersectionType,
        node_location: mockLocation,
        modifiers: {},
        context: null,
      };

      const annotations = process_type_annotations(
        [capture],
        mockScope,
        mockScopes,
        mockFilePath
      );

      expect(annotations).toHaveLength(1);
      expect(annotations[0].annotation_text).toBe(intersectionType);
    });
  });
});