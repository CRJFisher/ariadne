/**
 * Integration tests for type annotation syntax extraction
 */

import { describe, it, expect, vi, beforeEach } from "vitest";
import type {
  Location,
  FilePath,
  ScopeId,
  LexicalScope,
  SymbolName,
} from "@ariadnejs/types";
import type { NormalizedCapture } from "../../capture_types";
import { SemanticEntity } from "../../capture_types";
import {
  LocalTypeAnnotation,
  process_type_annotations,
  process_type_annotation_references,
} from "./type_annotation_references";

// Mock dependencies
vi.mock("../../scope_tree", () => ({
  find_containing_scope: vi.fn(),
}));

import { find_containing_scope } from "../../scope_tree";

const mockFindContainingScope = vi.mocked(find_containing_scope);

describe("Type Annotation References - Integration Tests", () => {
  const mockFilePath = "test.ts" as FilePath;

  const createLocation = (line: number, column: number = 0): Location => ({
    file_path: mockFilePath,
    line,
    column,
    end_line: line,
    end_column: column + 10,
  });

  const createScope = (id: string, type: LexicalScope["type"], location: Location): LexicalScope => ({
    id: id as ScopeId,
    type,
    location,
    parent_id: null,
    child_ids: [],
    symbols: new Map(),
    name: `scope_${id}` as SymbolName,
  });

  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe("Real-World Type Scenario Integration", () => {
    it("should process complex TypeScript-like type annotations", () => {
      const moduleScope = createScope("module", "module", createLocation(1, 0));
      const classScope = createScope("class", "class", createLocation(10, 0));
      const methodScope = createScope("method", "function", createLocation(15, 2));

      const scopes = new Map<ScopeId, LexicalScope>([
        ["module" as ScopeId, moduleScope],
        ["class" as ScopeId, classScope],
        ["method" as ScopeId, methodScope],
      ]);

      // Setup mock scope finding
      mockFindContainingScope.mockImplementation((location) => {
        if (location.line < 10) return moduleScope;
        if (location.line < 15) return classScope;
        return methodScope;
      });

      const captures: NormalizedCapture[] = [
        // Generic class definition with constraint
        {
          entity: SemanticEntity.TYPE,
          category: null,
          text: "MyClass",
          node_location: createLocation(10, 6),
          modifiers: {},
          context: {
            extends_class: "BaseClass",
            implements_interfaces: ["ISerializable", "ICloneable"],
          },
        },
        // Generic parameter
        {
          entity: SemanticEntity.TYPE_PARAMETER,
          category: null,
          text: "T",
          node_location: createLocation(10, 14),
          modifiers: {},
          context: {
            constraint_type: "BaseModel",
          },
        },
        // Method parameter with complex type
        {
          entity: SemanticEntity.PARAMETER,
          category: null,
          text: "Map<string, Array<T>>",
          node_location: createLocation(15, 20),
          modifiers: { is_optional: false },
          context: null,
        },
        // Return type annotation
        {
          entity: SemanticEntity.TYPE,
          category: null,
          text: "Promise<Result<T, Error>>",
          node_location: createLocation(15, 50),
          modifiers: {},
          context: null,
        },
        // Property with union type
        {
          entity: SemanticEntity.PROPERTY,
          category: null,
          text: "string | number | null",
          node_location: createLocation(12, 4),
          modifiers: {},
          context: null,
        },
        // Type cast
        {
          entity: SemanticEntity.TYPE_ASSERTION,
          category: null,
          text: "HTMLDivElement",
          node_location: createLocation(20, 10),
          modifiers: {},
          context: null,
        },
      ];

      const annotations = process_type_annotations(
        captures,
        moduleScope,
        scopes,
        mockFilePath
      );

      // Verify all annotations were processed
      expect(annotations).toHaveLength(6);

      // Check class annotation with constraints
      const classAnnotation = annotations.find(a => a.annotation_text === "MyClass");
      expect(classAnnotation).toBeDefined();
      expect(classAnnotation!.annotation_kind).toBe("generic");
      expect(classAnnotation!.constraint_text).toBe(
        "extends BaseClass, implements ISerializable, implements ICloneable"
      );

      // Check generic parameter
      const genericParam = annotations.find(a => a.annotation_text === "T");
      expect(genericParam).toBeDefined();
      expect(genericParam!.annotation_kind).toBe("generic");
      expect(genericParam!.constraint_text).toBe("extends BaseModel");

      // Check method parameter
      const methodParam = annotations.find(a => a.annotation_text === "Map<string, Array<T>>");
      expect(methodParam).toBeDefined();
      expect(methodParam!.annotation_kind).toBe("parameter");

      // Check return type
      const returnType = annotations.find(a => a.annotation_text === "Promise<Result<T, Error>>");
      expect(returnType).toBeDefined();
      expect(returnType!.annotation_kind).toBe("generic");

      // Check property with union type
      const unionProp = annotations.find(a => a.annotation_text === "string | number | null");
      expect(unionProp).toBeDefined();
      expect(unionProp!.annotation_kind).toBe("property");

      // Check type cast
      const typeCast = annotations.find(a => a.annotation_text === "HTMLDivElement");
      expect(typeCast).toBeDefined();
      expect(typeCast!.annotation_kind).toBe("cast");
    });

    it("should handle inheritance hierarchy syntax extraction", () => {
      const moduleScope = createScope("module", "module", createLocation(1, 0));
      const scopes = new Map<ScopeId, LexicalScope>([
        ["module" as ScopeId, moduleScope],
      ]);

      mockFindContainingScope.mockReturnValue(moduleScope);

      const captures: NormalizedCapture[] = [
        // Base interface
        {
          entity: SemanticEntity.TYPE,
          category: null,
          text: "IAnimal",
          node_location: createLocation(2, 0),
          modifiers: {},
          context: null,
        },
        // Extended interface
        {
          entity: SemanticEntity.TYPE,
          category: null,
          text: "IMammal",
          node_location: createLocation(6, 0),
          modifiers: {},
          context: {
            extends_class: "IAnimal",
          },
        },
        // Class implementing interfaces
        {
          entity: SemanticEntity.TYPE,
          category: null,
          text: "Dog",
          node_location: createLocation(10, 0),
          modifiers: {},
          context: {
            implements_interfaces: ["IMammal", "IPet"],
          },
        },
        // Derived class
        {
          entity: SemanticEntity.TYPE,
          category: null,
          text: "GoldenRetriever",
          node_location: createLocation(20, 0),
          modifiers: {},
          context: {
            extends_class: "Dog",
          },
        },
      ];

      const annotations = process_type_annotations(
        captures,
        moduleScope,
        scopes,
        mockFilePath
      );

      expect(annotations).toHaveLength(4);

      // Check that we captured the syntax without resolution
      const baseInterface = annotations.find(a => a.annotation_text === "IAnimal");
      expect(baseInterface).toBeDefined();
      expect(baseInterface!.constraint_text).toBeUndefined();

      const extendedInterface = annotations.find(a => a.annotation_text === "IMammal");
      expect(extendedInterface).toBeDefined();
      expect(extendedInterface!.constraint_text).toBe("extends IAnimal");

      const implementingClass = annotations.find(a => a.annotation_text === "Dog");
      expect(implementingClass).toBeDefined();
      expect(implementingClass!.constraint_text).toBe("implements IMammal, implements IPet");

      const derivedClass = annotations.find(a => a.annotation_text === "GoldenRetriever");
      expect(derivedClass).toBeDefined();
      expect(derivedClass!.constraint_text).toBe("extends Dog");
    });

    it("should handle complex generic constraints syntax", () => {
      const moduleScope = createScope("module", "module", createLocation(1, 0));
      const scopes = new Map<ScopeId, LexicalScope>([
        ["module" as ScopeId, moduleScope],
      ]);

      mockFindContainingScope.mockReturnValue(moduleScope);

      const captures: NormalizedCapture[] = [
        // Generic with extends constraint
        {
          entity: SemanticEntity.TYPE_PARAMETER,
          category: null,
          text: "T",
          node_location: createLocation(5, 10),
          modifiers: {},
          context: {
            constraint_type: "BaseType",
          },
        },
        // Generic with complex constraint
        {
          entity: SemanticEntity.TYPE_PARAMETER,
          category: null,
          text: "K",
          node_location: createLocation(5, 13),
          modifiers: {},
          context: {
            constraint_type: "keyof T",
          },
        },
        // Generic with satisfies constraint
        {
          entity: SemanticEntity.TYPE_PARAMETER,
          category: null,
          text: "V",
          node_location: createLocation(5, 16),
          modifiers: {},
          context: {
            constraint_type: "Record<string, unknown>",
          },
        },
      ];

      const annotations = process_type_annotations(
        captures,
        moduleScope,
        scopes,
        mockFilePath
      );

      expect(annotations).toHaveLength(3);

      const tParam = annotations.find(a => a.annotation_text === "T");
      expect(tParam).toBeDefined();
      expect(tParam!.constraint_text).toBe("extends BaseType");

      const kParam = annotations.find(a => a.annotation_text === "K");
      expect(kParam).toBeDefined();
      expect(kParam!.constraint_text).toBe("extends keyof T");

      const vParam = annotations.find(a => a.annotation_text === "V");
      expect(vParam).toBeDefined();
      expect(vParam!.constraint_text).toBe("satisfies Record<string, unknown>");
    });

    it("should handle error recovery in syntax extraction", () => {
      const moduleScope = createScope("module", "module", createLocation(1, 0));
      const scopes = new Map<ScopeId, LexicalScope>([
        ["module" as ScopeId, moduleScope],
      ]);

      mockFindContainingScope.mockReturnValue(moduleScope);

      const consoleWarn = vi.spyOn(console, "warn").mockImplementation(() => {});

      const captures: NormalizedCapture[] = [
        // Valid capture
        {
          entity: SemanticEntity.VARIABLE,
          category: null,
          text: "ValidType",
          node_location: createLocation(1, 0),
          modifiers: {},
          context: null,
        },
        // Invalid capture (no text)
        {
          entity: SemanticEntity.VARIABLE,
          category: null,
          text: "",
          node_location: createLocation(2, 0),
          modifiers: {},
          context: null,
        },
        // Invalid capture (no location)
        {
          entity: SemanticEntity.VARIABLE,
          category: null,
          text: "InvalidType",
          node_location: null as any,
          modifiers: {},
          context: null,
        },
        // Another valid capture
        {
          entity: SemanticEntity.PARAMETER,
          category: null,
          text: "string[]",
          node_location: createLocation(3, 0),
          modifiers: {},
          context: null,
        },
      ];

      const annotations = process_type_annotations(
        captures,
        moduleScope,
        scopes,
        mockFilePath
      );

      // Should only process valid captures
      expect(annotations).toHaveLength(2);
      expect(annotations[0].annotation_text).toBe("ValidType");
      expect(annotations[1].annotation_text).toBe("string[]");

      consoleWarn.mockRestore();
    });
  });
});