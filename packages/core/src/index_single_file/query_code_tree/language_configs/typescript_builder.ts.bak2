/**
 * TypeScript language configuration using builder pattern
 *
 * Extends JavaScript with TypeScript-specific features:
 * - Interfaces with methods and properties
 * - Type aliases
 * - Enums with members and optional methods
 * - Namespaces with exported symbols
 * - Decorators (class, method, property)
 * - Generics (type parameters)
 * - Access modifiers (public, private, protected, readonly)
 * - Abstract classes and methods
 */

import type { SyntaxNode } from "tree-sitter";
import type {
  SymbolId,
  SymbolName,
  SymbolAvailability,
  Location,
  ScopeId,
  ModulePath,
  FilePath,
} from "@ariadnejs/types";
import {
  class_symbol,
  function_symbol,
  interface_symbol,
  method_symbol,
  parameter_symbol,
  property_symbol,
  type_symbol,
  variable_symbol,
} from "@ariadnejs/types";
import type { DefinitionBuilder } from "../../definitions/definition_builder";
import type { ProcessingContext, CaptureNode } from "../scope_processor";

// Import JavaScript base configuration
import {
  JAVASCRIPT_BUILDER_CONFIG,
  type ProcessFunction,
  type LanguageBuilderConfig,
} from "./javascript_builder";

// ============================================================================
// Helper Functions for TypeScript-specific Features
// ============================================================================

/**
 * Extract location from a tree-sitter node
 */
function extract_location(node: SyntaxNode): Location {
  return {
    file_path: "" as FilePath, // Will be filled by context
    start_line: node.startPosition.row + 1,
    start_column: node.startPosition.column,
    end_line: node.endPosition.row + 1,
    end_column: node.endPosition.column,
  };
}

/**
 * Extract symbol name from a capture
 */
function extract_symbol_name(capture: CaptureNode): SymbolName {
  return (capture.text || capture.node.text || "unknown") as SymbolName;
}

/**
 * Create an interface symbol ID
 */
function create_interface_id(capture: CaptureNode): SymbolId {
  const name = capture.text;
  const location = capture.location;
  return interface_symbol(name, location);
}

/**
 * Create a type alias symbol ID
 */
function create_type_alias_id(capture: CaptureNode): SymbolId {
  const name = capture.text;
  const location = capture.location;
  return type_symbol(name, location);
}

/**
 * Create an enum symbol ID
 */
function create_enum_id(capture: CaptureNode): SymbolId {
  const name = capture.text;
  const location = capture.location;
  // Use a branded string pattern for enums
  return `enum:${location.file_path}:${location.start_line}:${location.start_column}:${location.end_line}:${location.end_column}:${name}` as SymbolId;
}

/**
 * Create a namespace symbol ID
 */
function create_namespace_id(capture: CaptureNode): SymbolId {
  const name = capture.text;
  const location = capture.location;
  // Use a branded string pattern for namespaces
  return `namespace:${location.file_path}:${location.start_line}:${location.start_column}:${location.end_line}:${location.end_column}:${name}` as SymbolId;
}

/**
 * Create an enum member symbol ID
 */
function create_enum_member_id(
  capture: CaptureNode,
  enum_id: SymbolId
): SymbolId {
  const name = capture.text;
  return `${enum_id}:${name}` as SymbolId;
}

/**
 * Create a method signature symbol ID for interface methods
 */
function create_method_signature_id(
  capture: CaptureNode,
  interface_name: SymbolName
): SymbolId {
  const name = capture.text;
  const location = capture.location;
  return method_symbol(name, location);
}

/**
 * Create a property signature symbol ID for interface properties
 */
function create_property_signature_id(capture: CaptureNode): SymbolId {
  const name = capture.text;
  const location = capture.location;
  return property_symbol(name, location);
}

/**
 * Create a class symbol ID
 */
function create_class_id(capture: CaptureNode): SymbolId {
  const name = capture.text;
  const location = capture.location;
  return class_symbol(name, location);
}

/**
 * Create a method symbol ID
 */
function create_method_id(capture: CaptureNode): SymbolId {
  const name = capture.text;
  const location = capture.location;
  return method_symbol(name, location);
}

/**
 * Create a function symbol ID
 */
function create_function_id(capture: CaptureNode): SymbolId {
  const name = capture.text;
  const location = capture.location;
  return function_symbol(name, location);
}

/**
 * Create a variable symbol ID
 */
function create_variable_id(capture: CaptureNode): SymbolId {
  const name = capture.text;
  const location = capture.location;
  return variable_symbol(name, location);
}

/**
 * Create a parameter symbol ID
 */
function create_parameter_id(capture: CaptureNode): SymbolId {
  const name = capture.text;
  const location = capture.location;
  return parameter_symbol(name, location);
}

/**
 * Create a property symbol ID
 */
function create_property_id(capture: CaptureNode): SymbolId {
  const name = capture.text;
  const location = capture.location;
  return property_symbol(name, location);
}

/**
 * Determine availability based on node context
 */
function determine_availability(node: SyntaxNode): SymbolAvailability {
  // Check for export modifier
  // TODO: improve this with the use of scope information. TODO: also, downstream clients of this ('export' processing) should calculate the visibility based on the scope
  let current: SyntaxNode | null = node;
  while (current) {
    if (current.parent?.type === "export_statement") {
      return { scope: "public" };
    }
    current = current.parent;
  }
  return { scope: "file-private" };
}

/**
 * Determine method availability (with access modifiers)
 */
function determine_method_availability(node: SyntaxNode): SymbolAvailability {
  // Check for private/protected/public modifiers
  const parent = node.parent;
  if (parent) {
    const modifiers = parent.children?.filter(
      (c: any) =>
        c.type === "private" || c.type === "protected" || c.type === "public"
    );
    if (modifiers?.length > 0) {
      const modifier = modifiers[0].type;
      // Map TypeScript visibility to SymbolAvailability scope values
      if (modifier === "private" || modifier === "protected") {
        return { scope: "file-private" }; // Private/protected are not exportable
      }
    }
  }
  return { scope: "public" };
}

/**
 * Extract type parameters from a node
 */
function extract_type_parameters(node: SyntaxNode): string[] {
  const typeParams = node.childForFieldName?.("type_parameters");
  if (typeParams) {
    // Extract individual type parameter names
    const params: string[] = [];
    for (const child of typeParams.children || []) {
      if (child.type === "type_parameter") {
        const nameNode = child.childForFieldName?.("name");
        if (nameNode) {
          params.push(nameNode.text);
        }
      }
    }
    return params;
  }
  return [];
}

/**
 * Extract interface extends clauses
 */
function extract_interface_extends(node: SyntaxNode): SymbolName[] {
  const extendsNode = node.childForFieldName?.("extends");
  if (extendsNode) {
    const interfaces: SymbolName[] = [];
    for (const child of extendsNode.children || []) {
      if (child.type === "type_identifier") {
        interfaces.push(child.text as SymbolName);
      }
    }
    return interfaces;
  }
  return [];
}

/**
 * Extract implements interfaces for classes
 */
function extract_implements(node: SyntaxNode): SymbolName[] {
  const heritage = node.childForFieldName?.("heritage");
  if (heritage) {
    const implementsClause = heritage.childForFieldName?.("implements_clause");
    if (implementsClause) {
      const interfaces: SymbolName[] = [];
      for (const child of implementsClause.children || []) {
        if (child.type === "type_identifier") {
          interfaces.push(child.text as SymbolName);
        }
      }
      return interfaces;
    }
  }
  return [];
}

/**
 * Extract access modifier from node
 */
function extract_access_modifier(
  node: SyntaxNode
): "public" | "private" | "protected" | undefined {
  const parent = node.parent;
  if (parent) {
    for (const child of parent.children || []) {
      if (child.type === "public") return "public";
      if (child.type === "private") return "private";
      if (child.type === "protected") return "protected";
    }
  }
  return undefined;
}

/**
 * Check if property is readonly
 */
function is_readonly_property(node: SyntaxNode): boolean {
  const parent = node.parent;
  if (parent) {
    for (const child of parent.children || []) {
      if (child.type === "readonly") return true;
    }
  }
  return false;
}

/**
 * Check if property/method is optional
 */
function is_optional_member(node: SyntaxNode): boolean {
  const parent = node.parent;
  if (parent) {
    // Check for optional token (?)
    for (const child of parent.children || []) {
      if (child.type === "?" || child.text === "?") return true;
    }
  }
  return false;
}

/**
 * Check if class is abstract
 */
function is_abstract_class(node: SyntaxNode): boolean {
  const parent = node.parent;
  return parent?.type === "abstract_class_declaration";
}

/**
 * Check if method is abstract
 */
function is_abstract_method(node: SyntaxNode): boolean {
  const parent = node.parent;
  if (parent) {
    for (const child of parent.children || []) {
      if (child.type === "abstract") return true;
    }
  }
  return false;
}

/**
 * Check if method is static
 */
function is_static_method(node: SyntaxNode): boolean {
  const parent = node.parent;
  if (parent) {
    for (const child of parent.children || []) {
      if (child.type === "static") return true;
    }
  }
  return false;
}

/**
 * Check if method is async
 */
function is_async_method(node: SyntaxNode): boolean {
  const parent = node.parent;
  if (parent) {
    for (const child of parent.children || []) {
      if (child.type === "async") return true;
    }
  }
  return false;
}

/**
 * Extract return type from function/method
 */
function extract_return_type(node: SyntaxNode): SymbolName | undefined {
  const returnType = node.parent?.childForFieldName?.("return_type");
  if (returnType) {
    // Skip the colon and get the actual type
    for (const child of returnType.children || []) {
      if (child.type !== ":") {
        return child.text as SymbolName;
      }
    }
  }
  return undefined;
}

/**
 * Extract type expression from type alias
 */
function extract_type_expression(node: SyntaxNode): string | undefined {
  const parent = node.parent;
  if (parent?.type === "type_alias_declaration") {
    const value = parent.childForFieldName?.("value");
    return value?.text;
  }
  return undefined;
}

/**
 * Extract enum value if present
 */
function extract_enum_value(node: SyntaxNode): string | number | undefined {
  const parent = node.parent;
  if (parent?.type === "enum_assignment") {
    const value = parent.childForFieldName?.("value");
    if (value) {
      // Try to parse as number first
      const numValue = parseFloat(value.text);
      if (!isNaN(numValue)) {
        return numValue;
      }
      return value.text;
    }
  }
  return undefined;
}

/**
 * Check if enum is const
 */
function is_const_enum(node: SyntaxNode): boolean {
  const parent = node.parent;
  if (parent) {
    // Check for const modifier
    for (const child of parent.children || []) {
      if (child.type === "const" && child.text === "const") {
        return true;
      }
    }
  }
  return false;
}

/**
 * Extract decorator name
 */
function extract_decorator_name(node: SyntaxNode): SymbolName {
  if (node.type === "identifier") {
    return node.text as SymbolName;
  }
  // Handle call expressions in decorators
  if (node.type === "call_expression") {
    const func = node.childForFieldName?.("function");
    if (func?.type === "identifier") {
      return func.text as SymbolName;
    }
  }
  return "unknown" as SymbolName;
}

/**
 * Extract decorator arguments if present
 */
function extract_decorator_arguments(node: SyntaxNode): string[] {
  if (node.type === "call_expression") {
    const args = node.childForFieldName?.("arguments");
    if (args) {
      const result: string[] = [];
      for (const child of args.children || []) {
        if (child.type !== "(" && child.type !== ")" && child.type !== ",") {
          result.push(child.text);
        }
      }
      return result;
    }
  }
  return [];
}

/**
 * Find containing class by traversing up the AST
 */
function find_containing_class(capture: CaptureNode): SymbolId | undefined {
  let node = capture.node.parent;

  while (node) {
    if (
      node.type === "class_declaration" ||
      node.type === "abstract_class_declaration" ||
      node.type === "class"
    ) {
      const nameNode = node.childForFieldName?.("name");
      if (nameNode) {
        const className = nameNode.text as SymbolName;
        return class_symbol(className, extract_location(nameNode));
      }
    }
    node = node.parent;
  }
  return undefined;
}

/**
 * Find containing interface by traversing up the AST
 */
function find_containing_interface(capture: CaptureNode): SymbolId | undefined {
  let node = capture.node.parent;

  while (node) {
    if (node.type === "interface_declaration") {
      const nameNode = node.childForFieldName?.("name");
      if (nameNode) {
        const interfaceName = nameNode.text as SymbolName;
        return interface_symbol(interfaceName, extract_location(nameNode));
      }
    }
    node = node.parent;
  }
  return undefined;
}

/**
 * Find containing enum by traversing up the AST
 */
function find_containing_enum(capture: CaptureNode): SymbolId | undefined {
  let node = capture.node.parent;

  while (node) {
    if (node.type === "enum_declaration") {
      const nameNode = node.childForFieldName?.("name");
      if (nameNode) {
        const enumName = nameNode.text as SymbolName;
        const location = extract_location(nameNode);
        return `enum:${location.file_path}:${location.start_line}:${location.start_column}:${location.end_line}:${location.end_column}:${enumName}` as SymbolId;
      }
    }
    node = node.parent;
  }
  return undefined;
}

/**
 * Find containing callable (function/method)
 */
function find_containing_callable(capture: CaptureNode): SymbolId {
  let node = capture.node.parent;

  while (node) {
    if (
      node.type === "function_declaration" ||
      node.type === "function_expression" ||
      node.type === "arrow_function" ||
      node.type === "method_definition"
    ) {
      const nameNode = node.childForFieldName?.("name");

      if (node.type === "method_definition") {
        const methodName = nameNode ? nameNode.text : "anonymous";
        return method_symbol(
          methodName as SymbolName,
          extract_location(nameNode || node)
        );
      } else if (nameNode) {
        // Named function
        return function_symbol(
          nameNode.text as SymbolName,
          extract_location(nameNode)
        );
      } else {
        // Anonymous function/arrow function - use the location as ID
        return function_symbol(
          "anonymous" as SymbolName,
          extract_location(node)
        );
      }
    }
    node = node.parent;
  }
  // Default to unknown function
  return function_symbol("anonymous" as SymbolName, capture.location);
}

/**
 * Extract property type
 */
function extract_property_type(node: SyntaxNode): SymbolName | undefined {
  const typeAnnotation = node.parent?.childForFieldName?.("type");
  if (typeAnnotation) {
    // Skip the colon and get the actual type
    for (const child of typeAnnotation.children || []) {
      if (child.type !== ":") {
        return child.text as SymbolName;
      }
    }
  }
  return undefined;
}

/**
 * Extract parameter type
 */
function extract_parameter_type(node: SyntaxNode): SymbolName | undefined {
  return extract_property_type(node);
}

/**
 * Find decorator target (class, method, or property being decorated)
 */
function find_decorator_target(capture: CaptureNode): SymbolId | undefined {
  // Decorator node's next sibling is typically the target
  const parent = capture.node.parent;
  if (parent) {
    const decoratorIndex = parent.children?.indexOf(capture.node);
    if (decoratorIndex !== undefined && decoratorIndex >= 0) {
      // Look for the next non-decorator sibling
      for (
        let i = decoratorIndex + 1;
        i < (parent.children?.length || 0);
        i++
      ) {
        const sibling = parent.children![i];
        if (sibling.type !== "decorator") {
          // Found the target - extract its ID based on type
          if (
            sibling.type === "class_declaration" ||
            sibling.type === "abstract_class_declaration"
          ) {
            const nameNode = sibling.childForFieldName?.("name");
            if (nameNode) {
              return class_symbol(
                nameNode.text as SymbolName,
                extract_location(nameNode)
              );
            }
          } else if (sibling.type === "method_definition") {
            const nameNode = sibling.childForFieldName?.("name");
            if (nameNode) {
              return method_symbol(
                nameNode.text as SymbolName,
                extract_location(nameNode)
              );
            }
          } else if (sibling.type === "public_field_definition") {
            const nameNode = sibling.childForFieldName?.("name");
            if (nameNode) {
              return property_symbol(
                nameNode.text as SymbolName,
                extract_location(nameNode)
              );
            }
          }
          break;
        }
      }
    }
  }
  return undefined;
}

// ============================================================================
// TypeScript Builder Configuration
// ============================================================================

export const TYPESCRIPT_BUILDER_CONFIG: LanguageBuilderConfig = new Map([
  // ============================================================================
  // JAVASCRIPT FOUNDATION - Start with all JavaScript mappings
  // ============================================================================
  ...Array.from(JAVASCRIPT_BUILDER_CONFIG),

  // ============================================================================
  // INTERFACES
  // ============================================================================
  [
    "def.interface",
    {
      process: (
        capture: CaptureNode,
        builder: DefinitionBuilder,
        context: ProcessingContext
      ) => {
        const interface_id = create_interface_id(capture);
        const parent = capture.node.parent; // interface_declaration
        const extends_clause = parent ? extract_interface_extends(parent) : [];

        builder.add_interface({
          symbol_id: interface_id,
          name: capture.text,
          location: capture.location,
          scope_id: context.get_scope_id(capture.location),
          availability: determine_availability(capture.node),
          extends: extends_clause,
        });
      },
    },
  ],

  [
    "def.interface.method",
    {
      process: (
        capture: CaptureNode,
        builder: DefinitionBuilder,
        context: ProcessingContext
      ) => {
        const interface_id = find_containing_interface(capture);
        if (!interface_id) return;

        const method_id = create_method_signature_id(capture, capture.text);

        builder.add_method_signature_to_interface(interface_id, {
          symbol_id: method_id,
          name: capture.text,
          location: capture.location,
          scope_id: context.get_scope_id(capture.location),
          optional: is_optional_member(capture.node),
          type_parameters: extract_type_parameters(capture.node.parent),
          return_type: extract_return_type(capture.node),
        });
      },
    },
  ],

  [
    "def.interface.property",
    {
      process: (
        capture: CaptureNode,
        builder: DefinitionBuilder,
        context: ProcessingContext
      ) => {
        const interface_id = find_containing_interface(capture);
        if (!interface_id) return;

        const prop_id = create_property_signature_id(capture);

        builder.add_property_signature_to_interface(interface_id, {
          symbol_id: prop_id,
          name: capture.text,
          location: capture.location,
          type: extract_property_type(capture.node),
          optional: is_optional_member(capture.node),
          readonly: is_readonly_property(capture.node),
        });
      },
    },
  ],

  // ============================================================================
  // TYPE ALIASES
  // ============================================================================
  [
    "def.type_alias",
    {
      process: (
        capture: CaptureNode,
        builder: DefinitionBuilder,
        context: ProcessingContext
      ) => {
        const type_id = create_type_alias_id(capture);

        builder.add_type({
          kind: "type_alias",
          symbol_id: type_id,
          name: capture.text,
          location: capture.location,
          scope_id: context.get_scope_id(capture.location),
          availability: determine_availability(capture.node),
          type_expression: extract_type_expression(capture.node),
          type_parameters: capture.node.parent
            ? extract_type_parameters(capture.node.parent)
            : [],
        });
      },
    },
  ],

  // ============================================================================
  // ENUMS
  // ============================================================================
  [
    "def.enum",
    {
      process: (
        capture: CaptureNode,
        builder: DefinitionBuilder,
        context: ProcessingContext
      ) => {
        const enum_id = create_enum_id(capture);

        builder.add_enum({
          symbol_id: enum_id,
          name: capture.text,
          location: capture.location,
          scope_id: context.get_scope_id(capture.location),
          availability: determine_availability(capture.node),
          is_const: is_const_enum(capture.node),
        });
      },
    },
  ],

  [
    "def.enum.member",
    {
      process: (
        capture: CaptureNode,
        builder: DefinitionBuilder,
        context: ProcessingContext
      ) => {
        const enum_id = find_containing_enum(capture);
        if (!enum_id) return;

        const member_id = create_enum_member_id(capture, enum_id);

        builder.add_enum_member(enum_id, {
          symbol_id: member_id,
          name: capture.text,
          location: capture.location,
          value: extract_enum_value(capture.node),
        });
      },
    },
  ],

  // ============================================================================
  // NAMESPACES
  // ============================================================================
  [
    "def.namespace",
    {
      process: (
        capture: CaptureNode,
        builder: DefinitionBuilder,
        context: ProcessingContext
      ) => {
        const namespace_id = create_namespace_id(capture);

        builder.add_namespace({
          symbol_id: namespace_id,
          name: capture.text,
          location: capture.location,
          scope_id: context.get_scope_id(capture.location),
          availability: determine_availability(capture.node),
        });
      },
    },
  ],

  // ============================================================================
  // DECORATORS
  // ============================================================================
  [
    "decorator.class",
    {
      process: (
        capture: CaptureNode,
        builder: DefinitionBuilder,
        context: ProcessingContext
      ) => {
        const target_id = find_decorator_target(capture);
        if (!target_id) return;

        const decorator_name = extract_decorator_name(capture.node);

        builder.add_decorator_to_target(target_id, {
          name: decorator_name,
          arguments: extract_decorator_arguments(capture.node),
          location: capture.location,
        });
      },
    },
  ],

  [
    "decorator.method",
    {
      process: (
        capture: CaptureNode,
        builder: DefinitionBuilder,
        context: ProcessingContext
      ) => {
        const target_id = find_decorator_target(capture);
        if (!target_id) return;

        const decorator_name = extract_decorator_name(capture.node);

        builder.add_decorator_to_target(target_id, {
          name: decorator_name,
          arguments: extract_decorator_arguments(capture.node),
          location: capture.location,
        });
      },
    },
  ],

  [
    "decorator.property",
    {
      process: (
        capture: CaptureNode,
        builder: DefinitionBuilder,
        context: ProcessingContext
      ) => {
        const target_id = find_decorator_target(capture);
        if (!target_id) return;

        const decorator_name = extract_decorator_name(capture.node);

        builder.add_decorator_to_target(target_id, {
          name: decorator_name,
          arguments: extract_decorator_arguments(capture.node),
          location: capture.location,
        });
      },
    },
  ],

  // ============================================================================
  // ENHANCED CLASS DEFINITIONS - Override JavaScript version with TypeScript features
  // ============================================================================
  [
    "def.class",
    {
      process: (
        capture: CaptureNode,
        builder: DefinitionBuilder,
        context: ProcessingContext
      ) => {
        const class_id = create_class_id(capture);
        const parent = capture.node.parent; // class_declaration or abstract_class_declaration

        // Extract extends
        const heritage = parent?.childForFieldName?.("heritage");
        let extends_classes: SymbolName[] = [];
        if (heritage) {
          const extendsClause = heritage.childForFieldName?.("extends_clause");
          if (extendsClause) {
            const superclass = extendsClause.childForFieldName?.("value");
            if (superclass) {
              extends_classes = [superclass.text as SymbolName];
            }
          }
        }

        builder.add_class({
          symbol_id: class_id,
          name: capture.text,
          location: capture.location,
          scope_id: context.get_scope_id(capture.location),
          availability: determine_availability(capture.node),
          abstract: is_abstract_class(capture.node),
          extends: extends_classes,
          implements: parent ? extract_implements(parent) : [],
          type_parameters: parent ? extract_type_parameters(parent) : [],
        });
      },
    },
  ],

  [
    "def.method",
    {
      process: (
        capture: CaptureNode,
        builder: DefinitionBuilder,
        context: ProcessingContext
      ) => {
        const class_id = find_containing_class(capture);
        if (!class_id) return;

        const method_id = create_method_id(capture);
        const parent = capture.node.parent; // method_definition

        builder.add_method_to_class(class_id, {
          symbol_id: method_id,
          name: capture.text,
          location: capture.location,
          scope_id: context.get_scope_id(capture.location),
          availability: determine_method_availability(capture.node),
          access_modifier: extract_access_modifier(capture.node),
          abstract: is_abstract_method(capture.node),
          static: is_static_method(capture.node),
          async: is_async_method(capture.node),
          return_type: extract_return_type(capture.node),
          type_parameters: parent ? extract_type_parameters(parent) : [],
        });
      },
    },
  ],

  [
    "def.field",
    {
      process: (
        capture: CaptureNode,
        builder: DefinitionBuilder,
        context: ProcessingContext
      ) => {
        const class_id = find_containing_class(capture);
        if (!class_id) return;

        const prop_id = create_property_id(capture);

        builder.add_property_to_class(class_id, {
          symbol_id: prop_id,
          name: capture.text,
          location: capture.location,
          scope_id: context.get_scope_id(capture.location),
          availability: determine_method_availability(capture.node),
          access_modifier: extract_access_modifier(capture.node),
          static: is_static_method(capture.node),
          readonly: is_readonly_property(capture.node),
          abstract: is_abstract_method(capture.node),
          type: extract_property_type(capture.node),
          initial_value: undefined, // Would need to extract from node
        });
      },
    },
  ],

  // ============================================================================
  // OPTIONAL PARAMETERS
  // ============================================================================
  [
    "def.param.optional",
    {
      process: (
        capture: CaptureNode,
        builder: DefinitionBuilder,
        context: ProcessingContext
      ) => {
        const param_id = create_parameter_id(capture);
        const parent_id = find_containing_callable(capture);

        builder.add_parameter_to_callable(parent_id, {
          symbol_id: param_id,
          name: capture.text,
          location: capture.location,
          scope_id: context.get_scope_id(capture.location),
          type: extract_parameter_type(capture.node),
          default_value: undefined,
          optional: true,
        });
      },
    },
  ],

  // ============================================================================
  // PARAMETER PROPERTIES (Constructor parameters that become properties)
  // ============================================================================
  [
    "param.property",
    {
      process: (
        capture: CaptureNode,
        builder: DefinitionBuilder,
        context: ProcessingContext
      ) => {
        // This is a constructor parameter that becomes a property
        const class_id = find_containing_class(capture);
        if (!class_id) return;

        const prop_id = create_property_id(capture);
        const parent = capture.node.parent; // required_parameter

        builder.add_property_to_class(class_id, {
          symbol_id: prop_id,
          name: capture.text,
          location: capture.location,
          scope_id: context.get_scope_id(capture.location),
          availability: determine_method_availability(capture.node),
          access_modifier: extract_access_modifier(capture.node),
          readonly: is_readonly_property(capture.node),
          type: extract_parameter_type(capture.node),
          initial_value: undefined,
          is_parameter_property: true,
        });
      },
    },
  ],

  [
    "def.field.param_property",
    {
      process: (
        capture: CaptureNode,
        builder: DefinitionBuilder,
        context: ProcessingContext
      ) => {
        // This is the field definition aspect of a parameter property
        const class_id = find_containing_class(capture);
        if (!class_id) return;

        const prop_id = create_property_id(capture);
        const parent = capture.node.parent; // required_parameter

        builder.add_property_to_class(class_id, {
          symbol_id: prop_id,
          name: capture.text,
          location: capture.location,
          scope_id: context.get_scope_id(capture.location),
          availability: determine_method_availability(capture.node),
          access_modifier: extract_access_modifier(capture.node),
          readonly: is_readonly_property(capture.node),
          type: extract_parameter_type(capture.node),
          initial_value: undefined,
          is_parameter_property: true,
        });
      },
    },
  ],
]);
