/**
 * Rust bespoke return type handlers
 * 
 * Handles Rust-specific features that cannot be expressed through configuration:
 * - impl Trait return types
 * - Result<T, E> and Option<T> patterns
 * - Lifetime annotations in return types
 * - Associated types
 * - Trait objects (dyn Trait)
 */

import { SyntaxNode } from 'tree-sitter';
import { ReturnTypeInfo, ReturnTypeContext } from './return_type_inference';

/**
 * Handle Rust impl Trait return types
 */
export function handle_rust_impl_trait(
  type_node: SyntaxNode,
  context: ReturnTypeContext
): string | undefined {
  if (type_node.type !== 'impl_trait_type' && type_node.type !== 'dyn_trait_type') {
    return undefined;
  }
  
  const source_code = context.source_code;
  const type_text = source_code.substring(type_node.startIndex, type_node.endIndex);
  
  // Simplify complex impl Trait for display
  if (type_text.startsWith('impl ')) {
    // Extract the main trait
    const trait_match = type_text.match(/impl\s+(?:Send\s+\+\s+)?(?:Sync\s+\+\s+)?(\w+)/);
    if (trait_match) {
      return `impl ${trait_match[1]}`;
    }
  }
  
  return type_text;
}

/**
 * Handle Rust Result and Option patterns
 */
export function handle_rust_result_option(
  type_text: string,
  func_node: SyntaxNode,
  context: ReturnTypeContext
): ReturnTypeInfo | undefined {
  // Check for Result<T, E> pattern
  if (type_text.startsWith('Result<')) {
    // Try to infer error type from function context
    const error_type = infer_error_type(func_node, context);
    if (error_type && !type_text.includes(',')) {
      // If only success type is specified
      return {
        type_name: type_text.replace('>', `, ${error_type}>`),
        confidence: 'inferred',
        source: 'pattern'
      };
    }
    return {
      type_name: type_text,
      confidence: 'explicit',
      source: 'annotation'
    };
  }
  
  // Check for Option<T> pattern
  if (type_text.startsWith('Option<')) {
    return {
      type_name: type_text,
      confidence: 'explicit',
      source: 'annotation'
    };
  }
  
  return undefined;
}

/**
 * Handle Rust lifetime annotations in return types
 */
export function handle_rust_lifetimes(
  type_text: string
): string {
  // Simplify lifetime annotations for display
  // &'a str -> &str
  // &'static str -> &'static str (keep 'static)
  
  if (type_text.includes("'static")) {
    // Keep 'static lifetime as it's semantically important
    return type_text;
  }
  
  // Remove other lifetime annotations for clarity
  return type_text.replace(/'\w+\s+/g, '');
}

/**
 * Handle Rust associated types
 */
export function handle_rust_associated_types(
  type_node: SyntaxNode,
  context: ReturnTypeContext
): string | undefined {
  if (type_node.type !== 'associated_type') {
    return undefined;
  }
  
  const source_code = context.source_code;
  const type_text = source_code.substring(type_node.startIndex, type_node.endIndex);
  
  // Handle Self::Item, T::Item patterns
  if (type_text.includes('::')) {
    return type_text;
  }
  
  return undefined;
}

/**
 * Handle Rust macro-generated return types
 */
export function handle_rust_macro_types(
  func_node: SyntaxNode,
  context: ReturnTypeContext
): ReturnTypeInfo | undefined {
  // Check if function is generated by a macro
  const parent = func_node.parent;
  if (parent && parent.type === 'macro_invocation') {
    const macro_name = extract_macro_name(parent, context.source_code);
    
    // Common macros with known return types
    switch (macro_name) {
      case 'vec':
        return {
          type_name: 'Vec<T>',
          confidence: 'inferred',
          source: 'pattern'
        };
        
      case 'format':
        return {
          type_name: 'String',
          confidence: 'explicit',
          source: 'pattern'
        };
        
      case 'println':
      case 'print':
      case 'eprintln':
      case 'eprint':
        return {
          type_name: '()',
          confidence: 'explicit',
          source: 'pattern'
        };
        
      case 'assert':
      case 'assert_eq':
      case 'assert_ne':
        return {
          type_name: '()',
          confidence: 'explicit',
          source: 'pattern'
        };
    }
  }
  
  return undefined;
}

/**
 * Handle Rust trait method implementations
 */
export function handle_rust_trait_methods(
  method_name: string,
  impl_trait: string | undefined
): ReturnTypeInfo | undefined {
  if (!impl_trait) {
    return undefined;
  }
  
  // Common trait methods with known return types
  const trait_methods: Record<string, Record<string, string>> = {
    'Iterator': {
      'next': 'Option<Self::Item>',
      'size_hint': '(usize, Option<usize>)',
      'count': 'usize',
      'last': 'Option<Self::Item>',
      'nth': 'Option<Self::Item>'
    },
    'Clone': {
      'clone': 'Self'
    },
    'Default': {
      'default': 'Self'
    },
    'Display': {
      'fmt': 'fmt::Result'
    },
    'Debug': {
      'fmt': 'fmt::Result'
    },
    'From': {
      'from': 'Self'
    },
    'Into': {
      'into': 'T'
    },
    'TryFrom': {
      'try_from': 'Result<Self, Self::Error>'
    },
    'TryInto': {
      'try_into': 'Result<T, Self::Error>'
    }
  };
  
  for (const [trait, methods] of Object.entries(trait_methods)) {
    if (impl_trait.includes(trait) && method_name in methods) {
      return {
        type_name: methods[method_name],
        confidence: 'explicit',
        source: 'pattern'
      };
    }
  }
  
  return undefined;
}

// Helper functions

function infer_error_type(func_node: SyntaxNode, context: ReturnTypeContext): string | undefined {
  // Look for ? operator usage which suggests error type
  const body = func_node.childForFieldName('body');
  if (!body) {
    return undefined;
  }
  
  // Common error types in order of preference
  const common_errors = ['Error', 'io::Error', 'Box<dyn Error>', 'String', '&str'];
  
  // Simple heuristic: if function name contains 'parse', likely ParseError
  const func_name = func_node.childForFieldName('name');
  if (func_name) {
    const name = context.source_code.substring(func_name.startIndex, func_name.endIndex);
    if (name.includes('parse')) {
      return 'ParseError';
    }
    if (name.includes('read') || name.includes('write')) {
      return 'io::Error';
    }
  }
  
  // Default to generic Error
  return 'Error';
}

function extract_macro_name(macro_node: SyntaxNode, source_code: string): string | undefined {
  const name_node = macro_node.childForFieldName('macro');
  if (name_node) {
    const full_name = source_code.substring(name_node.startIndex, name_node.endIndex);
    // Remove the ! suffix
    return full_name.replace(/!$/, '');
  }
  return undefined;
}