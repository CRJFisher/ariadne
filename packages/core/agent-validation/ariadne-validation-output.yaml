meta:
  timestamp: '2025-08-03T10:48:06.678Z'
  ariadne_version: 0.5.18
  total_files: 19
  total_functions: 121
  total_calls: 100
top_level_nodes:
  - id: src/call_graph_utils#apply_max_depth_filter
    name: apply_max_depth_filter
    file: src/call_graph_utils.ts
    line: 16
    is_exported: false
    calls_count: 0
    called_by_count: 0
  - id: src/call_graph_utils#is_position_within_range
    name: is_position_within_range
    file: src/call_graph_utils.ts
    line: 71
    is_exported: false
    calls_count: 0
    called_by_count: 0
  - id: src/call_graph_utils#get_function_node_range
    name: get_function_node_range
    file: src/call_graph_utils.ts
    line: 86
    is_exported: false
    calls_count: 0
    called_by_count: 0
  - id: src/edit#create_edit
    name: create_edit
    file: src/edit.ts
    line: 13
    is_exported: false
    calls_count: 0
    called_by_count: 0
  - id: src/edit#calculate_end_position
    name: calculate_end_position
    file: src/edit.ts
    line: 39
    is_exported: false
    calls_count: 0
    called_by_count: 0
  - id: src/function_metadata#extract_function_metadata
    name: extract_function_metadata
    file: src/function_metadata.ts
    line: 9
    is_exported: false
    calls_count: 8
    called_by_count: 0
  - id: src/graph#ScopeGraph.constructor
    name: constructor
    file: src/graph.ts
    line: 67
    is_exported: false
    calls_count: 1
    called_by_count: 0
  - id: src/graph#ScopeGraph.insert_local_def
    name: insert_local_def
    file: src/graph.ts
    line: 82
    is_exported: false
    calls_count: 1
    called_by_count: 0
  - id: src/graph#ScopeGraph.insert_hoisted_def
    name: insert_hoisted_def
    file: src/graph.ts
    line: 88
    is_exported: false
    calls_count: 1
    called_by_count: 0
  - id: src/graph#ScopeGraph.insert_global_def
    name: insert_global_def
    file: src/graph.ts
    line: 104
    is_exported: false
    calls_count: 0
    called_by_count: 0
  - id: src/graph#ScopeGraph.insert_local_scope
    name: insert_local_scope
    file: src/graph.ts
    line: 109
    is_exported: false
    calls_count: 1
    called_by_count: 0
  - id: src/graph#ScopeGraph.insert_local_import
    name: insert_local_import
    file: src/graph.ts
    line: 115
    is_exported: false
    calls_count: 1
    called_by_count: 0
  - id: src/graph#ScopeGraph.insert_ref
    name: insert_ref
    file: src/graph.ts
    line: 121
    is_exported: false
    calls_count: 4
    called_by_count: 0
  - id: src/graph#ScopeGraph.node_to_simple_range
    name: node_to_simple_range
    file: src/graph.ts
    line: 194
    is_exported: false
    calls_count: 0
    called_by_count: 0
  - id: src/graph#ScopeGraph.getEdges
    name: getEdges
    file: src/graph.ts
    line: 244
    is_exported: false
    calls_count: 0
    called_by_count: 0
  - id: src/graph#ScopeGraph.getDefsForRef
    name: getDefsForRef
    file: src/graph.ts
    line: 249
    is_exported: false
    calls_count: 0
    called_by_count: 0
  - id: src/graph#ScopeGraph.getImportsForRef
    name: getImportsForRef
    file: src/graph.ts
    line: 260
    is_exported: false
    calls_count: 0
    called_by_count: 0
  - id: src/graph#ScopeGraph.getRefsForDef
    name: getRefsForDef
    file: src/graph.ts
    line: 271
    is_exported: false
    calls_count: 0
    called_by_count: 0
  - id: src/graph#ScopeGraph.findNodeAtPosition
    name: findNodeAtPosition
    file: src/graph.ts
    line: 282
    is_exported: false
    calls_count: 1
    called_by_count: 0
  - id: src/graph#ScopeGraph.getAllDefs
    name: getAllDefs
    file: src/graph.ts
    line: 324
    is_exported: false
    calls_count: 1
    called_by_count: 0
  - id: src/graph#ScopeGraph.getAllImports
    name: getAllImports
    file: src/graph.ts
    line: 329
    is_exported: false
    calls_count: 1
    called_by_count: 0
  - id: src/graph#ScopeGraph.findExportedDef
    name: findExportedDef
    file: src/graph.ts
    line: 334
    is_exported: false
    calls_count: 1
    called_by_count: 0
  - id: src/graph#ScopeGraph.debug_print
    name: debug_print
    file: src/graph.ts
    line: 352
    is_exported: false
    calls_count: 0
    called_by_count: 0
  - id: src/graph#ScopeGraph.getCallsFromDef
    name: getCallsFromDef
    file: src/graph.ts
    line: 365
    is_exported: false
    calls_count: 0
    called_by_count: 0
  - id: src/graph#ScopeGraph.getSymbolId
    name: getSymbolId
    file: src/graph.ts
    line: 370
    is_exported: false
    calls_count: 0
    called_by_count: 0
  - id: src/graph#ScopeGraph.getDefinitionBySymbol
    name: getDefinitionBySymbol
    file: src/graph.ts
    line: 374
    is_exported: false
    calls_count: 1
    called_by_count: 0
  - id: src/graph#ScopeGraph.getFunctionCalls
    name: getFunctionCalls
    file: src/graph.ts
    line: 378
    is_exported: false
    calls_count: 0
    called_by_count: 0
  - id: src/graph#ScopeGraph.getImportInfo
    name: getImportInfo
    file: src/graph.ts
    line: 383
    is_exported: false
    calls_count: 0
    called_by_count: 0
  - id: src/graph#ScopeGraph.getCallGraph
    name: getCallGraph
    file: src/graph.ts
    line: 388
    is_exported: false
    calls_count: 0
    called_by_count: 0
  - id: src/inheritance#extract_class_relationships
    name: extract_class_relationships
    file: src/inheritance.ts
    line: 14
    is_exported: false
    calls_count: 6
    called_by_count: 0
  - id: src/languages/shared_extractors#extract_jsdoc_context
    name: extract_jsdoc_context
    file: src/languages/shared_extractors.ts
    line: 7
    is_exported: false
    calls_count: 0
    called_by_count: 0
  - id: src/module_resolver#ModuleResolver.resolveModulePath
    name: resolveModulePath
    file: src/module_resolver.ts
    line: 31
    is_exported: false
    calls_count: 2
    called_by_count: 0
  - id: src/module_resolver#ModuleResolver.resolvePythonImport
    name: resolvePythonImport
    file: src/module_resolver.ts
    line: 171
    is_exported: false
    calls_count: 0
    called_by_count: 0
  - id: src/module_resolver#ModuleResolver.resolveRustModule
    name: resolveRustModule
    file: src/module_resolver.ts
    line: 233
    is_exported: false
    calls_count: 1
    called_by_count: 0
  - id: src/project_inheritance#ProjectInheritance.constructor
    name: constructor
    file: src/project_inheritance.ts
    line: 22
    is_exported: false
    calls_count: 0
    called_by_count: 0
  - id: src/project_inheritance#ProjectInheritance.find_subclasses
    name: find_subclasses
    file: src/project_inheritance.ts
    line: 82
    is_exported: false
    calls_count: 1
    called_by_count: 0
  - id: src/project_inheritance#ProjectInheritance.find_implementations
    name: find_implementations
    file: src/project_inheritance.ts
    line: 111
    is_exported: false
    calls_count: 1
    called_by_count: 0
  - id: src/project_inheritance#ProjectInheritance.is_subclass_of
    name: is_subclass_of
    file: src/project_inheritance.ts
    line: 167
    is_exported: false
    calls_count: 1
    called_by_count: 0
  - id: src/project_source#ProjectSource.constructor
    name: constructor
    file: src/project_source.ts
    line: 19
    is_exported: false
    calls_count: 0
    called_by_count: 0
  - id: src/project_source#ProjectSource.get_source_with_context
    name: get_source_with_context
    file: src/project_source.ts
    line: 132
    is_exported: false
    calls_count: 3
    called_by_count: 0
  - id: src/scope_resolution#build_scope_graph
    name: build_scope_graph
    file: src/scope_resolution.ts
    line: 11
    is_exported: false
    calls_count: 4
    called_by_count: 0
  - id: src/symbol_naming#get_symbol_id
    name: get_symbol_id
    file: src/symbol_naming.ts
    line: 16
    is_exported: false
    calls_count: 4
    called_by_count: 0
  - id: src/symbol_naming#create_method_symbol_id
    name: create_method_symbol_id
    file: src/symbol_naming.ts
    line: 104
    is_exported: false
    calls_count: 0
    called_by_count: 0
  - id: src/symbol_naming#get_symbol_container
    name: get_symbol_container
    file: src/symbol_naming.ts
    line: 129
    is_exported: false
    calls_count: 4
    called_by_count: 0
  - id: src/symbol_naming#get_unqualified_name
    name: get_unqualified_name
    file: src/symbol_naming.ts
    line: 146
    is_exported: false
    calls_count: 2
    called_by_count: 0
  - id: src/symbol_naming#same_module
    name: same_module
    file: src/symbol_naming.ts
    line: 165
    is_exported: false
    calls_count: 4
    called_by_count: 0
  - id: src/symbol_resolver#find_definition
    name: find_definition
    file: src/symbol_resolver.ts
    line: 86
    is_exported: false
    calls_count: 0
    called_by_count: 0
sampled_nodes:
  - node:
      id: src/call_graph_utils#apply_max_depth_filter
      name: apply_max_depth_filter
      file: src/call_graph_utils.ts
      line: 16
    outgoing_calls: []
    incoming_calls: []
    source_snippet: |2-
       * @returns Filtered nodes and edges within max_depth from top-level nodes
       */
      export function apply_max_depth_filter(
        nodes: Map<string, CallGraphNode>,
        edges: CallGraphEdge[],
        top_level_nodes: string[],
        max_depth: number
      ): { nodes: Map<string, CallGraphNode>; edges: CallGraphEdge[] } {
        // BFS from top-level nodes to find nodes within max_depth
        const visited = new Set<string>();
        const queue: { node: string; depth: number }[] = [];
        
        // Start with top-level nodes
        for (const node of top_level_nodes) {
          queue.push({ node, depth: 0 });
          visited.add(node);
        }
        
        // BFS traversal
        while (queue.length > 0) {
          const { node, depth } = queue.shift()!;
          
          if (depth >= max_depth) continue;
          
          // Add all nodes called by this node
          const caller_node = nodes.get(node);
          if (caller_node) {
            for (const call of caller_node.calls) {
              if (!visited.has(call.symbol)) {
                visited.add(call.symbol);
                queue.push({ node: call.symbol, depth: depth + 1 });
              }
            }
          }
        }
        
        // Filter nodes and edges
        const filtered_nodes = new Map<string, CallGraphNode>();
        for (const [symbol, node] of nodes) {
          if (visited.has(symbol)) {
            filtered_nodes.set(symbol, node);
          }
        }
        
        const filtered_edges = edges.filter(
          edge => visited.has(edge.from) && visited.has(edge.to)
        );
        
        return {
          nodes: filtered_nodes,
          edges: filtered_edges
        };
      }

      /**
  - node:
      id: src/call_graph_utils#is_position_within_range
      name: is_position_within_range
      file: src/call_graph_utils.ts
      line: 71
    outgoing_calls: []
    incoming_calls: []
    source_snippet: |2-
       * Check if a position is within a range
       */
      export function is_position_within_range(position: SimpleRange, range: SimpleRange): boolean {
        // Check if position start is after range start
        const afterStart = position.start.row > range.start.row ||
          (position.start.row === range.start.row && position.start.column >= range.start.column);
        
        // Check if position end is before range end  
        const beforeEnd = position.end.row < range.end.row ||
          (position.end.row === range.end.row && position.end.column <= range.end.column);
        
        return afterStart && beforeEnd;
      }

      /**
  - node:
      id: src/call_graph_utils#get_function_node_range
      name: get_function_node_range
      file: src/call_graph_utils.ts
      line: 86
    outgoing_calls: []
    incoming_calls: []
    source_snippet: |2-
       * Extract function metadata from AST node
       */
      export function get_function_node_range(node: any): SimpleRange | null {
        if (!node) return null;
        
        return {
          start: { row: node.startPosition.row, column: node.startPosition.column },
          end: { row: node.endPosition.row, column: node.endPosition.column }
        };
      }
  - node:
      id: src/benchmark-incremental#generateLargeFile
      name: generateLargeFile
      file: src/benchmark-incremental.ts
      line: 8
    outgoing_calls: []
    incoming_calls: []
    source_snippet: |-

      // Create a large TypeScript file for benchmarking
      function generateLargeFile(functionCount: number): string {
        const lines: string[] = [];
        
        // Add imports
        lines.push(`import { Something } from './module';`);
        lines.push('');
        
        // Add interfaces
        for (let i = 0; i < 10; i++) {
          lines.push(`interface Interface${i} {`);
          lines.push(`  prop${i}: string;`);
          lines.push(`  method${i}(): void;`);
          lines.push(`}`);
          lines.push('');
        }
        
        // Add functions
        for (let i = 0; i < functionCount; i++) {
          lines.push(`function function_${i}(param${i}: number): number {`);
          lines.push(`  const result = param${i} * 2;`);
          lines.push(`  return result + ${i};`);
          lines.push(`}`);
          lines.push('');
        }
        
        // Add a class
        lines.push('class LargeClass {');
        for (let i = 0; i < 20; i++) {
          lines.push(`  method${i}() {`);
          lines.push(`    return function_${i % functionCount}(${i});`);
          lines.push(`  }`);
          lines.push('');
        }
        lines.push('}');
        
        return lines.join('\n');
      }

      // Benchmark function
  - node:
      id: src/benchmark-incremental#benchmark
      name: benchmark
      file: src/benchmark-incremental.ts
      line: 47
    outgoing_calls: []
    incoming_calls: []
    source_snippet: |-

      // Benchmark function
      function benchmark(name: string, fn: () => void): number {
        const start = process.hrtime.bigint();
        fn();
        const end = process.hrtime.bigint();
        const duration = Number(end - start) / 1_000_000; // Convert to milliseconds
        console.log(`${name}: ${duration.toFixed(2)}ms`);
        return duration;
      }

      // Run benchmarks
  - node:
      id: src/function_metadata#extract_typescript_function_metadata
      name: extract_typescript_function_metadata
      file: src/function_metadata.ts
      line: 36
    outgoing_calls:
      - target_id: src/function_metadata#extract_parameter_names
        target_name: extract_parameter_names
        target_file: src/function_metadata.ts
        call_line: 69
        call_type: direct
      - target_id: src/function_metadata#is_typescript_test_function
        target_name: is_typescript_test_function
        target_file: src/function_metadata.ts
        call_line: 73
        call_type: direct
      - target_id: src/function_metadata#is_arrow_function_in_test_block
        target_name: is_arrow_function_in_test_block
        target_file: src/function_metadata.ts
        call_line: 77
        call_type: direct
    incoming_calls:
      - source_id: src/function_metadata#extract_function_metadata
        source_name: extract_function_metadata
        source_file: src/function_metadata.ts
      - source_id: src/function_metadata#extract_function_metadata
        source_name: extract_function_metadata
        source_file: src/function_metadata.ts
    source_snippet: |2-
       * Extract metadata for TypeScript functions
       */
      function extract_typescript_function_metadata(
        node: SyntaxNode,
        parent_node: SyntaxNode | null,
        source_code: string
      ): FunctionMetadata {
        // If node is an identifier and parent is a function, use parent as the function node
        let function_node = node;
        let actual_parent = parent_node;
        
        if ((node.type === "identifier" || node.type === "property_identifier" || node.type === "private_property_identifier") && parent_node) {
          if (parent_node.type === "function_declaration" || 
              parent_node.type === "function_expression" ||
              parent_node.type === "arrow_function" ||
              parent_node.type === "method_definition" ||
              parent_node.type === "generator_function_declaration") {
            function_node = parent_node;
            actual_parent = parent_node.parent;
          }
        }

        const metadata: FunctionMetadata = {
          line_count: function_node.endPosition.row - function_node.startPosition.row + 1,
        };

        // Check if async
        const first_child = function_node.child(0);
        if (first_child && first_child.type === "async") {
          metadata.is_async = true;
        }

        // Extract parameter names
        const params_node = function_node.childForFieldName("parameters");
        if (params_node) {
          metadata.parameter_names = extract_parameter_names(params_node);
        }

        // Check if it's a test function
        metadata.is_test = is_typescript_test_function(function_node, source_code);
        
        // For arrow functions, also check if they're inside test blocks
        if (!metadata.is_test && function_node.type === "arrow_function") {
          metadata.is_test = is_arrow_function_in_test_block(function_node);
        }

        // Check if it's a method within a class
        if (actual_parent && (actual_parent.type === "class_body" || actual_parent.type === "class_declaration")) {
          // Find the class name
          let class_node = actual_parent;
          if (actual_parent.type === "class_body") {
            class_node = actual_parent.parent!;
          }
          const class_name_node = class_node.childForFieldName("name");
          if (class_name_node) {
            metadata.class_name = class_name_node.text;
          }
        }

        // Check if private (TypeScript uses private keyword or # prefix)
        if (function_node.type === "method_definition") {
          // Check for private keyword
          for (let i = 0; i < function_node.childCount; i++) {
            const child = function_node.child(i);
            if (child && child.type === "accessibility_modifier" && child.text === "private") {
              metadata.is_private = true;
              break;
            }
          }
          // Check for # prefix
          const property_name = function_node.childForFieldName("name");
          if (property_name && property_name.text.startsWith("#")) {
            metadata.is_private = true;
          }
        }
        
        // Also check if the original node was a private_property_identifier
        if (node.type === "private_property_identifier") {
          metadata.is_private = true;
          
          // For private methods, we need to check the grandparent for the class
          if (!metadata.class_name && function_node.parent && function_node.parent.type === "class_body") {
            const class_body = function_node.parent;
            if (class_body.parent && class_body.parent.type === "class_declaration") {
              const class_name_node = class_body.parent.childForFieldName("name");
              if (class_name_node) {
                metadata.class_name = class_name_node.text;
              }
            }
          }
        }

        return metadata;
      }

      /**
  - node:
      id: src/function_metadata#extract_javascript_function_metadata
      name: extract_javascript_function_metadata
      file: src/function_metadata.ts
      line: 132
    outgoing_calls:
      - target_id: src/function_metadata#extract_parameter_names
        target_name: extract_parameter_names
        target_file: src/function_metadata.ts
        call_line: 166
        call_type: direct
      - target_id: src/function_metadata#is_javascript_test_function
        target_name: is_javascript_test_function
        target_file: src/function_metadata.ts
        call_line: 170
        call_type: direct
      - target_id: src/function_metadata#is_arrow_function_in_test_block
        target_name: is_arrow_function_in_test_block
        target_file: src/function_metadata.ts
        call_line: 174
        call_type: direct
    incoming_calls:
      - source_id: src/function_metadata#extract_function_metadata
        source_name: extract_function_metadata
        source_file: src/function_metadata.ts
      - source_id: src/function_metadata#extract_function_metadata
        source_name: extract_function_metadata
        source_file: src/function_metadata.ts
    source_snippet: |2-
       * Extract metadata for JavaScript functions
       */
      function extract_javascript_function_metadata(
        node: SyntaxNode,
        parent_node: SyntaxNode | null,
        source_code: string
      ): FunctionMetadata {
        // If node is an identifier and parent is a function, use parent as the function node
        let function_node = node;
        let actual_parent = parent_node;
        
        if ((node.type === "identifier" || node.type === "property_identifier" || node.type === "private_property_identifier") && parent_node) {
          if (parent_node.type === "function_declaration" || 
              parent_node.type === "function_expression" ||
              parent_node.type === "arrow_function" ||
              parent_node.type === "method_definition" ||
              parent_node.type === "generator_function_declaration") {
            function_node = parent_node;
            actual_parent = parent_node.parent;
          }
        }

        // JavaScript metadata extraction is similar to TypeScript but without type information
        const metadata: FunctionMetadata = {
          line_count: function_node.endPosition.row - function_node.startPosition.row + 1,
        };

        // Check if async
        const first_child = function_node.child(0);
        if (first_child && first_child.type === "async") {
          metadata.is_async = true;
        }

        // Extract parameter names
        const params_node = function_node.childForFieldName("parameters");
        if (params_node) {
          metadata.parameter_names = extract_parameter_names(params_node);
        }

        // Check if it's a test function
        metadata.is_test = is_javascript_test_function(function_node, source_code);
        
        // For arrow functions, also check if they're inside test blocks
        if (!metadata.is_test && function_node.type === "arrow_function") {
          metadata.is_test = is_arrow_function_in_test_block(function_node);
        }

        // Check if it's a method within a class
        if (actual_parent && (actual_parent.type === "class_body" || actual_parent.type === "class_declaration")) {
          // Find the class name
          let class_node = actual_parent;
          if (actual_parent.type === "class_body") {
            class_node = actual_parent.parent!;
          }
          const class_name_node = class_node.childForFieldName("name");
          if (class_name_node) {
            metadata.class_name = class_name_node.text;
          }
        } else if (!metadata.class_name && function_node.type === "method_definition") {
          // Alternative path: when actual_parent wasn't set correctly, check function_node's parent
          if (function_node.parent && function_node.parent.type === "class_body") {
            const class_body = function_node.parent;
            if (class_body.parent && class_body.parent.type === "class_declaration") {
              const class_name_node = class_body.parent.childForFieldName("name");
              if (class_name_node) {
                metadata.class_name = class_name_node.text;
              }
            }
          }
        }

        // Check if private (# prefix for private fields/methods)
        if (function_node.type === "method_definition") {
          const property_name = function_node.childForFieldName("name");
          if (property_name && property_name.text.startsWith("#")) {
            metadata.is_private = true;
          }
        }
        
        // Also check if the original node was a private_property_identifier
        if (node.type === "private_property_identifier") {
          metadata.is_private = true;
          
          // For private methods, we need to check if we're in a class
          if (!metadata.class_name && function_node.type === "method_definition") {
            // Method definition's parent is class_body
            if (function_node.parent && function_node.parent.type === "class_body") {
              const class_body = function_node.parent;
              if (class_body.parent && class_body.parent.type === "class_declaration") {
                const class_name_node = class_body.parent.childForFieldName("name");
                if (class_name_node) {
                  metadata.class_name = class_name_node.text;
                }
              }
            }
          }
        }

        return metadata;
      }

      /**
  - node:
      id: src/function_metadata#extract_python_function_metadata
      name: extract_python_function_metadata
      file: src/function_metadata.ts
      line: 234
    outgoing_calls:
      - target_id: src/function_metadata#extract_python_parameter_names
        target_name: extract_python_parameter_names
        target_file: src/function_metadata.ts
        call_line: 261
        call_type: direct
    incoming_calls:
      - source_id: src/function_metadata#extract_function_metadata
        source_name: extract_function_metadata
        source_file: src/function_metadata.ts
      - source_id: src/function_metadata#extract_function_metadata
        source_name: extract_function_metadata
        source_file: src/function_metadata.ts
    source_snippet: |2-
       * Extract metadata for Python functions
       */
      function extract_python_function_metadata(
        node: SyntaxNode,
        parent_node: SyntaxNode | null,
        _source_code: string
      ): FunctionMetadata {
        // If node is an identifier and parent is a function, use parent as the function node
        let function_node = node;
        let actual_parent = parent_node;
        
        if (node.type === "identifier" && parent_node && parent_node.type === "function_definition") {
          function_node = parent_node;
          actual_parent = parent_node.parent;
        }

        const metadata: FunctionMetadata = {
          line_count: function_node.endPosition.row - function_node.startPosition.row + 1,
        };

        // Check if async
        const async_keyword = function_node.child(0);
        if (async_keyword && async_keyword.type === "async") {
          metadata.is_async = true;
        }

        // Extract parameter names
        const params_node = function_node.childForFieldName("parameters");
        if (params_node) {
          metadata.parameter_names = extract_python_parameter_names(params_node);
        }

        // Get function name to check if private
        const name_node = function_node.childForFieldName("name");
        if (name_node && name_node.text.startsWith("_")) {
          metadata.is_private = true;
        }

        // Check if it's a test function
        if (name_node) {
          const func_name = name_node.text;
          if (func_name.startsWith("test_") || func_name === "setUp" || func_name === "tearDown") {
            metadata.is_test = true;
          }
        }

        // Check for decorators
        if (actual_parent && actual_parent.type === "decorated_definition") {
          metadata.has_decorator = true;
          // Check for test decorators
          const decorator_list = actual_parent.child(0);
          if (decorator_list && decorator_list.type === "decorator") {
            const decorator_text = decorator_list.text;
            if (decorator_text.includes("@pytest") || decorator_text.includes("@unittest")) {
              metadata.is_test = true;
            }
          }
        }

        // Check if it's a method within a class
        let current = actual_parent;
        while (current) {
          if (current.type === "class_definition") {
            const class_name_node = current.childForFieldName("name");
            if (class_name_node) {
              metadata.class_name = class_name_node.text;
            }
            break;
          }
          current = current.parent;
        }

        return metadata;
      }

      /**
file_summary:
  - file: src/graph.ts
    function_count: 30
    exported_function_count: 0
    import_count: 27
  - file: src/symbol_naming.ts
    function_count: 18
    exported_function_count: 0
    import_count: 1
  - file: src/function_metadata.ts
    function_count: 12
    exported_function_count: 0
    import_count: 3
  - file: src/module_resolver.ts
    function_count: 10
    exported_function_count: 0
    import_count: 0
  - file: src/project_inheritance.ts
    function_count: 8
    exported_function_count: 0
    import_count: 7
  - file: src/call_graph_utils.ts
    function_count: 6
    exported_function_count: 0
    import_count: 5
  - file: src/inheritance.ts
    function_count: 6
    exported_function_count: 0
    import_count: 3
  - file: src/project_source.ts
    function_count: 5
    exported_function_count: 0
    import_count: 4
  - file: src/symbol_resolver.ts
    function_count: 5
    exported_function_count: 0
    import_count: 5
  - file: src/edit.ts
    function_count: 4
    exported_function_count: 0
    import_count: 2
  - file: src/scope_resolution.ts
    function_count: 4
    exported_function_count: 0
    import_count: 10
  - file: src/languages/python/index.ts
    function_count: 3
    exported_function_count: 0
    import_count: 7
  - file: src/benchmark-incremental.ts
    function_count: 2
    exported_function_count: 0
    import_count: 1
  - file: src/languages/javascript/index.ts
    function_count: 2
    exported_function_count: 0
    import_count: 6
  - file: src/languages/rust/index.ts
    function_count: 2
    exported_function_count: 0
    import_count: 4
  - file: src/languages/shared_extractors.ts
    function_count: 2
    exported_function_count: 0
    import_count: 2
  - file: src/languages/typescript/index.ts
    function_count: 2
    exported_function_count: 0
    import_count: 6
validation_stats:
  nodes_with_calls_pct: 36.633663366336634
  nodes_called_by_others_pct: 53.46534653465347
  exported_nodes_pct: 0
  edges_with_call_type_pct: 100
  top_level_accuracy_pct: 100
