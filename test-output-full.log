
> ariadne@0.5.8 test
> npm run test --workspaces


> @ariadnejs/core@0.7.0 test
> vitest run


 RUN  v3.2.4 /Users/chuck/workspace/ariadne/packages/core

 ❯ src/index_single_file/semantic_index.javascript.test.ts (26 tests | 4 failed | 2 skipped) 604ms
   × Semantic Index - JavaScript > JavaScript fixtures > should correctly parse basic_function.js 7ms
     → ENOENT: no such file or directory, open '/Users/chuck/workspace/ariadne/packages/core/tests/fixtures/javascript/basic_function.js'
   × Semantic Index - JavaScript > JavaScript fixtures > should correctly parse class_and_methods.js 1ms
     → ENOENT: no such file or directory, open '/Users/chuck/workspace/ariadne/packages/core/tests/fixtures/javascript/class_and_methods.js'
   × Semantic Index - JavaScript > JavaScript fixtures > should correctly parse imports_exports.js 0ms
     → ENOENT: no such file or directory, open '/Users/chuck/workspace/ariadne/packages/core/tests/fixtures/javascript/imports_exports.js'
   × Semantic Index - JavaScript > JavaScript fixtures > should correctly parse all export types from imports_exports fixture 0ms
     → ENOENT: no such file or directory, open '/Users/chuck/workspace/ariadne/packages/core/tests/fixtures/javascript/imports_exports.js'
   ✓ Semantic Index - JavaScript > Import type detection in semantic index > should correctly create Import objects for all import types 64ms
   ✓ Semantic Index - JavaScript > Detailed capture parsing > should correctly parse function definitions and calls 28ms
   ✓ Semantic Index - JavaScript > Detailed capture parsing > should correctly parse static methods 28ms
   ✓ Semantic Index - JavaScript > Detailed capture parsing > should correctly parse method calls with receivers 29ms
   ✓ Semantic Index - JavaScript > Detailed capture parsing > should correctly capture constructor calls with target assignment 28ms
   ✓ Semantic Index - JavaScript > Detailed capture parsing > should populate receiver_location for method calls 29ms
   ↓ Semantic Index - JavaScript > Detailed capture parsing > should populate type_info for type references (JSDoc not supported)
   ✓ Semantic Index - JavaScript > Detailed capture parsing > should capture property access chains correctly 28ms
   ✓ Semantic Index - JavaScript > Detailed capture parsing > should populate appropriate context for function calls 29ms
   ↓ Semantic Index - JavaScript > Detailed capture parsing > should handle assignment metadata correctly (not currently implemented)
   ✓ Semantic Index - JavaScript > Comprehensive feature coverage > should correctly parse destructuring assignments 27ms
   ✓ Semantic Index - JavaScript > Comprehensive feature coverage > should correctly parse default and rest parameters 27ms
   ✓ Semantic Index - JavaScript > Comprehensive feature coverage > should correctly parse computed member access and bracket notation 27ms
   ✓ Semantic Index - JavaScript > Comprehensive feature coverage > should correctly parse generator functions 27ms
   ✓ Semantic Index - JavaScript > Comprehensive feature coverage > should correctly parse async/await functions 28ms
   ✓ Semantic Index - JavaScript > Comprehensive feature coverage > should correctly parse private class fields and methods 27ms
   ✓ Semantic Index - JavaScript > Comprehensive feature coverage > should correctly parse update expressions and assignments 27ms
   ✓ Semantic Index - JavaScript > Comprehensive feature coverage > should correctly parse catch clause parameters 27ms
   ✓ Semantic Index - JavaScript > Comprehensive feature coverage > should correctly parse for-in and for-of loop variables 27ms
   ✓ Semantic Index - JavaScript > Comprehensive feature coverage > should correctly parse template literals and tagged templates 27ms
   ✓ Semantic Index - JavaScript > Comprehensive feature coverage > should correctly parse spread operators in function calls 27ms
   ✓ Semantic Index - JavaScript > Comprehensive feature coverage > should correctly parse multiple variable declarations in one statement 27ms
 ❯ src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts (32 tests | 20 failed) 45ms
   ✓ rust_builder > struct definitions > should process simple struct 9ms
   × rust_builder > struct definitions > should process generic struct 5ms
     → expected undefined to deeply equal [ 'T', 'U' ]
   ✓ rust_builder > struct definitions > should process tuple struct 0ms
   × rust_builder > struct definitions > should handle pub(crate) visibility 1ms
     → expected 'package-internal' to be 'package' // Object.is equality
   × rust_builder > enum definitions > should process simple enum 6ms
     → expected [ { …(3) }, { …(3) }, { …(3) } ] to deeply equal [ 'Success', 'Error', 'Pending' ]
   × rust_builder > enum definitions > should process generic enum 1ms
     → expected undefined to deeply equal [ 'T', 'E' ]
   × rust_builder > enum definitions > should process enum with complex variants 2ms
     → expected [ { …(3) }, { …(3) }, { …(3) } ] to deeply equal [ 'Quit', 'Move', 'Write' ]
   ✓ rust_builder > trait definitions > should process simple trait 1ms
   × rust_builder > trait definitions > should process generic trait 1ms
     → expected undefined to deeply equal [ 'Item' ]
   × rust_builder > function definitions > should process simple function 1ms
     → expected undefined to be 'i32' // Object.is equality
   × rust_builder > function definitions > should process async function 1ms
     → expected undefined to be true // Object.is equality
   × rust_builder > function definitions > should process const function 1ms
     → expected undefined to be true // Object.is equality
   × rust_builder > function definitions > should process unsafe function 1ms
     → expected undefined to be true // Object.is equality
   × rust_builder > function definitions > should process generic function 1ms
     → expected undefined to deeply equal [ 'T' ]
   ✓ rust_builder > method definitions > should process instance method 1ms
   ✓ rust_builder > method definitions > should process associated function (static method) 0ms
   ✓ rust_builder > variable and constant definitions > should process let binding 1ms
   × rust_builder > variable and constant definitions > should process const definition 1ms
     → expected undefined to be true // Object.is equality
   × rust_builder > variable and constant definitions > should process static variable 1ms
     → expected undefined to be true // Object.is equality
   × rust_builder > parameter definitions > should process function parameter 2ms
     → Target cannot be null or undefined.
   × rust_builder > parameter definitions > should process mutable parameter 1ms
     → Target cannot be null or undefined.
   ✓ rust_builder > parameter definitions > should process self parameter 0ms
   × rust_builder > type definitions > should process type alias 1ms
     → expected undefined to deeply equal [ 'T' ]
   ✓ rust_builder > type definitions > should process module definition 1ms
   ✓ rust_builder > visibility extraction > should detect pub visibility 0ms
   × rust_builder > visibility extraction > should detect pub(crate) visibility 1ms
     → expected 'package-internal' to be 'package' // Object.is equality
   × rust_builder > visibility extraction > should detect pub(super) visibility 1ms
     → expected 'file-private' to be 'parent-module' // Object.is equality
   ✓ rust_builder > visibility extraction > should default to file-private for no visibility 0ms
   × rust_builder > macro definitions > should process macro definition 1ms
     → expected undefined to be true // Object.is equality
   ✓ rust_builder > field definitions > should process struct fields 1ms
   × rust_builder > integration tests > should handle complex struct with multiple features 1ms
     → the given combination of arguments (undefined and string) is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a string
   ✓ rust_builder > integration tests > should handle trait with associated types and default methods 0ms
 ❯ src/index_single_file/query_code_tree/language_configs/python_builder.test.ts (28 tests | 8 failed) 16ms
   ✓ Python Builder Configuration > PYTHON_BUILDER_CONFIG > should export a valid LanguageBuilderConfig 0ms
   ✓ Python Builder Configuration > PYTHON_BUILDER_CONFIG > should contain class definition capture mappings 0ms
   ✓ Python Builder Configuration > PYTHON_BUILDER_CONFIG > should contain method definition capture mappings 0ms
   × Python Builder Configuration > PYTHON_BUILDER_CONFIG > should contain function definition capture mappings 1ms
     → expected false to be true // Object.is equality
   × Python Builder Configuration > PYTHON_BUILDER_CONFIG > should contain parameter definition capture mappings 0ms
     → expected false to be true // Object.is equality
   × Python Builder Configuration > PYTHON_BUILDER_CONFIG > should contain variable definition capture mappings 0ms
     → expected false to be true // Object.is equality
   × Python Builder Configuration > PYTHON_BUILDER_CONFIG > should contain property definition capture mappings 0ms
     → expected false to be true // Object.is equality
   ✓ Python Builder Configuration > PYTHON_BUILDER_CONFIG > should contain import capture mappings 0ms
   ✓ Python Builder Configuration > PYTHON_BUILDER_CONFIG > should handle a simple class definition 2ms
   ✓ Python Builder Configuration > PYTHON_BUILDER_CONFIG > should handle a method definition 0ms
   ✓ Python Builder Configuration > PYTHON_BUILDER_CONFIG > should handle a function definition 0ms
   ✓ Python Builder Configuration > PYTHON_BUILDER_CONFIG > should handle variable definitions 0ms
   ✓ Python Builder Configuration > PYTHON_BUILDER_CONFIG > should handle import statements 0ms
   ✓ Python Builder Configuration > PYTHON_BUILDER_CONFIG > should handle async functions 0ms
   ✓ Python Builder Configuration > PYTHON_BUILDER_CONFIG > should handle lambda functions 0ms
   ✓ Python Builder Configuration > PYTHON_BUILDER_CONFIG > should handle static methods 0ms
   ✓ Python Builder Configuration > PYTHON_BUILDER_CONFIG > should handle class methods 0ms
   ✓ Python Builder Configuration > PYTHON_BUILDER_CONFIG > should handle properties 0ms
   ✓ Python Builder Configuration > PYTHON_BUILDER_CONFIG > should handle class inheritance 1ms
   ✓ Python Builder Configuration > PYTHON_BUILDER_CONFIG > should handle typed parameters 0ms
   ✓ Python Builder Configuration > PYTHON_BUILDER_CONFIG > should handle *args and **kwargs 0ms
   ✓ Python Builder Configuration > PYTHON_BUILDER_CONFIG > should handle from imports 0ms
   ✓ Python Builder Configuration > PYTHON_BUILDER_CONFIG > should handle aliased imports 0ms
   × Python Builder Configuration > PYTHON_BUILDER_CONFIG > End-to-end integration tests > should build complete class definition with methods 1ms
     → actual value must be number or bigint, received "undefined"
   × Python Builder Configuration > PYTHON_BUILDER_CONFIG > End-to-end integration tests > should handle function with typed parameters 1ms
     → actual value must be number or bigint, received "undefined"
   × Python Builder Configuration > PYTHON_BUILDER_CONFIG > End-to-end integration tests > should distinguish between constants and variables by naming convention 0ms
     → defs1.find is not a function
   ✓ Python Builder Configuration > PYTHON_BUILDER_CONFIG > End-to-end integration tests > should handle complex import patterns 1ms
   × Python Builder Configuration > PYTHON_BUILDER_CONFIG > End-to-end integration tests > should handle private methods by naming convention 1ms
     → definitions.find is not a function
 ❯ src/resolve_references/function_resolution/scope_resolution.test.ts (46 tests | 1 failed) 11ms
   ✓ Scope Walker > resolve_symbol_in_scope_chain > should find symbol in current scope 0ms
   ✓ Scope Walker > resolve_symbol_in_scope_chain > should find symbol in parent scope 0ms
   ✓ Scope Walker > resolve_symbol_in_scope_chain > should respect max depth option 0ms
   ✓ Scope Walker > get_visible_symbols > should collect all symbols visible from a scope 0ms
   ✓ Scope Walker > find_enclosing_scope_of_type > should find nearest enclosing scope of specific type 0ms
   ✓ Scope Walker > find_enclosing_scope_of_type > should return null if no enclosing scope of type exists 0ms
   ✓ Scope Walker > is_scope_descendant > should correctly identify scope descendant relationships 0ms
   ✓ Scope Walker > collect_descendant_scopes > should collect all descendant scopes recursively 0ms
   ✓ Scope Walker > collect_descendant_scopes > should handle scopes with no children 0ms
   ✓ Edge Cases and Error Handling > Circular scope references > should handle circular parent references gracefully 0ms
   ✓ Edge Cases and Error Handling > Empty and null cases > should handle empty scope maps 0ms
   ✓ Edge Cases and Error Handling > Empty and null cases > should handle scopes with no symbols 0ms
   ✓ Edge Cases and Error Handling > Empty and null cases > should handle missing parent scopes 0ms
   ✓ Edge Cases and Error Handling > Boundary conditions > should handle exact boundary matches for location_in_scope 0ms
   ✓ Edge Cases and Error Handling > Boundary conditions > should handle overlapping scopes correctly 0ms
   ✓ Edge Cases and Error Handling > Symbol shadowing > should handle symbol shadowing correctly 0ms
   ✓ Edge Cases and Error Handling > Deep nesting > should handle deeply nested scopes 0ms
   ✓ Hoisting Handler > get_hoisting_rules > should return correct rules for JavaScript 0ms
   ✓ Hoisting Handler > get_hoisting_rules > should return correct rules for Python 0ms
   ✓ Hoisting Handler > get_hoisting_rules > should return correct rules for Rust 0ms
   ✓ Hoisting Handler > resolve_global_symbol > should resolve JavaScript built-in symbols 0ms
   ✓ Hoisting Handler > resolve_global_symbol > should resolve Python built-in symbols 0ms
   ✓ Hoisting Handler > resolve_global_symbol > should resolve Rust macro symbols 0ms
   ✓ Hoisting Handler > resolve_global_symbol > should return null for unknown symbols 0ms
   ✓ Hoisting Handler > resolve_global_symbol > should resolve TypeScript-specific globals 0ms
   ✓ Hoisting Handler > resolve_global_symbol > should resolve Node.js-specific globals 0ms
   ✓ Hoisting Handler > resolve_global_symbol > should resolve browser-specific globals 0ms
   ✓ Hoisting Handler > find_hoisted_symbol_in_scope > should find hoisted function declarations in scope 0ms
   × Hoisting Handler > find_hoisted_symbol_in_scope > should find hoisted var declarations 2ms
     → expected null to be 'var1' // Object.is equality
   ✓ Hoisting Handler > find_hoisted_symbol_in_scope > should not find non-hoisted symbols 0ms
   ✓ Hoisting Handler > find_hoisted_symbol_in_scope > should respect language-specific hoisting rules 0ms
   ✓ Hoisting Handler > hoisting behavior > should handle JavaScript function hoisting 0ms
   ✓ Hoisting Handler > hoisting behavior > should respect temporal dead zone for let/const 0ms
   ✓ Hoisting Handler > hoisting behavior > should handle var declaration hoisting 0ms
   ✓ Scope Utilities > location_in_scope > should correctly determine if location is within scope 0ms
   ✓ Scope Utilities > is_global_scope > should identify global and module scopes 0ms
   ✓ Scope Utilities > get_scope_chain > should return chain from scope to root 0ms
   ✓ Scope Utilities > get_scope_depth > should calculate correct scope depth 0ms
   ✓ Scope Utilities > find_common_ancestor_scope > should find common ancestor of two scopes 0ms
   ✓ Scope Utilities > is_symbol_accessible_from_scope > should determine if symbol is accessible 0ms
   ✓ Scope Utilities > find_containing_function_scope > should find the containing function scope 0ms
   ✓ Scope Utilities > get_function_scopes_in_file > should return all function scopes in a file 0ms
   ✓ Scope Utilities > find_scope_at_location > should find the most specific scope at a location 0ms
   ✓ Scope Utilities > analyze_scopes_at_location > should analyze all scopes at a location 0ms
   ✓ Scope Utilities > analyze_scopes_at_location > should handle location outside all scopes 0ms
   ✓ Scope Utilities > get_symbols_in_scope > should get all symbols in a scope 0ms
 ❯ src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts (12 tests | 12 failed) 12ms
   × Symbol Resolution Fixes - Integration Tests > Import Resolution Fixes > handles imports with proper source field structure 2ms
     → idx.functions is not iterable
   × Symbol Resolution Fixes - Integration Tests > Import Resolution Fixes > handles missing import sources gracefully 0ms
     → idx.functions is not iterable
   × Symbol Resolution Fixes - Integration Tests > Import Resolution Fixes > resolves cross-language imports correctly 1ms
     → idx.functions is not iterable
   × Symbol Resolution Fixes - Integration Tests > Export Structure Fixes > handles named exports with proper structure 1ms
     → idx.functions is not iterable
   × Symbol Resolution Fixes - Integration Tests > Export Structure Fixes > handles default exports correctly 0ms
     → idx.functions is not iterable
   × Symbol Resolution Fixes - Integration Tests > Type Resolution Fixes > handles return type hints correctly 1ms
     → idx.functions is not iterable
   × Symbol Resolution Fixes - Integration Tests > Type Resolution Fixes > handles class inheritance correctly 1ms
     → idx.functions is not iterable
   × Symbol Resolution Fixes - Integration Tests > Performance and Stability > handles moderate-sized projects efficiently 2ms
     → idx.functions is not iterable
   × Symbol Resolution Fixes - Integration Tests > Performance and Stability > handles error conditions gracefully 1ms
     → expected [Function] to not throw an error but 'TypeError: idx.functions is not itera…' was thrown
   × Symbol Resolution Fixes - Integration Tests > Performance and Stability > maintains consistency across multiple runs 1ms
     → idx.functions is not iterable
   × Symbol Resolution Fixes - Integration Tests > Integration Validation > validates all four phases work together 1ms
     → idx.functions is not iterable
   × Symbol Resolution Fixes - Integration Tests > Integration Validation > handles real-world scenarios 0ms
     → idx.functions is not iterable
 ❯ src/resolve_references/symbol_resolution.test.ts (17 tests | 15 failed | 1 skipped) 8ms
   ✓ Symbol Resolution Pipeline > Main Entry Point > should export resolve_symbols function 0ms
   × Symbol Resolution Pipeline > Main Entry Point > should return ResolvedSymbols with all phases 2ms
     → idx.functions is not iterable
   ↓ Symbol Resolution Pipeline > Phase 1: Import/Export Resolution > should resolve named imports
   × Symbol Resolution Pipeline > Phase 1: Import/Export Resolution > should resolve default imports 1ms
     → idx.functions is not iterable
   × Symbol Resolution Pipeline > Phase 1: Import/Export Resolution > should resolve namespace imports 0ms
     → idx.functions is not iterable
   × Symbol Resolution Pipeline > Phase 2: Function Call Resolution > should resolve function calls via lexical scope 1ms
     → idx.functions is not iterable
   × Symbol Resolution Pipeline > Phase 2: Function Call Resolution > should resolve imported function calls 1ms
     → idx.functions is not iterable
   × Symbol Resolution Pipeline > Phase 2: Function Call Resolution > should handle hoisted function declarations 0ms
     → idx.functions is not iterable
   × Symbol Resolution Pipeline > Phase 2: Function Call Resolution > should track unresolved function calls 0ms
     → idx.functions is not iterable
   × Symbol Resolution Pipeline > Phase 3: Type Resolution > should build type registry from local types 0ms
     → idx.functions is not iterable
   × Symbol Resolution Pipeline > Phase 3: Type Resolution > should resolve type inheritance 0ms
     → idx.functions is not iterable
   × Symbol Resolution Pipeline > Phase 3: Type Resolution > should track type flow 0ms
     → idx.functions is not iterable
   × Symbol Resolution Pipeline > Phase 4: Method/Constructor Resolution > should resolve method calls 1ms
     → idx.functions is not iterable
   × Symbol Resolution Pipeline > Phase 4: Method/Constructor Resolution > should resolve constructor calls 0ms
     → idx.functions is not iterable
   × Symbol Resolution Pipeline > Integration Tests > should integrate all four phases 1ms
     → idx.functions is not iterable
   × Symbol Resolution Pipeline > Integration Tests > should track unresolved references 0ms
     → idx.functions is not iterable
   × Symbol Resolution Pipeline > Integration Tests > should build reverse reference mapping 0ms
     → idx.functions is not iterable
 ❯ src/resolve_references/integration_tests/cross_language.test.ts (8 tests | 8 failed) 6ms
   × Cross-Language Symbol Resolution > JavaScript/TypeScript mixed projects > should handle JavaScript and TypeScript interoperability 2ms
     → idx.functions is not iterable
   × Cross-Language Symbol Resolution > JavaScript/TypeScript mixed projects > should handle CommonJS and ES6 module patterns 1ms
     → idx.functions is not iterable
   × Cross-Language Symbol Resolution > Language-specific features > should support all language features independently 1ms
     → idx.functions is not iterable
   × Cross-Language Symbol Resolution > Language-specific features > should handle JavaScript-specific patterns 0ms
     → idx.functions is not iterable
   × Cross-Language Symbol Resolution > Language-specific features > should handle TypeScript-specific patterns 0ms
     → idx.functions is not iterable
   × Cross-Language Symbol Resolution > Language-specific features > should handle Python-specific patterns 0ms
     → idx.functions is not iterable
   × Cross-Language Symbol Resolution > Language-specific features > should handle Rust-specific patterns 0ms
     → idx.functions is not iterable
   × Cross-Language Symbol Resolution > Cross-language import resolution > should resolve imports with language-specific path patterns 1ms
     → idx.functions is not iterable
 ❯ src/index_single_file/definitions/definition_builder.test.ts (9 tests | 9 failed) 6ms
   × DefinitionBuilder - Complex Assembly > should assemble class with multiple methods and properties 2ms
     → expected { functions: Map{}, …(8) } to have property 'length'
   × DefinitionBuilder - Complex Assembly > should assemble class with inheritance chain 0ms
     → Cannot read properties of undefined (reading 'extends')
   × DefinitionBuilder - Complex Assembly > should assemble function with multiple parameters 0ms
     → Cannot read properties of undefined (reading 'signature')
   × DefinitionBuilder - Complex Assembly > should assemble method with decorators 0ms
     → Cannot read properties of undefined (reading 'methods')
   × DefinitionBuilder - Complex Assembly > should assemble interface with method signatures and properties 0ms
     → Cannot read properties of undefined (reading 'extends')
   × DefinitionBuilder - Complex Assembly > should assemble enum with members 0ms
     → Cannot read properties of undefined (reading 'is_const')
   × DefinitionBuilder - Complex Assembly > should assemble namespace with exported symbols 0ms
     → Cannot read properties of undefined (reading 'kind')
   × DefinitionBuilder - Public API > should support all definition types through public API 1ms
     → expected { functions: Map{}, …(8) } to have property 'length'
   × DefinitionBuilder - Public API > should properly chain all builder methods 1ms
     → expected { functions: Map{}, …(8) } to have property 'length'
 ❯ src/trace_call_graph/detect_call_graph.test.ts (13 tests | 12 failed) 4ms
   × detect_call_graph > basic functionality > should detect call graph with single function 1ms
     → line is not defined
   × detect_call_graph > basic functionality > should detect call graph with multiple functions and references 0ms
     → line is not defined
   × detect_call_graph > basic functionality > should handle complex call chains 0ms
     → line is not defined
   ✓ detect_call_graph > edge cases > should handle empty resolved symbols 0ms
   × detect_call_graph > edge cases > should handle functions with no calls 0ms
     → line is not defined
   × detect_call_graph > edge cases > should throw error for missing resolved reference 0ms
     → line is not defined
   × detect_call_graph > edge cases > should handle multiple entry points 0ms
     → line is not defined
   × detect_call_graph > edge cases > should handle recursive function calls 0ms
     → line is not defined
   × detect_call_graph > edge cases > should identify recursive function as entry point when not called externally 0ms
     → line is not defined
   × detect_call_graph > edge cases > should handle mutual recursion 0ms
     → line is not defined
   × detect_call_graph > cross-file scenarios > should handle functions across multiple files 0ms
     → line is not defined
   × detect_call_graph > cross-file scenarios > should correctly identify multiple enclosed calls in same function 0ms
     → line is not defined
   × detect_call_graph > qualified names and namespaces > should handle qualified function names 0ms
     → line is not defined
 ❯ src/resolve_references/integration_tests/end_to_end.test.ts (6 tests | 6 failed) 5ms
   × Complete Symbol Resolution Pipeline > Cross-file function call resolution > should resolve function calls through imports correctly 2ms
     → idx.functions is not iterable
   × Complete Symbol Resolution Pipeline > Method resolution through inheritance > should resolve inherited method calls correctly 1ms
     → idx.functions is not iterable
   × Complete Symbol Resolution Pipeline > Constructor call resolution > should resolve constructor calls with proper type context 1ms
     → idx.functions is not iterable
   × Complete Symbol Resolution Pipeline > Complete pipeline integration > should handle complex multi-file projects with all resolution types 1ms
     → idx.functions is not iterable
   × Complete Symbol Resolution Pipeline > Error handling and edge cases > should handle missing imports gracefully 1ms
     → idx.functions is not iterable
   × Complete Symbol Resolution Pipeline > Error handling and edge cases > should handle circular imports 1ms
     → idx.functions is not iterable
 ❯ src/index_single_file/scopes/scope_processor.test.ts (10 tests | 6 failed) 5ms
   ✓ scope_processor > process_scopes > should create root module scope for empty file 0ms
   × scope_processor > process_scopes > should create function scope nested in module 2ms
     → Cannot read properties of undefined (reading 'file_path')
   × scope_processor > process_scopes > should create nested scopes correctly 0ms
     → Cannot read properties of undefined (reading 'start_line')
   × scope_processor > process_scopes > should handle multiple sibling scopes 0ms
     → Cannot read properties of undefined (reading 'start_line')
   × scope_processor > process_scopes > should handle closures (functions within functions) 0ms
     → Cannot read properties of undefined (reading 'start_line')
   × scope_processor > process_scopes > should handle interface and enum scopes 0ms
     → Cannot read properties of undefined (reading 'start_line')
   ✓ scope_processor > create_processing_context > should compute depths correctly 0ms
   ✓ scope_processor > create_processing_context > should find correct scope for location 0ms
   ✓ scope_processor > create_processing_context > should handle overlapping scopes by choosing deepest 0ms
   × scope_processor > scope types > should handle all scope entity types correctly 0ms
     → Cannot read properties of undefined (reading 'file_path')
 ❯ src/resolve_references/constructor_resolution.test.ts (9 tests | 9 failed) 3ms
   × Constructor Resolution > Cross-file constructor resolution > should resolve constructor calls to imported classes 1ms
     → line is not defined
   × Constructor Resolution > Cross-file constructor resolution > should handle multiple constructor calls to different imported classes 0ms
     → line is not defined
   × Constructor Resolution > Local constructor resolution > should resolve constructor calls to classes in the same file 0ms
     → line is not defined
   × Constructor Resolution > Local constructor resolution > should resolve constructor calls with both local and imported classes (current behavior: imports take priority) 0ms
     → line is not defined
   × Constructor Resolution > Edge cases and error handling > should handle constructor calls to non-existent classes gracefully 0ms
     → line is not defined
   × Constructor Resolution > Edge cases and error handling > should handle imports that don't exist 0ms
     → line is not defined
   × Constructor Resolution > Edge cases and error handling > should handle imported symbols that are not classes 0ms
     → line is not defined
   × Constructor Resolution > Edge cases and error handling > should handle empty constructor calls array 0ms
     → line is not defined
   × Constructor Resolution > Integration with other phases > should work correctly when constructor resolution is part of full pipeline 0ms
     → line is not defined
 ❯ src/resolve_references/function_resolution/function_resolution.updated_example.test.ts (5 tests | 3 failed) 2ms
   × Function Resolution with Mock Factories > Using Individual Mock Factories > should resolve simple function call 1ms
     → (0 , mock_import_resolution_map) is not a function
   × Function Resolution with Mock Factories > Using Pre-built Scenarios > should resolve function call using scenario factory 0ms
     → (0 , mock_import_resolution_map) is not a function
   ✓ Function Resolution with Mock Factories > Comparison: Old vs New Approach > demonstrates ReadonlyMap handling improvement 0ms
   × Function Resolution with Mock Factories > Built-in Function Resolution > should handle built-in functions with mock factories 0ms
     → (0 , mock_import_resolution_map) is not a function
   ✓ Function Resolution with Mock Factories > Benefits Demonstration > shows improved test readability and maintainability 0ms
 ❯ src/resolve_references/method_resolution_simple/heuristic_with_types.test.ts (3 tests | 3 failed) 2ms
   × Heuristic Resolution with Local Type Context > should resolve method using constructor type hint 1ms
     → expected null to be truthy
   × Heuristic Resolution with Local Type Context > should resolve method without type hints using file proximity 0ms
     → expected undefined to be 'method::::::getName' // Object.is equality
   × Heuristic Resolution with Local Type Context > should prioritize type hints over other strategies 0ms
     → expected undefined to be 'method::::::getName' // Object.is equality
 ❯ src/resolve_references/method_resolution_simple/heuristic_resolver_simple.test.ts (2 tests | 2 failed) 1ms
   × Heuristic Method Resolution (Simple) > should resolve unique method names directly 1ms
     → expected undefined to be 'method::::::getName' // Object.is equality
   × Heuristic Method Resolution (Simple) > should return null when multiple methods exist without disambiguation 0ms
     → expected null to be truthy
 ✓ src/index_single_file/semantic_index.typescript.test.ts (25 tests) 4217ms
 ✓ src/index_single_file/semantic_index.rust.test.ts (25 tests) 1716ms
 ✓ src/index_single_file/semantic_index.python.test.ts (28 tests) 1356ms
 ✓ src/resolve_references/method_resolution/method_resolution.test.ts (45 tests) 18ms
 ✓ src/index_single_file/query_code_tree/language_configs/rust_metadata.test.ts (93 tests) 16ms
 ✓ src/index_single_file/query_code_tree/language_configs/javascript_metadata.test.ts (57 tests) 22ms
 ✓ src/index_single_file/query_code_tree/language_configs/python_metadata.test.ts (69 tests) 12ms
 ✓ src/resolve_references/import_resolution/language_handlers/python.test.ts (40 tests) 15ms
 ✓ src/resolve_references/import_resolution/language_handlers/rust.test.ts (47 tests) 14ms
 ✓ src/resolve_references/import_resolution/import_resolution.comprehensive.test.ts (30 tests) 20ms
 ✓ src/resolve_references/import_resolution/language_handlers/integration.test.ts (9 tests) 8ms
 ✓ src/resolve_references/import_resolution/language_handlers/javascript.test.ts (46 tests) 22ms
 ✓ src/resolve_references/type_resolution/type_registry.test.ts (19 tests) 8ms
 ✓ src/index_single_file/references/reference_builder.test.ts (35 tests | 7 skipped) 7ms
 ✓ src/resolve_references/type_resolution/type_registry_interfaces.test.ts (48 tests) 6ms
 ✓ src/resolve_references/type_resolution/resolve_members.test.ts (21 tests) 5ms
stderr | src/resolve_references/type_resolution/inheritance.test.ts > resolve_inheritance > Edge cases > should handle circular inheritance gracefully
Circular inheritance detected for type:class:A:file.ts:1:1

stderr | src/resolve_references/type_resolution/inheritance.test.ts > resolve_inheritance > Advanced inheritance patterns > should handle self-referential inheritance
Circular inheritance detected for type:class:SelfRef:file.ts:1:1

 ✓ src/resolve_references/type_resolution/inheritance.test.ts (17 tests) 6ms
 ✓ src/index_single_file/query_code_tree/language_configs/typescript_builder.test.ts (21 tests) 8ms
 ✓ src/resolve_references/type_resolution/track_types.test.ts (21 tests) 4ms
 ✓ src/resolve_references/test_factories.test.ts (20 tests) 4ms
 ✓ src/resolve_references/function_resolution/function_resolution.test.ts (16 tests) 4ms
stderr | src/resolve_references/type_resolution/type_member_resolution.integration.test.ts > Type Member Resolution Integration > Error handling in integrated pipeline > should handle complex circular inheritance
Circular inheritance detected for type:class:A:test.ts:1:1

 ✓ src/resolve_references/type_resolution/type_member_resolution.integration.test.ts (6 tests) 2ms
 ✓ src/resolve_references/type_resolution/type_flow.test.ts (13 tests) 2ms
 ✓ src/resolve_references/function_resolution/resolution_priority.test.ts (13 tests) 2ms
 ✓ src/resolve_references/method_resolution/static_resolution.test.ts (19 tests) 2ms
 ✓ src/resolve_references/import_resolution/import_resolution.test.ts (10 tests) 2ms
 ✓ src/resolve_references/local_type_context/local_type_context.test.ts (3 tests) 1ms
 ↓ src/resolve_references/type_resolution_consolidated.test.ts (8 tests | 8 skipped)
 ↓ src/index_single_file/query_code_tree/query_loader.test.ts (76 tests | 76 skipped)

⎯⎯⎯⎯⎯⎯ Failed Suites 5 ⎯⎯⎯⎯⎯⎯⎯

 FAIL  src/resolve_references/rust_async_await_integration.test.ts [ src/resolve_references/rust_async_await_integration.test.ts ]
 FAIL  src/resolve_references/type_resolution/type_resolution.comprehensive.test.ts [ src/resolve_references/type_resolution/type_resolution.comprehensive.test.ts ]
 FAIL  src/resolve_references/type_resolution/type_resolution.test.ts [ src/resolve_references/type_resolution/type_resolution.test.ts ]
Error: Cannot find module '../../../index_single_file/capture_types' imported from '/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/type_resolution/rust_types/pattern_matching.ts'
 ❯ src/resolve_references/type_resolution/rust_types/pattern_matching.ts:12:1
     10| import type { TypeResolutionMap } from "../../types";
     11| import type { NormalizedCapture } from "../../../index_single_file/cap…
     12| import {
       | ^
     13|   SemanticEntity,
     14|   SemanticCategory,

Caused by: Error: Failed to load url ../../../index_single_file/capture_types (resolved id: ../../../index_single_file/capture_types) in /Users/chuck/workspace/ariadne/packages/core/src/resolve_references/type_resolution/rust_types/pattern_matching.ts. Does the file exist?
 ❯ loadAndTransform ../../node_modules/vite/dist/node/chunks/dep-BHkUv4Z8.js:26444:33

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[1/123]⎯

 FAIL  src/resolve_references/method_resolution_simple/enhanced_method_resolution.test.ts [ src/resolve_references/method_resolution_simple/enhanced_method_resolution.test.ts ]
Error: Cannot find module '../../index_single_file/scope_tree' imported from '/Users/chuck/workspace/ariadne/packages/core/src/resolve_references/method_resolution_simple/enhanced_heuristic_resolver.ts'
 ❯ src/resolve_references/method_resolution_simple/enhanced_heuristic_resolver.ts:23:1
     21| } from "./enhanced_context";
     22| import { find_variable_type_enhanced } from "./enhanced_context";
     23| import { find_containing_scope } from "../../index_single_file/scope_t…
       | ^
     24| 
     25| /**

Caused by: Error: Failed to load url ../../index_single_file/scope_tree (resolved id: ../../index_single_file/scope_tree) in /Users/chuck/workspace/ariadne/packages/core/src/resolve_references/method_resolution_simple/enhanced_heuristic_resolver.ts. Does the file exist?
 ❯ loadAndTransform ../../node_modules/vite/dist/node/chunks/dep-BHkUv4Z8.js:26444:33

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[2/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/javascript_builder.test.ts [ src/index_single_file/query_code_tree/language_configs/javascript_builder.test.ts ]
Error: Cannot find module '../reference_builder' imported from '/Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/javascript_builder.test.ts'
 ❯ src/index_single_file/query_code_tree/language_configs/javascript_builder.test.ts:16:1
     14| } from "../../scopes/scope_processor";
     15| import type { Location, ScopeId, FilePath, SymbolName } from "@ariadne…
     16| import { ReferenceBuilder } from "../reference_builder";
       | ^
     17| import { JAVASCRIPT_METADATA_EXTRACTORS } from "./javascript_metadata";
     18| 

Caused by: Error: Failed to load url ../reference_builder (resolved id: ../reference_builder) in /Users/chuck/workspace/ariadne/packages/core/src/index_single_file/query_code_tree/language_configs/javascript_builder.test.ts. Does the file exist?
 ❯ loadAndTransform ../../node_modules/vite/dist/node/chunks/dep-BHkUv4Z8.js:26444:33

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[3/123]⎯


⎯⎯⎯⎯⎯⎯ Failed Tests 118 ⎯⎯⎯⎯⎯⎯

 FAIL  src/index_single_file/semantic_index.javascript.test.ts > Semantic Index - JavaScript > JavaScript fixtures > should correctly parse basic_function.js
Error: ENOENT: no such file or directory, open '/Users/chuck/workspace/ariadne/packages/core/tests/fixtures/javascript/basic_function.js'
 ❯ src/index_single_file/semantic_index.javascript.test.ts:52:22
     50|     for (const fixture of javascript_fixtures) {
     51|       it(`should correctly parse ${fixture}`, () => {
     52|         const code = readFileSync(
       |                      ^
     53|           join(FIXTURES_DIR, "javascript", fixture),
     54|           "utf8"

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[4/123]⎯

 FAIL  src/index_single_file/semantic_index.javascript.test.ts > Semantic Index - JavaScript > JavaScript fixtures > should correctly parse class_and_methods.js
Error: ENOENT: no such file or directory, open '/Users/chuck/workspace/ariadne/packages/core/tests/fixtures/javascript/class_and_methods.js'
 ❯ src/index_single_file/semantic_index.javascript.test.ts:52:22
     50|     for (const fixture of javascript_fixtures) {
     51|       it(`should correctly parse ${fixture}`, () => {
     52|         const code = readFileSync(
       |                      ^
     53|           join(FIXTURES_DIR, "javascript", fixture),
     54|           "utf8"

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[5/123]⎯

 FAIL  src/index_single_file/semantic_index.javascript.test.ts > Semantic Index - JavaScript > JavaScript fixtures > should correctly parse imports_exports.js
Error: ENOENT: no such file or directory, open '/Users/chuck/workspace/ariadne/packages/core/tests/fixtures/javascript/imports_exports.js'
 ❯ src/index_single_file/semantic_index.javascript.test.ts:52:22
     50|     for (const fixture of javascript_fixtures) {
     51|       it(`should correctly parse ${fixture}`, () => {
     52|         const code = readFileSync(
       |                      ^
     53|           join(FIXTURES_DIR, "javascript", fixture),
     54|           "utf8"

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[6/123]⎯

 FAIL  src/index_single_file/semantic_index.javascript.test.ts > Semantic Index - JavaScript > JavaScript fixtures > should correctly parse all export types from imports_exports fixture
Error: ENOENT: no such file or directory, open '/Users/chuck/workspace/ariadne/packages/core/tests/fixtures/javascript/imports_exports.js'
 ❯ src/index_single_file/semantic_index.javascript.test.ts:156:20
    154|     it("should correctly parse all export types from imports_exports f…
    155|       const { build_semantic_index } = await import("./semantic_index"…
    156|       const code = readFileSync(
       |                    ^
    157|         join(FIXTURES_DIR, "javascript", "imports_exports.js"),
    158|         "utf8"

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[7/123]⎯

 FAIL  src/resolve_references/constructor_resolution.test.ts > Constructor Resolution > Cross-file constructor resolution > should resolve constructor calls to imported classes
ReferenceError: line is not defined
 ❯ create_location src/resolve_references/constructor_resolution.test.ts:34:17
     32|   return {
     33|     file_path,
     34|     start_line: line,
       |                 ^
     35|     start_column: column,
     36|     end_line: line,
 ❯ src/resolve_references/constructor_resolution.test.ts:98:33

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[8/123]⎯

 FAIL  src/resolve_references/constructor_resolution.test.ts > Constructor Resolution > Cross-file constructor resolution > should handle multiple constructor calls to different imported classes
ReferenceError: line is not defined
 ❯ create_location src/resolve_references/constructor_resolution.test.ts:34:17
     32|   return {
     33|     file_path,
     34|     start_line: line,
       |                 ^
     35|     start_column: column,
     36|     end_line: line,
 ❯ src/resolve_references/constructor_resolution.test.ts:200:31

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[9/123]⎯

 FAIL  src/resolve_references/constructor_resolution.test.ts > Constructor Resolution > Local constructor resolution > should resolve constructor calls to classes in the same file
ReferenceError: line is not defined
 ❯ create_location src/resolve_references/constructor_resolution.test.ts:34:17
     32|   return {
     33|     file_path,
     34|     start_line: line,
       |                 ^
     35|     start_column: column,
     36|     end_line: line,
 ❯ src/resolve_references/constructor_resolution.test.ts:350:30

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[10/123]⎯

 FAIL  src/resolve_references/constructor_resolution.test.ts > Constructor Resolution > Local constructor resolution > should resolve constructor calls with both local and imported classes (current behavior: imports take priority)
ReferenceError: line is not defined
 ❯ create_location src/resolve_references/constructor_resolution.test.ts:34:17
     32|   return {
     33|     file_path,
     34|     start_line: line,
       |                 ^
     35|     start_column: column,
     36|     end_line: line,
 ❯ src/resolve_references/constructor_resolution.test.ts:406:39

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[11/123]⎯

 FAIL  src/resolve_references/constructor_resolution.test.ts > Constructor Resolution > Edge cases and error handling > should handle constructor calls to non-existent classes gracefully
ReferenceError: line is not defined
 ❯ create_location src/resolve_references/constructor_resolution.test.ts:34:17
     32|   return {
     33|     file_path,
     34|     start_line: line,
       |                 ^
     35|     start_column: column,
     36|     end_line: line,
 ❯ src/resolve_references/constructor_resolution.test.ts:512:41

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[12/123]⎯

 FAIL  src/resolve_references/constructor_resolution.test.ts > Constructor Resolution > Edge cases and error handling > should handle imports that don't exist
ReferenceError: line is not defined
 ❯ create_location src/resolve_references/constructor_resolution.test.ts:34:17
     32|   return {
     33|     file_path,
     34|     start_line: line,
       |                 ^
     35|     start_column: column,
     36|     end_line: line,
 ❯ src/resolve_references/constructor_resolution.test.ts:545:41

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[13/123]⎯

 FAIL  src/resolve_references/constructor_resolution.test.ts > Constructor Resolution > Edge cases and error handling > should handle imported symbols that are not classes
ReferenceError: line is not defined
 ❯ create_location src/resolve_references/constructor_resolution.test.ts:34:17
     32|   return {
     33|     file_path,
     34|     start_line: line,
       |                 ^
     35|     start_column: column,
     36|     end_line: line,
 ❯ src/resolve_references/constructor_resolution.test.ts:592:29

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[14/123]⎯

 FAIL  src/resolve_references/constructor_resolution.test.ts > Constructor Resolution > Edge cases and error handling > should handle empty constructor calls array
ReferenceError: line is not defined
 ❯ create_location src/resolve_references/constructor_resolution.test.ts:34:17
     32|   return {
     33|     file_path,
     34|     start_line: line,
       |                 ^
     35|     start_column: column,
     36|     end_line: line,
 ❯ create_test_index src/resolve_references/constructor_resolution.test.ts:56:15
 ❯ src/resolve_references/constructor_resolution.test.ts:673:21

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[15/123]⎯

 FAIL  src/resolve_references/constructor_resolution.test.ts > Constructor Resolution > Integration with other phases > should work correctly when constructor resolution is part of full pipeline
ReferenceError: line is not defined
 ❯ create_location src/resolve_references/constructor_resolution.test.ts:34:17
     32|   return {
     33|     file_path,
     34|     start_line: line,
       |                 ^
     35|     start_column: column,
     36|     end_line: line,
 ❯ src/resolve_references/constructor_resolution.test.ts:696:30

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[16/123]⎯

 FAIL  src/resolve_references/symbol_resolution.test.ts > Symbol Resolution Pipeline > Main Entry Point > should return ResolvedSymbols with all phases
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/symbol_resolution.test.ts:141:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[17/123]⎯

 FAIL  src/resolve_references/symbol_resolution.test.ts > Symbol Resolution Pipeline > Phase 1: Import/Export Resolution > should resolve default imports
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/symbol_resolution.test.ts:268:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[18/123]⎯

 FAIL  src/resolve_references/symbol_resolution.test.ts > Symbol Resolution Pipeline > Phase 1: Import/Export Resolution > should resolve namespace imports
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/symbol_resolution.test.ts:319:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[19/123]⎯

 FAIL  src/resolve_references/symbol_resolution.test.ts > Symbol Resolution Pipeline > Phase 2: Function Call Resolution > should resolve function calls via lexical scope
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/symbol_resolution.test.ts:361:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[20/123]⎯

 FAIL  src/resolve_references/symbol_resolution.test.ts > Symbol Resolution Pipeline > Phase 2: Function Call Resolution > should resolve imported function calls
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/symbol_resolution.test.ts:440:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[21/123]⎯

 FAIL  src/resolve_references/symbol_resolution.test.ts > Symbol Resolution Pipeline > Phase 2: Function Call Resolution > should handle hoisted function declarations
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/symbol_resolution.test.ts:482:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[22/123]⎯

 FAIL  src/resolve_references/symbol_resolution.test.ts > Symbol Resolution Pipeline > Phase 2: Function Call Resolution > should track unresolved function calls
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/symbol_resolution.test.ts:500:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[23/123]⎯

 FAIL  src/resolve_references/symbol_resolution.test.ts > Symbol Resolution Pipeline > Phase 3: Type Resolution > should build type registry from local types
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/symbol_resolution.test.ts:529:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[24/123]⎯

 FAIL  src/resolve_references/symbol_resolution.test.ts > Symbol Resolution Pipeline > Phase 3: Type Resolution > should resolve type inheritance
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/symbol_resolution.test.ts:560:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[25/123]⎯

 FAIL  src/resolve_references/symbol_resolution.test.ts > Symbol Resolution Pipeline > Phase 3: Type Resolution > should track type flow
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/symbol_resolution.test.ts:600:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[26/123]⎯

 FAIL  src/resolve_references/symbol_resolution.test.ts > Symbol Resolution Pipeline > Phase 4: Method/Constructor Resolution > should resolve method calls
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/symbol_resolution.test.ts:662:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[27/123]⎯

 FAIL  src/resolve_references/symbol_resolution.test.ts > Symbol Resolution Pipeline > Phase 4: Method/Constructor Resolution > should resolve constructor calls
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/symbol_resolution.test.ts:705:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[28/123]⎯

 FAIL  src/resolve_references/symbol_resolution.test.ts > Symbol Resolution Pipeline > Integration Tests > should integrate all four phases
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/symbol_resolution.test.ts:838:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[29/123]⎯

 FAIL  src/resolve_references/symbol_resolution.test.ts > Symbol Resolution Pipeline > Integration Tests > should track unresolved references
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/symbol_resolution.test.ts:862:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[30/123]⎯

 FAIL  src/resolve_references/symbol_resolution.test.ts > Symbol Resolution Pipeline > Integration Tests > should build reverse reference mapping
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/symbol_resolution.test.ts:910:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[31/123]⎯

 FAIL  src/trace_call_graph/detect_call_graph.test.ts > detect_call_graph > basic functionality > should detect call graph with single function
ReferenceError: line is not defined
 ❯ create_location src/trace_call_graph/detect_call_graph.test.ts:28:17
     26|   ): Location => ({
     27|     file_path: file as FilePath,
     28|     start_line: line,
       |                 ^
     29|     start_column: column,
     30|     end_line: line,
 ❯ src/trace_call_graph/detect_call_graph.test.ts:62:28

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[32/123]⎯

 FAIL  src/trace_call_graph/detect_call_graph.test.ts > detect_call_graph > basic functionality > should detect call graph with multiple functions and references
ReferenceError: line is not defined
 ❯ create_location src/trace_call_graph/detect_call_graph.test.ts:28:17
     26|   ): Location => ({
     27|     file_path: file as FilePath,
     28|     start_line: line,
       |                 ^
     29|     start_column: column,
     30|     end_line: line,
 ❯ src/trace_call_graph/detect_call_graph.test.ts:87:29

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[33/123]⎯

 FAIL  src/trace_call_graph/detect_call_graph.test.ts > detect_call_graph > basic functionality > should handle complex call chains
ReferenceError: line is not defined
 ❯ create_location src/trace_call_graph/detect_call_graph.test.ts:28:17
     26|   ): Location => ({
     27|     file_path: file as FilePath,
     28|     start_line: line,
       |                 ^
     29|     start_column: column,
     30|     end_line: line,
 ❯ src/trace_call_graph/detect_call_graph.test.ts:135:28

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[34/123]⎯

 FAIL  src/trace_call_graph/detect_call_graph.test.ts > detect_call_graph > edge cases > should handle functions with no calls
ReferenceError: line is not defined
 ❯ create_location src/trace_call_graph/detect_call_graph.test.ts:28:17
     26|   ): Location => ({
     27|     file_path: file as FilePath,
     28|     start_line: line,
       |                 ^
     29|     start_column: column,
     30|     end_line: line,
 ❯ src/trace_call_graph/detect_call_graph.test.ts:220:29

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[35/123]⎯

 FAIL  src/trace_call_graph/detect_call_graph.test.ts > detect_call_graph > edge cases > should throw error for missing resolved reference
ReferenceError: line is not defined
 ❯ create_location src/trace_call_graph/detect_call_graph.test.ts:28:17
     26|   ): Location => ({
     27|     file_path: file as FilePath,
     28|     start_line: line,
       |                 ^
     29|     start_column: column,
     30|     end_line: line,
 ❯ src/trace_call_graph/detect_call_graph.test.ts:243:28

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[36/123]⎯

 FAIL  src/trace_call_graph/detect_call_graph.test.ts > detect_call_graph > edge cases > should handle multiple entry points
ReferenceError: line is not defined
 ❯ create_location src/trace_call_graph/detect_call_graph.test.ts:28:17
     26|   ): Location => ({
     27|     file_path: file as FilePath,
     28|     start_line: line,
       |                 ^
     29|     start_column: column,
     30|     end_line: line,
 ❯ src/trace_call_graph/detect_call_graph.test.ts:266:28

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[37/123]⎯

 FAIL  src/trace_call_graph/detect_call_graph.test.ts > detect_call_graph > edge cases > should handle recursive function calls
ReferenceError: line is not defined
 ❯ create_location src/trace_call_graph/detect_call_graph.test.ts:28:17
     26|   ): Location => ({
     27|     file_path: file as FilePath,
     28|     start_line: line,
       |                 ^
     29|     start_column: column,
     30|     end_line: line,
 ❯ src/trace_call_graph/detect_call_graph.test.ts:301:33

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[38/123]⎯

 FAIL  src/trace_call_graph/detect_call_graph.test.ts > detect_call_graph > edge cases > should identify recursive function as entry point when not called externally
ReferenceError: line is not defined
 ❯ create_location src/trace_call_graph/detect_call_graph.test.ts:28:17
     26|   ): Location => ({
     27|     file_path: file as FilePath,
     28|     start_line: line,
       |                 ^
     29|     start_column: column,
     30|     end_line: line,
 ❯ src/trace_call_graph/detect_call_graph.test.ts:339:28

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[39/123]⎯

 FAIL  src/trace_call_graph/detect_call_graph.test.ts > detect_call_graph > edge cases > should handle mutual recursion
ReferenceError: line is not defined
 ❯ create_location src/trace_call_graph/detect_call_graph.test.ts:28:17
     26|   ): Location => ({
     27|     file_path: file as FilePath,
     28|     start_line: line,
       |                 ^
     29|     start_column: column,
     30|     end_line: line,
 ❯ src/trace_call_graph/detect_call_graph.test.ts:386:29

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[40/123]⎯

 FAIL  src/trace_call_graph/detect_call_graph.test.ts > detect_call_graph > cross-file scenarios > should handle functions across multiple files
ReferenceError: line is not defined
 ❯ create_location src/trace_call_graph/detect_call_graph.test.ts:28:17
     26|   ): Location => ({
     27|     file_path: file as FilePath,
     28|     start_line: line,
       |                 ^
     29|     start_column: column,
     30|     end_line: line,
 ❯ src/trace_call_graph/detect_call_graph.test.ts:438:32

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[41/123]⎯

 FAIL  src/trace_call_graph/detect_call_graph.test.ts > detect_call_graph > cross-file scenarios > should correctly identify multiple enclosed calls in same function
ReferenceError: line is not defined
 ❯ create_location src/trace_call_graph/detect_call_graph.test.ts:28:17
     26|   ): Location => ({
     27|     file_path: file as FilePath,
     28|     start_line: line,
       |                 ^
     29|     start_column: column,
     30|     end_line: line,
 ❯ src/trace_call_graph/detect_call_graph.test.ts:507:28

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[42/123]⎯

 FAIL  src/trace_call_graph/detect_call_graph.test.ts > detect_call_graph > qualified names and namespaces > should handle qualified function names
ReferenceError: line is not defined
 ❯ create_location src/trace_call_graph/detect_call_graph.test.ts:28:17
     26|   ): Location => ({
     27|     file_path: file as FilePath,
     28|     start_line: line,
       |                 ^
     29|     start_column: column,
     30|     end_line: line,
 ❯ src/trace_call_graph/detect_call_graph.test.ts:546:30

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[43/123]⎯

 FAIL  src/index_single_file/definitions/definition_builder.test.ts > DefinitionBuilder - Complex Assembly > should assemble class with multiple methods and properties
AssertionError: expected { functions: Map{}, …(8) } to have property 'length'
 ❯ src/index_single_file/definitions/definition_builder.test.ts:149:25
    147| 
    148|     const definitions = builder.build();
    149|     expect(definitions).toHaveLength(1);
       |                         ^
    150| 
    151|     const class_def = definitions[0] as ClassDefinition;

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[44/123]⎯

 FAIL  src/index_single_file/definitions/definition_builder.test.ts > DefinitionBuilder - Complex Assembly > should assemble class with inheritance chain
TypeError: Cannot read properties of undefined (reading 'extends')
 ❯ src/index_single_file/definitions/definition_builder.test.ts:179:22
    177|     const class_def = definitions[0] as ClassDefinition;
    178| 
    179|     expect(class_def.extends).toEqual(["ParentClass"]);
       |                      ^
    180|   });
    181| 

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[45/123]⎯

 FAIL  src/index_single_file/definitions/definition_builder.test.ts > DefinitionBuilder - Complex Assembly > should assemble function with multiple parameters
TypeError: Cannot read properties of undefined (reading 'signature')
 ❯ src/index_single_file/definitions/definition_builder.test.ts:228:21
    226|     const func_def = definitions[0] as FunctionDefinition;
    227| 
    228|     expect(func_def.signature.parameters).toHaveLength(3);
       |                     ^
    229| 
    230|     const param1 = func_def.signature.parameters[0];

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[46/123]⎯

 FAIL  src/index_single_file/definitions/definition_builder.test.ts > DefinitionBuilder - Complex Assembly > should assemble method with decorators
TypeError: Cannot read properties of undefined (reading 'methods')
 ❯ src/index_single_file/definitions/definition_builder.test.ts:277:30
    275|     const definitions = builder.build();
    276|     const class_def = definitions[0] as ClassDefinition;
    277|     const method = class_def.methods[0];
       |                              ^
    278| 
    279|     expect(method.decorators).toHaveLength(2);

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[47/123]⎯

 FAIL  src/index_single_file/definitions/definition_builder.test.ts > DefinitionBuilder - Complex Assembly > should assemble interface with method signatures and properties
TypeError: Cannot read properties of undefined (reading 'extends')
 ❯ src/index_single_file/definitions/definition_builder.test.ts:322:26
    320|     const interface_def = definitions[0] as InterfaceDefinition;
    321| 
    322|     expect(interface_def.extends).toEqual(["IBase"]);
       |                          ^
    323|     expect(interface_def.methods).toHaveLength(1);
    324|     expect(interface_def.properties).toHaveLength(1);

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[48/123]⎯

 FAIL  src/index_single_file/definitions/definition_builder.test.ts > DefinitionBuilder - Complex Assembly > should assemble enum with members
TypeError: Cannot read properties of undefined (reading 'is_const')
 ❯ src/index_single_file/definitions/definition_builder.test.ts:367:21
    365|     const enum_def = definitions[0] as EnumDefinition;
    366| 
    367|     expect(enum_def.is_const).toBe(true);
       |                     ^
    368|     expect(enum_def.members).toHaveLength(3);
    369|     expect(enum_def.members[0].value).toBe(1);

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[49/123]⎯

 FAIL  src/index_single_file/definitions/definition_builder.test.ts > DefinitionBuilder - Complex Assembly > should assemble namespace with exported symbols
TypeError: Cannot read properties of undefined (reading 'kind')
 ❯ src/index_single_file/definitions/definition_builder.test.ts:391:26
    389|     const namespace_def = definitions[0] as NamespaceDefinition;
    390| 
    391|     expect(namespace_def.kind).toBe("namespace");
       |                          ^
    392|     expect(namespace_def.name).toBe("MyNamespace");
    393|   });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[50/123]⎯

 FAIL  src/index_single_file/definitions/definition_builder.test.ts > DefinitionBuilder - Public API > should support all definition types through public API
AssertionError: expected { functions: Map{}, …(8) } to have property 'length'
 ❯ src/index_single_file/definitions/definition_builder.test.ts:475:25
    473| 
    474|     const definitions = builder.build();
    475|     expect(definitions).toHaveLength(8);
       |                         ^
    476| 
    477|     const kinds = definitions.map((d) => d.kind).sort();

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[51/123]⎯

 FAIL  src/index_single_file/definitions/definition_builder.test.ts > DefinitionBuilder - Public API > should properly chain all builder methods
AssertionError: expected { functions: Map{}, …(8) } to have property 'length'
 ❯ src/index_single_file/definitions/definition_builder.test.ts:535:25
    533| 
    534|     const definitions = builder.build();
    535|     expect(definitions).toHaveLength(1);
       |                         ^
    536| 
    537|     const class_def = definitions[0] as ClassDefinition;

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[52/123]⎯

 FAIL  src/index_single_file/scopes/scope_processor.test.ts > scope_processor > process_scopes > should create function scope nested in module
TypeError: Cannot read properties of undefined (reading 'file_path')
 ❯ scope_string ../types/src/scopes.ts:109:20
 ❯ create_scope_id src/index_single_file/scopes/scope_processor.ts:309:10
    307|  */
    308| function create_scope_id(type: ScopeType, location: Location): ScopeId…
    309|   return scope_string({ type, location });
       |          ^
    310| }
    311| 
 ❯ process_scopes src/index_single_file/scopes/scope_processor.ts:173:22
 ❯ src/index_single_file/scopes/scope_processor.test.ts:78:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[53/123]⎯

 FAIL  src/index_single_file/scopes/scope_processor.test.ts > scope_processor > process_scopes > should create nested scopes correctly
TypeError: Cannot read properties of undefined (reading 'start_line')
 ❯ compare_locations src/index_single_file/scopes/scope_processor.ts:340:9
    338|  */
    339| function compare_locations(a: Location, b: Location): number {
    340|   if (a.start_line !== b.start_line) return a.start_line - b.start_lin…
       |         ^
    341|   if (a.start_column !== b.start_column) return a.start_column - b.sta…
    342|   if (a.end_line !== b.end_line) return a.end_line - b.end_line;
 ❯ src/index_single_file/scopes/scope_processor.ts:160:5
 ❯ process_scopes src/index_single_file/scopes/scope_processor.ts:159:41
 ❯ src/index_single_file/scopes/scope_processor.test.ts:140:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[54/123]⎯

 FAIL  src/index_single_file/scopes/scope_processor.test.ts > scope_processor > process_scopes > should handle multiple sibling scopes
TypeError: Cannot read properties of undefined (reading 'start_line')
 ❯ compare_locations src/index_single_file/scopes/scope_processor.ts:340:9
    338|  */
    339| function compare_locations(a: Location, b: Location): number {
    340|   if (a.start_line !== b.start_line) return a.start_line - b.start_lin…
       |         ^
    341|   if (a.start_column !== b.start_column) return a.start_column - b.sta…
    342|   if (a.end_line !== b.end_line) return a.end_line - b.end_line;
 ❯ src/index_single_file/scopes/scope_processor.ts:160:5
 ❯ process_scopes src/index_single_file/scopes/scope_processor.ts:159:41
 ❯ src/index_single_file/scopes/scope_processor.test.ts:211:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[55/123]⎯

 FAIL  src/index_single_file/scopes/scope_processor.test.ts > scope_processor > process_scopes > should handle closures (functions within functions)
TypeError: Cannot read properties of undefined (reading 'start_line')
 ❯ compare_locations src/index_single_file/scopes/scope_processor.ts:340:9
    338|  */
    339| function compare_locations(a: Location, b: Location): number {
    340|   if (a.start_line !== b.start_line) return a.start_line - b.start_lin…
       |         ^
    341|   if (a.start_column !== b.start_column) return a.start_column - b.sta…
    342|   if (a.end_line !== b.end_line) return a.end_line - b.end_line;
 ❯ src/index_single_file/scopes/scope_processor.ts:160:5
 ❯ process_scopes src/index_single_file/scopes/scope_processor.ts:159:41
 ❯ src/index_single_file/scopes/scope_processor.test.ts:260:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[56/123]⎯

 FAIL  src/index_single_file/scopes/scope_processor.test.ts > scope_processor > process_scopes > should handle interface and enum scopes
TypeError: Cannot read properties of undefined (reading 'start_line')
 ❯ compare_locations src/index_single_file/scopes/scope_processor.ts:340:9
    338|  */
    339| function compare_locations(a: Location, b: Location): number {
    340|   if (a.start_line !== b.start_line) return a.start_line - b.start_lin…
       |         ^
    341|   if (a.start_column !== b.start_column) return a.start_column - b.sta…
    342|   if (a.end_line !== b.end_line) return a.end_line - b.end_line;
 ❯ src/index_single_file/scopes/scope_processor.ts:160:5
 ❯ process_scopes src/index_single_file/scopes/scope_processor.ts:159:41
 ❯ src/index_single_file/scopes/scope_processor.test.ts:305:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[57/123]⎯

 FAIL  src/index_single_file/scopes/scope_processor.test.ts > scope_processor > scope types > should handle all scope entity types correctly
TypeError: Cannot read properties of undefined (reading 'file_path')
 ❯ scope_string ../types/src/scopes.ts:109:20
 ❯ create_scope_id src/index_single_file/scopes/scope_processor.ts:309:10
    307|  */
    308| function create_scope_id(type: ScopeType, location: Location): ScopeId…
    309|   return scope_string({ type, location });
       |          ^
    310| }
    311| 
 ❯ process_scopes src/index_single_file/scopes/scope_processor.ts:173:22
 ❯ src/index_single_file/scopes/scope_processor.test.ts:606:24
 ❯ src/index_single_file/scopes/scope_processor.test.ts:590:18

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[58/123]⎯

 FAIL  src/resolve_references/function_resolution/function_resolution.updated_example.test.ts > Function Resolution with Mock Factories > Using Individual Mock Factories > should resolve simple function call
TypeError: (0 , mock_import_resolution_map) is not a function
 ❯ src/resolve_references/function_resolution/function_resolution.updated_example.test.ts:86:26
     84| 
     85|       // Create import resolution map using factory
     86|       const import_map = mock_import_resolution_map();
       |                          ^
     87| 
     88|       // Test the function resolution

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[59/123]⎯

 FAIL  src/resolve_references/function_resolution/function_resolution.updated_example.test.ts > Function Resolution with Mock Factories > Using Pre-built Scenarios > should resolve function call using scenario factory
TypeError: (0 , mock_import_resolution_map) is not a function
 ❯ src/resolve_references/function_resolution/function_resolution.updated_example.test.ts:114:26
    112|       };
    113| 
    114|       const import_map = mock_import_resolution_map();
       |                          ^
    115| 
    116|       // Test function resolution

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[60/123]⎯

 FAIL  src/resolve_references/function_resolution/function_resolution.updated_example.test.ts > Function Resolution with Mock Factories > Built-in Function Resolution > should handle built-in functions with mock factories
TypeError: (0 , mock_import_resolution_map) is not a function
 ❯ src/resolve_references/function_resolution/function_resolution.updated_example.test.ts:194:26
    192|       });
    193| 
    194|       const import_map = mock_import_resolution_map();
       |                          ^
    195| 
    196|       const result = resolve_function_calls(

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[61/123]⎯

 FAIL  src/resolve_references/function_resolution/scope_resolution.test.ts > Hoisting Handler > find_hoisted_symbol_in_scope > should find hoisted var declarations
AssertionError: expected null to be 'var1' // Object.is equality

[32m- Expected:[39m 
"var1"

[31m+ Received:[39m 
null

 ❯ src/resolve_references/function_resolution/scope_resolution.test.ts:882:22
    880|       );
    881| 
    882|       expect(result).toBe("var1");
       |                      ^
    883|     });
    884| 

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[62/123]⎯

 FAIL  src/resolve_references/integration_tests/cross_language.test.ts > Cross-Language Symbol Resolution > JavaScript/TypeScript mixed projects > should handle JavaScript and TypeScript interoperability
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/cross_language.test.ts:441:32

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[63/123]⎯

 FAIL  src/resolve_references/integration_tests/cross_language.test.ts > Cross-Language Symbol Resolution > JavaScript/TypeScript mixed projects > should handle CommonJS and ES6 module patterns
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/cross_language.test.ts:497:32

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[64/123]⎯

 FAIL  src/resolve_references/integration_tests/cross_language.test.ts > Cross-Language Symbol Resolution > Language-specific features > should support all language features independently
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/cross_language.test.ts:517:34

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[65/123]⎯

 FAIL  src/resolve_references/integration_tests/cross_language.test.ts > Cross-Language Symbol Resolution > Language-specific features > should handle JavaScript-specific patterns
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/cross_language.test.ts:561:32

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[66/123]⎯

 FAIL  src/resolve_references/integration_tests/cross_language.test.ts > Cross-Language Symbol Resolution > Language-specific features > should handle TypeScript-specific patterns
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/cross_language.test.ts:702:32

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[67/123]⎯

 FAIL  src/resolve_references/integration_tests/cross_language.test.ts > Cross-Language Symbol Resolution > Language-specific features > should handle Python-specific patterns
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/cross_language.test.ts:733:32

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[68/123]⎯

 FAIL  src/resolve_references/integration_tests/cross_language.test.ts > Cross-Language Symbol Resolution > Language-specific features > should handle Rust-specific patterns
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/cross_language.test.ts:757:32

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[69/123]⎯

 FAIL  src/resolve_references/integration_tests/cross_language.test.ts > Cross-Language Symbol Resolution > Cross-language import resolution > should resolve imports with language-specific path patterns
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/cross_language.test.ts:807:32

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[70/123]⎯

 FAIL  src/resolve_references/integration_tests/end_to_end.test.ts > Complete Symbol Resolution Pipeline > Cross-file function call resolution > should resolve function calls through imports correctly
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/end_to_end.test.ts:254:32

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[71/123]⎯

 FAIL  src/resolve_references/integration_tests/end_to_end.test.ts > Complete Symbol Resolution Pipeline > Method resolution through inheritance > should resolve inherited method calls correctly
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/end_to_end.test.ts:413:32

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[72/123]⎯

 FAIL  src/resolve_references/integration_tests/end_to_end.test.ts > Complete Symbol Resolution Pipeline > Constructor call resolution > should resolve constructor calls with proper type context
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/end_to_end.test.ts:512:32

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[73/123]⎯

 FAIL  src/resolve_references/integration_tests/end_to_end.test.ts > Complete Symbol Resolution Pipeline > Complete pipeline integration > should handle complex multi-file projects with all resolution types
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/end_to_end.test.ts:728:32

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[74/123]⎯

 FAIL  src/resolve_references/integration_tests/end_to_end.test.ts > Complete Symbol Resolution Pipeline > Error handling and edge cases > should handle missing imports gracefully
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/end_to_end.test.ts:789:32

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[75/123]⎯

 FAIL  src/resolve_references/integration_tests/end_to_end.test.ts > Complete Symbol Resolution Pipeline > Error handling and edge cases > should handle circular imports
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/end_to_end.test.ts:886:32

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[76/123]⎯

 FAIL  src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts > Symbol Resolution Fixes - Integration Tests > Import Resolution Fixes > handles imports with proper source field structure
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts:63:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[77/123]⎯

 FAIL  src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts > Symbol Resolution Fixes - Integration Tests > Import Resolution Fixes > handles missing import sources gracefully
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts:106:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[78/123]⎯

 FAIL  src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts > Symbol Resolution Fixes - Integration Tests > Import Resolution Fixes > resolves cross-language imports correctly
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts:139:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[79/123]⎯

 FAIL  src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts > Symbol Resolution Fixes - Integration Tests > Export Structure Fixes > handles named exports with proper structure
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts:186:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[80/123]⎯

 FAIL  src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts > Symbol Resolution Fixes - Integration Tests > Export Structure Fixes > handles default exports correctly
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts:207:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[81/123]⎯

 FAIL  src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts > Symbol Resolution Fixes - Integration Tests > Type Resolution Fixes > handles return type hints correctly
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts:231:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[82/123]⎯

 FAIL  src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts > Symbol Resolution Fixes - Integration Tests > Type Resolution Fixes > handles class inheritance correctly
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts:268:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[83/123]⎯

 FAIL  src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts > Symbol Resolution Fixes - Integration Tests > Performance and Stability > handles moderate-sized projects efficiently
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts:290:15
 ❯ time_execution src/resolve_references/test_utilities.ts:772:18
 ❯ src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts:289:65

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[84/123]⎯

 FAIL  src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts > Symbol Resolution Fixes - Integration Tests > Performance and Stability > handles error conditions gracefully
AssertionError: expected [Function] to not throw an error but 'TypeError: idx.functions is not itera…' was thrown

[32m- Expected:[39m 
undefined

[31m+ Received:[39m 
"TypeError: idx.functions is not iterable"

 ❯ src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts:337:14
    335|         const result = resolve_symbols({ indices });
    336|         expect(result).toBeDefined();
    337|       }).not.toThrow();
       |              ^
    338|     });
    339| 

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[85/123]⎯

 FAIL  src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts > Symbol Resolution Fixes - Integration Tests > Performance and Stability > maintains consistency across multiple runs
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts:344:23

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[86/123]⎯

 FAIL  src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts > Symbol Resolution Fixes - Integration Tests > Integration Validation > validates all four phases work together
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts:368:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[87/123]⎯

 FAIL  src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts > Symbol Resolution Fixes - Integration Tests > Integration Validation > handles real-world scenarios
TypeError: idx.functions is not iterable
 ❯ combine_results src/resolve_references/symbol_resolution.ts:181:34
    179|   for (const idx of indices.values()) {
    180|     // Collect all definition types from AnyDefinition union
    181|     for (const [id, func] of idx.functions) {
       |                                  ^
    182|       callable_definitions.set(id, func);
    183|     }
 ❯ resolve_symbols src/resolve_references/symbol_resolution.ts:135:10
 ❯ src/resolve_references/integration_tests/symbol_resolution_fixes.test.ts:435:22

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[88/123]⎯

 FAIL  src/resolve_references/method_resolution_simple/heuristic_resolver_simple.test.ts > Heuristic Method Resolution (Simple) > should resolve unique method names directly
AssertionError: expected undefined to be 'method::::::getName' // Object.is equality

[32m- Expected:[39m 
"method::::::getName"

[31m+ Received:[39m 
undefined

 ❯ src/resolve_references/method_resolution_simple/heuristic_resolver_simple.test.ts:95:31
     93| 
     94|     expect(result).toBeTruthy();
     95|     expect(result?.method_id).toBe(get_name_method);
       |                               ^
     96|     expect(result?.class_id).toBe(user_class);
     97|     expect(result?.strategy).toBe(ResolutionStrategy.UNIQUE_METHOD);

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[89/123]⎯

 FAIL  src/resolve_references/method_resolution_simple/heuristic_resolver_simple.test.ts > Heuristic Method Resolution (Simple) > should return null when multiple methods exist without disambiguation
AssertionError: expected null to be truthy

[32m- Expected:[39m 
true

[31m+ Received:[39m 
null

 ❯ src/resolve_references/method_resolution_simple/heuristic_resolver_simple.test.ts:195:20
    193|     // Since both are in the same file, it will return one of them
    194|     // (in practice, this would need more context to disambiguate)
    195|     expect(result).toBeTruthy();
       |                    ^
    196|     expect([get_name_method, admin_get_name]).toContain(result?.method…
    197|   });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[90/123]⎯

 FAIL  src/resolve_references/method_resolution_simple/heuristic_with_types.test.ts > Heuristic Resolution with Local Type Context > should resolve method using constructor type hint
AssertionError: expected null to be truthy

[32m- Expected:[39m 
true

[31m+ Received:[39m 
null

 ❯ src/resolve_references/method_resolution_simple/heuristic_with_types.test.ts:139:20
    137| 
    138|     // Should resolve to User.getName, not Admin.getName
    139|     expect(result).toBeTruthy();
       |                    ^
    140|     expect(result?.method_id).toBe(user_get_name);
    141|     expect(result?.class_id).toBe(user_class);

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[91/123]⎯

 FAIL  src/resolve_references/method_resolution_simple/heuristic_with_types.test.ts > Heuristic Resolution with Local Type Context > should resolve method without type hints using file proximity
AssertionError: expected undefined to be 'method::::::getName' // Object.is equality

[32m- Expected:[39m 
"method::::::getName"

[31m+ Received:[39m 
undefined

 ❯ src/resolve_references/method_resolution_simple/heuristic_with_types.test.ts:207:31
    205|     // Should resolve using unique method strategy
    206|     expect(result).toBeTruthy();
    207|     expect(result?.method_id).toBe(user_get_name);
       |                               ^
    208|     expect(result?.strategy).toBe("unique_method");
    209|   });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[92/123]⎯

 FAIL  src/resolve_references/method_resolution_simple/heuristic_with_types.test.ts > Heuristic Resolution with Local Type Context > should prioritize type hints over other strategies
AssertionError: expected undefined to be 'method::::::getName' // Object.is equality

[32m- Expected:[39m 
"method::::::getName"

[31m+ Received:[39m 
undefined

 ❯ src/resolve_references/method_resolution_simple/heuristic_with_types.test.ts:303:31
    301|     // Should resolve using type hint even though class is in differen…
    302|     expect(result).toBeTruthy();
    303|     expect(result?.method_id).toBe(user_get_name);
       |                               ^
    304|     expect(result?.class_id).toBe(user_class);
    305|     expect(result?.strategy).toBe("explicit_type");

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[93/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/python_builder.test.ts > Python Builder Configuration > PYTHON_BUILDER_CONFIG > should contain function definition capture mappings
AssertionError: expected false to be true // Object.is equality

[32m- Expected[39m
[31m+ Received[39m

[32m- true[39m
[31m+ false[39m

 ❯ src/index_single_file/query_code_tree/language_configs/python_builder.test.ts:123:52
    121| 
    122|       for (const mapping of functionMappings) {
    123|         expect(PYTHON_BUILDER_CONFIG.has(mapping)).toBe(true);
       |                                                    ^
    124|         const config = PYTHON_BUILDER_CONFIG.get(mapping);
    125|         expect(config).toBeDefined();

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[94/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/python_builder.test.ts > Python Builder Configuration > PYTHON_BUILDER_CONFIG > should contain parameter definition capture mappings
AssertionError: expected false to be true // Object.is equality

[32m- Expected[39m
[31m+ Received[39m

[32m- true[39m
[31m+ false[39m

 ❯ src/index_single_file/query_code_tree/language_configs/python_builder.test.ts:141:52
    139| 
    140|       for (const mapping of paramMappings) {
    141|         expect(PYTHON_BUILDER_CONFIG.has(mapping)).toBe(true);
       |                                                    ^
    142|         const config = PYTHON_BUILDER_CONFIG.get(mapping);
    143|         expect(config).toBeDefined();

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[95/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/python_builder.test.ts > Python Builder Configuration > PYTHON_BUILDER_CONFIG > should contain variable definition capture mappings
AssertionError: expected false to be true // Object.is equality

[32m- Expected[39m
[31m+ Received[39m

[32m- true[39m
[31m+ false[39m

 ❯ src/index_single_file/query_code_tree/language_configs/python_builder.test.ts:163:52
    161| 
    162|       for (const mapping of variableMappings) {
    163|         expect(PYTHON_BUILDER_CONFIG.has(mapping)).toBe(true);
       |                                                    ^
    164|         const config = PYTHON_BUILDER_CONFIG.get(mapping);
    165|         expect(config).toBeDefined();

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[96/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/python_builder.test.ts > Python Builder Configuration > PYTHON_BUILDER_CONFIG > should contain property definition capture mappings
AssertionError: expected false to be true // Object.is equality

[32m- Expected[39m
[31m+ Received[39m

[32m- true[39m
[31m+ false[39m

 ❯ src/index_single_file/query_code_tree/language_configs/python_builder.test.ts:174:52
    172| 
    173|       for (const mapping of propertyMappings) {
    174|         expect(PYTHON_BUILDER_CONFIG.has(mapping)).toBe(true);
       |                                                    ^
    175|         const config = PYTHON_BUILDER_CONFIG.get(mapping);
    176|         expect(config).toBeDefined();

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[97/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/python_builder.test.ts > Python Builder Configuration > PYTHON_BUILDER_CONFIG > End-to-end integration tests > should build complete class definition with methods
TypeError: actual value must be number or bigint, received "undefined"
 ❯ src/index_single_file/query_code_tree/language_configs/python_builder.test.ts:452:36
    450| 
    451|         const definitions = builder.build();
    452|         expect(definitions.length).toBeGreaterThan(0);
       |                                    ^
    453| 
    454|         const classDef = definitions.find((d) => d.kind === "class");

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[98/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/python_builder.test.ts > Python Builder Configuration > PYTHON_BUILDER_CONFIG > End-to-end integration tests > should handle function with typed parameters
TypeError: actual value must be number or bigint, received "undefined"
 ❯ src/index_single_file/query_code_tree/language_configs/python_builder.test.ts:484:36
    482| 
    483|         const definitions = builder.build();
    484|         expect(definitions.length).toBeGreaterThan(0);
       |                                    ^
    485| 
    486|         const funcDef = definitions.find((d) => d.kind === "function");

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[99/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/python_builder.test.ts > Python Builder Configuration > PYTHON_BUILDER_CONFIG > End-to-end integration tests > should distinguish between constants and variables by naming convention
TypeError: defs1.find is not a function
 ❯ src/index_single_file/query_code_tree/language_configs/python_builder.test.ts:514:32
    512|         }
    513|         const defs1 = builder1.build();
    514|         const constDef = defs1.find((d) => d.name === "MAX_SIZE");
       |                                ^
    515|         expect(constDef?.kind).toBe("constant");
    516| 

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[100/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/python_builder.test.ts > Python Builder Configuration > PYTHON_BUILDER_CONFIG > End-to-end integration tests > should handle private methods by naming convention
TypeError: definitions.find is not a function
 ❯ src/index_single_file/query_code_tree/language_configs/python_builder.test.ts:655:38
    653| 
    654|         const definitions = builder.build();
    655|         const classDef = definitions.find((d) => d.kind === "class") a…
       |                                      ^
    656| 
    657|         // Verify that both methods exist

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[101/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts > rust_builder > struct definitions > should process generic struct
AssertionError: expected undefined to deeply equal [ 'T', 'U' ]

[32m- Expected:[39m 
[
  "T",
  "U",
]

[31m+ Received:[39m 
undefined

 ❯ src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts:142:47
    140|       expect(definitions.classes).toHaveLength(1);
    141|       expect(definitions.classes[0].name).toBe("Container");
    142|       expect(definitions.classes[0].generics).toEqual(["T", "U"]);
       |                                               ^
    143|       expect(definitions.classes[0].availability.scope).toBe("file-pri…
    144|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[102/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts > rust_builder > struct definitions > should handle pub(crate) visibility
AssertionError: expected 'package-internal' to be 'package' // Object.is equality

Expected: [32m"package"[39m
Received: [31m"package[7m-internal[27m"[39m

 ❯ src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts:172:57
    170| 
    171|       expect(definitions.classes).toHaveLength(1);
    172|       expect(definitions.classes[0].availability.scope).toBe("package"…
       |                                                         ^
    173|     });
    174|   });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[103/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts > rust_builder > enum definitions > should process simple enum
AssertionError: expected [ { …(3) }, { …(3) }, { …(3) } ] to deeply equal [ 'Success', 'Error', 'Pending' ]

[32m- Expected[39m
[31m+ Received[39m

[2m  [[22m
[32m-   "Success",[39m
[32m-   "Error",[39m
[32m-   "Pending",[39m
[31m+   {[39m
[31m+     "location": {[39m
[31m+       "end_column": 15,[39m
[31m+       "end_line": 1,[39m
[31m+       "file_path": "test.rs",[39m
[31m+       "start_column": 9,[39m
[31m+       "start_line": 1,[39m
[31m+     },[39m
[31m+     "name": "enum_member:test.rs:1:9:1:15:Success",[39m
[31m+     "value": undefined,[39m
[31m+   },[39m
[31m+   {[39m
[31m+     "location": {[39m
[31m+       "end_column": 15,[39m
[31m+       "end_line": 1,[39m
[31m+       "file_path": "test.rs",[39m
[31m+       "start_column": 9,[39m
[31m+       "start_line": 1,[39m
[31m+     },[39m
[31m+     "name": "enum_member:test.rs:1:9:1:15:Error",[39m
[31m+     "value": undefined,[39m
[31m+   },[39m
[31m+   {[39m
[31m+     "location": {[39m
[31m+       "end_column": 15,[39m
[31m+       "end_line": 1,[39m
[31m+       "file_path": "test.rs",[39m
[31m+       "start_column": 9,[39m
[31m+       "start_line": 1,[39m
[31m+     },[39m
[31m+     "name": "enum_member:test.rs:1:9:1:15:Pending",[39m
[31m+     "value": undefined,[39m
[31m+   },[39m
[2m  ][22m

 ❯ src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts:193:44
    191|       expect(definitions.enums).toHaveLength(1);
    192|       expect(definitions.enums[0].name).toBe("Status");
    193|       expect(definitions.enums[0].members).toEqual([
       |                                            ^
    194|         "Success",
    195|         "Error",

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[104/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts > rust_builder > enum definitions > should process generic enum
AssertionError: expected undefined to deeply equal [ 'T', 'E' ]

[32m- Expected:[39m 
[
  "T",
  "E",
]

[31m+ Received:[39m 
undefined

 ❯ src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts:216:45
    214|       expect(definitions.enums).toHaveLength(1);
    215|       expect(definitions.enums[0].name).toBe("Result");
    216|       expect(definitions.enums[0].generics).toEqual(["T", "E"]);
       |                                             ^
    217|       expect(definitions.enums[0].members).toEqual(["Ok", "Err"]);
    218|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[105/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts > rust_builder > enum definitions > should process enum with complex variants
AssertionError: expected [ { …(3) }, { …(3) }, { …(3) } ] to deeply equal [ 'Quit', 'Move', 'Write' ]

[32m- Expected[39m
[31m+ Received[39m

[2m  [[22m
[32m-   "Quit",[39m
[32m-   "Move",[39m
[32m-   "Write",[39m
[31m+   {[39m
[31m+     "location": {[39m
[31m+       "end_column": 12,[39m
[31m+       "end_line": 1,[39m
[31m+       "file_path": "test.rs",[39m
[31m+       "start_column": 5,[39m
[31m+       "start_line": 1,[39m
[31m+     },[39m
[31m+     "name": "enum_member:test.rs:1:5:1:12:Quit",[39m
[31m+     "value": undefined,[39m
[31m+   },[39m
[31m+   {[39m
[31m+     "location": {[39m
[31m+       "end_column": 12,[39m
[31m+       "end_line": 1,[39m
[31m+       "file_path": "test.rs",[39m
[31m+       "start_column": 5,[39m
[31m+       "start_line": 1,[39m
[31m+     },[39m
[31m+     "name": "enum_member:test.rs:1:5:1:12:Move",[39m
[31m+     "value": undefined,[39m
[31m+   },[39m
[31m+   {[39m
[31m+     "location": {[39m
[31m+       "end_column": 12,[39m
[31m+       "end_line": 1,[39m
[31m+       "file_path": "test.rs",[39m
[31m+       "start_column": 5,[39m
[31m+       "start_line": 1,[39m
[31m+     },[39m
[31m+     "name": "enum_member:test.rs:1:5:1:12:Write",[39m
[31m+     "value": undefined,[39m
[31m+   },[39m
[2m  ][22m

 ❯ src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts:235:44
    233| 
    234|       expect(definitions.enums).toHaveLength(1);
    235|       expect(definitions.enums[0].members).toEqual(["Quit", "Move", "W…
       |                                            ^
    236|     });
    237|   });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[106/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts > rust_builder > trait definitions > should process generic trait
AssertionError: expected undefined to deeply equal [ 'Item' ]

[32m- Expected:[39m 
[
  "Item",
]

[31m+ Received:[39m 
undefined

 ❯ src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts:272:50
    270|       expect(definitions.interfaces).toHaveLength(1);
    271|       expect(definitions.interfaces[0].name).toBe("Iterator");
    272|       expect(definitions.interfaces[0].generics).toEqual(["Item"]);
       |                                                  ^
    273|     });
    274|   });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[107/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts > rust_builder > function definitions > should process simple function
AssertionError: expected undefined to be 'i32' // Object.is equality

[32m- Expected:[39m 
"i32"

[31m+ Received:[39m 
undefined

 ❯ src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts:291:52
    289|       expect(definitions.functions).toHaveLength(1);
    290|       expect(definitions.functions[0].name).toBe("calculate");
    291|       expect(definitions.functions[0].return_type).toBe("i32");
       |                                                    ^
    292|       expect(definitions.functions[0].availability.scope).toBe("public…
    293|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[108/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts > rust_builder > function definitions > should process async function
AssertionError: expected undefined to be true // Object.is equality

[32m- Expected:[39m 
true

[31m+ Received:[39m 
undefined

 ❯ src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts:309:46
    307|       expect(definitions.functions).toHaveLength(1);
    308|       expect(definitions.functions[0].name).toBe("fetch_data");
    309|       expect(definitions.functions[0].async).toBe(true);
       |                                              ^
    310|       expect(definitions.functions[0].return_type).toBe(
    311|         "Result<String, Error>"

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[109/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts > rust_builder > function definitions > should process const function
AssertionError: expected undefined to be true // Object.is equality

[32m- Expected:[39m 
true

[31m+ Received:[39m 
undefined

 ❯ src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts:329:46
    327|       expect(definitions.functions).toHaveLength(1);
    328|       expect(definitions.functions[0].name).toBe("compute");
    329|       expect(definitions.functions[0].const).toBe(true);
       |                                              ^
    330|       expect(definitions.functions[0].return_type).toBe("usize");
    331|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[110/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts > rust_builder > function definitions > should process unsafe function
AssertionError: expected undefined to be true // Object.is equality

[32m- Expected:[39m 
true

[31m+ Received:[39m 
undefined

 ❯ src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts:347:47
    345|       expect(definitions.functions).toHaveLength(1);
    346|       expect(definitions.functions[0].name).toBe("raw_access");
    347|       expect(definitions.functions[0].unsafe).toBe(true);
       |                                               ^
    348|     });
    349| 

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[111/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts > rust_builder > function definitions > should process generic function
AssertionError: expected undefined to deeply equal [ 'T' ]

[32m- Expected:[39m 
[
  "T",
]

[31m+ Received:[39m 
undefined

 ❯ src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts:364:49
    362|       expect(definitions.functions).toHaveLength(1);
    363|       expect(definitions.functions[0].name).toBe("compare");
    364|       expect(definitions.functions[0].generics).toEqual(["T"]);
       |                                                 ^
    365|     });
    366|   });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[112/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts > rust_builder > variable and constant definitions > should process const definition
AssertionError: expected undefined to be true // Object.is equality

[32m- Expected:[39m 
true

[31m+ Received:[39m 
undefined

 ❯ src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts:501:49
    499|       expect(definitions.variables[0].name).toBe("MAX_SIZE");
    500|       expect(definitions.variables[0].type).toBe("usize");
    501|       expect(definitions.variables[0].readonly).toBe(true);
       |                                                 ^
    502|       expect(definitions.variables[0].availability.scope).toBe("public…
    503|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[113/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts > rust_builder > variable and constant definitions > should process static variable
AssertionError: expected undefined to be true // Object.is equality

[32m- Expected:[39m 
true

[31m+ Received:[39m 
undefined

 ❯ src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts:517:47
    515|       expect(definitions.variables).toHaveLength(1);
    516|       expect(definitions.variables[0].name).toBe("COUNTER");
    517|       expect(definitions.variables[0].static).toBe(true);
       |                                               ^
    518|     });
    519|   });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[114/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts > rust_builder > parameter definitions > should process function parameter
AssertionError: Target cannot be null or undefined.
 ❯ src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts:532:38
    530|       );
    531| 
    532|       expect(definitions.parameters).toHaveLength(1);
       |                                      ^
    533|       expect(definitions.parameters[0].name).toBe("data");
    534|       expect(definitions.parameters[0].type).toBe("&str");

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[115/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts > rust_builder > parameter definitions > should process mutable parameter
AssertionError: Target cannot be null or undefined.
 ❯ src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts:547:38
    545|       );
    546| 
    547|       expect(definitions.parameters).toHaveLength(1);
       |                                      ^
    548|       expect(definitions.parameters[0].name).toBe("value");
    549|       // Mutable detection would require checking parent node

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[116/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts > rust_builder > type definitions > should process type alias
AssertionError: expected undefined to deeply equal [ 'T' ]

[32m- Expected:[39m 
[
  "T",
]

[31m+ Received:[39m 
undefined

 ❯ src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts:604:45
    602|       expect(definitions.types).toHaveLength(1);
    603|       expect(definitions.types[0].name).toBe("Result");
    604|       expect(definitions.types[0].generics).toEqual(["T"]);
       |                                             ^
    605|       expect(definitions.types[0].availability.scope).toBe("public");
    606|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[117/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts > rust_builder > visibility extraction > should detect pub(crate) visibility
AssertionError: expected 'package-internal' to be 'package' // Object.is equality

Expected: [32m"package"[39m
Received: [31m"package[7m-internal[27m"[39m

 ❯ src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts:646:57
    644|         "CrateStruct"
    645|       );
    646|       expect(definitions.classes[0].availability.scope).toBe("package"…
       |                                                         ^
    647|     });
    648| 

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[118/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts > rust_builder > visibility extraction > should detect pub(super) visibility
AssertionError: expected 'file-private' to be 'parent-module' // Object.is equality

Expected: [32m"[7mparent-modul[27me"[39m
Received: [31m"[7mfile-privat[27me"[39m

 ❯ src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts:657:55
    655|         "SuperEnum"
    656|       );
    657|       expect(definitions.enums[0].availability.scope).toBe("parent-mod…
       |                                                       ^
    658|     });
    659| 

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[119/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts > rust_builder > macro definitions > should process macro definition
AssertionError: expected undefined to be true // Object.is equality

[32m- Expected:[39m 
true

[31m+ Received:[39m 
undefined

 ❯ src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts:689:46
    687|       expect(definitions.functions).toHaveLength(1);
    688|       expect(definitions.functions[0].name).toBe("debug_log");
    689|       expect(definitions.functions[0].macro).toBe(true);
       |                                              ^
    690|     });
    691|   });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[120/123]⎯

 FAIL  src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts > rust_builder > integration tests > should handle complex struct with multiple features
AssertionError: the given combination of arguments (undefined and string) is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a string
 ❯ src/index_single_file/query_code_tree/language_configs/rust_builder.test.ts:781:49
    779|         expect(definitions.classes).toHaveLength(1);
    780|         expect(definitions.classes[0].name).toBe("Database");
    781|         expect(definitions.classes[0].generics).toContain("T");
       |                                                 ^
    782|       }
    783|     });

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[121/123]⎯


 Test Files  20 failed | 27 passed | 2 skipped (49)
      Tests  118 failed | 894 passed | 94 skipped (1106)
   Start at  14:39:47
   Duration  10.56s (transform 1.12s, setup 36ms, collect 1.57s, tests 8.23s, environment 0ms, prepare 66ms)

npm error Lifecycle script `test` failed with error:
npm error code 1
npm error path /Users/chuck/workspace/ariadne/packages/core
npm error workspace @ariadnejs/core@0.7.0
npm error location /Users/chuck/workspace/ariadne/packages/core
npm error command failed
npm error command sh -c vitest run


> @ariadnejs/mcp@0.1.5 test
> vitest run


 RUN  v3.2.4 /Users/chuck/workspace/ariadne/packages/mcp

 ❯ tests/find_references.test.ts (11 tests | 11 skipped) 7ms
   ↓ find_references > TypeScript references > should find function references across files
   ↓ find_references > TypeScript references > should include declaration when requested
   ↓ find_references > TypeScript references > should handle method references
   ↓ find_references > TypeScript references > should respect search scope
   ↓ find_references > JavaScript references > should find references in JavaScript files
   ↓ find_references > Python references > should find references in Python files
   ↓ find_references > Error handling > should return error for non-existent symbol
   ↓ find_references > Error handling > should handle symbols with no references
   ↓ find_references > Multiple definitions > should handle symbols with multiple definitions
   ↓ find_references > Edge cases > should handle references in string literals correctly
   ↓ find_references > Edge cases > should provide context for each reference
 ❯ tests/server.test.ts (3 tests | 2 failed) 16ms
   × Ariadne MCP Server > Core functionality > should handle go_to_definition correctly 8ms
     → Project is not defined
   × Ariadne MCP Server > Core functionality > should handle find_references correctly 2ms
     → Project is not defined
   ✓ Ariadne MCP Server > Server binary > should be executable 4ms
 ❯ tests/get_source_code.test.ts (13 tests | 13 skipped) 9ms
   ↓ get_source_code > TypeScript source extraction > should extract function source code
   ↓ get_source_code > TypeScript source extraction > should extract class source code
   ↓ get_source_code > TypeScript source extraction > should extract interface source code
   ↓ get_source_code > TypeScript source extraction > should extract type alias source code
   ↓ get_source_code > JavaScript source extraction > should extract JavaScript functions
   ↓ get_source_code > Python source extraction > should extract Python functions and classes
   ↓ get_source_code > Rust source extraction > should extract Rust functions and structs
   ↓ get_source_code > Error handling > should return error for non-existent symbol
   ↓ get_source_code > Error handling > should provide suggestions for similar symbols
   ↓ get_source_code > Docstring extraction > should extract JSDoc comments
   ↓ get_source_code > Docstring extraction > should handle includeDocstring flag
   ↓ get_source_code > Complex source extraction > should extract nested functions
   ↓ get_source_code > Complex source extraction > should handle multiline signatures
 ❯ tests/get_file_metadata.test.ts (12 tests | 12 skipped) 9ms
   ↓ get_file_metadata > TypeScript files > should extract function metadata correctly
   ↓ get_file_metadata > TypeScript files > should extract class and interface metadata
   ↓ get_file_metadata > TypeScript files > should extract import statements
   ↓ get_file_metadata > JavaScript files > should handle JavaScript functions and classes
   ↓ get_file_metadata > Python files > should handle Python functions and classes
   ↓ get_file_metadata > Rust files > should handle Rust functions and structs
   ↓ get_file_metadata > Error handling > should return error for non-existent file
   ↓ get_file_metadata > Error handling > should handle empty files
   ↓ get_file_metadata > Error handling > should handle files with only comments
   ↓ get_file_metadata > Path handling > should handle relative paths
   ↓ get_file_metadata > Path handling > should handle absolute paths
   ↓ get_file_metadata > Signature extraction > should extract clean signatures without braces
 ❯ tests/get_symbol_context.test.ts (10 tests | 10 failed) 9ms
   × get_symbol_context > TypeScript symbol resolution > should find a function definition by name 5ms
     → Project is not defined
   × get_symbol_context > TypeScript symbol resolution > should find a class definition with methods 1ms
     → Project is not defined
   × get_symbol_context > TypeScript symbol resolution > should handle symbol not found with suggestions 0ms
     → Project is not defined
   × get_symbol_context > TypeScript symbol resolution > should track imports and cross-file references 0ms
     → Project is not defined
   × get_symbol_context > TypeScript symbol resolution > should include test references when requested 0ms
     → Project is not defined
   × get_symbol_context > TypeScript symbol resolution > should extract documentation from JSDoc comments 0ms
     → Project is not defined
   × get_symbol_context > TypeScript symbol resolution > should calculate basic metrics 0ms
     → Project is not defined
   × get_symbol_context > TypeScript symbol resolution > should extract class inheritance relationships 0ms
     → Project is not defined
   × get_symbol_context > TypeScript symbol resolution > should extract Rust trait implementations 0ms
     → Project is not defined
   × get_symbol_context > Performance > should respond within 200ms for typical queries 0ms
     → Project is not defined

⎯⎯⎯⎯⎯⎯ Failed Suites 3 ⎯⎯⎯⎯⎯⎯⎯

 FAIL  tests/find_references.test.ts > find_references
ReferenceError: Project is not defined
 ❯ tests/find_references.test.ts:12:5
     10| 
     11|   beforeAll(async () => {
     12|     project = new Project();
       |     ^
     13|     // Create a temporary test directory
     14|     testDir = path.join(os.tmpdir(), 'ariadne-find-refs-test-' + Date.…

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[1/18]⎯

 FAIL  tests/find_references.test.ts > find_references
TypeError: The "path" argument must be of type string or an instance of Buffer or URL. Received undefined
 ❯ tests/find_references.test.ts:20:14
     18|   afterAll(async () => {
     19|     // Clean up test directory
     20|     await fs.rm(testDir, { recursive: true, force: true });
       |              ^
     21|   });
     22| 

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[2/18]⎯

 FAIL  tests/get_file_metadata.test.ts > get_file_metadata
ReferenceError: Project is not defined
 ❯ tests/get_file_metadata.test.ts:12:5
     10| 
     11|   beforeAll(async () => {
     12|     project = new Project();
       |     ^
     13|     // Create a temporary test directory
     14|     testDir = path.join(os.tmpdir(), 'ariadne-mcp-test-' + Date.now());

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[3/18]⎯

 FAIL  tests/get_file_metadata.test.ts > get_file_metadata
TypeError: The "path" argument must be of type string or an instance of Buffer or URL. Received undefined
 ❯ tests/get_file_metadata.test.ts:20:14
     18|   afterAll(async () => {
     19|     // Clean up test directory
     20|     await fs.rm(testDir, { recursive: true, force: true });
       |              ^
     21|   });
     22| 

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[4/18]⎯

 FAIL  tests/get_source_code.test.ts > get_source_code
ReferenceError: Project is not defined
 ❯ tests/get_source_code.test.ts:12:5
     10| 
     11|   beforeAll(async () => {
     12|     project = new Project();
       |     ^
     13|     // Create a temporary test directory
     14|     testDir = path.join(os.tmpdir(), 'ariadne-source-test-' + Date.now…

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[5/18]⎯

 FAIL  tests/get_source_code.test.ts > get_source_code
TypeError: The "path" argument must be of type string or an instance of Buffer or URL. Received undefined
 ❯ tests/get_source_code.test.ts:20:14
     18|   afterAll(async () => {
     19|     // Clean up test directory
     20|     await fs.rm(testDir, { recursive: true, force: true });
       |              ^
     21|   });
     22| 

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[6/18]⎯


⎯⎯⎯⎯⎯⎯ Failed Tests 12 ⎯⎯⎯⎯⎯⎯⎯

 FAIL  tests/get_symbol_context.test.ts > get_symbol_context > TypeScript symbol resolution > should find a function definition by name
 FAIL  tests/get_symbol_context.test.ts > get_symbol_context > TypeScript symbol resolution > should find a class definition with methods
 FAIL  tests/get_symbol_context.test.ts > get_symbol_context > TypeScript symbol resolution > should handle symbol not found with suggestions
 FAIL  tests/get_symbol_context.test.ts > get_symbol_context > TypeScript symbol resolution > should track imports and cross-file references
 FAIL  tests/get_symbol_context.test.ts > get_symbol_context > TypeScript symbol resolution > should include test references when requested
 FAIL  tests/get_symbol_context.test.ts > get_symbol_context > TypeScript symbol resolution > should extract documentation from JSDoc comments
 FAIL  tests/get_symbol_context.test.ts > get_symbol_context > TypeScript symbol resolution > should calculate basic metrics
 FAIL  tests/get_symbol_context.test.ts > get_symbol_context > TypeScript symbol resolution > should extract class inheritance relationships
 FAIL  tests/get_symbol_context.test.ts > get_symbol_context > TypeScript symbol resolution > should extract Rust trait implementations
 FAIL  tests/get_symbol_context.test.ts > get_symbol_context > Performance > should respond within 200ms for typical queries
ReferenceError: Project is not defined
 ❯ tests/get_symbol_context.test.ts:9:5
      7|   
      8|   beforeEach(() => {
      9|     project = new Project();
       |     ^
     10|   });
     11|   

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[7/18]⎯

 FAIL  tests/server.test.ts > Ariadne MCP Server > Core functionality > should handle go_to_definition correctly
ReferenceError: Project is not defined
 ❯ tests/server.test.ts:34:23
     32| 
     33|       // Use Ariadne directly to test the core functionality
     34|       const project = new Project();
       |                       ^
     35|       project.add_or_update_file(testFile, testContent);
     36|       

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[8/18]⎯

 FAIL  tests/server.test.ts > Ariadne MCP Server > Core functionality > should handle find_references correctly
ReferenceError: Project is not defined
 ❯ tests/server.test.ts:58:23
     56| 
     57|       // Use Ariadne directly to test the core functionality
     58|       const project = new Project();
       |                       ^
     59|       project.add_or_update_file(testFile, testContent);
     60|       

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[9/18]⎯


 Test Files  5 failed (5)
      Tests  12 failed | 1 passed | 36 skipped (49)
   Start at  14:39:58
   Duration  648ms (transform 235ms, setup 0ms, collect 459ms, tests 49ms, environment 1ms, prepare 862ms)

npm error Lifecycle script `test` failed with error:
npm error code 1
npm error path /Users/chuck/workspace/ariadne/packages/mcp
npm error workspace @ariadnejs/mcp@0.1.5
npm error location /Users/chuck/workspace/ariadne/packages/mcp
npm error command failed
npm error command sh -c vitest run


> @ariadnejs/types@0.5.15 test
> vitest run


 RUN  v3.2.4 /Users/chuck/workspace/ariadne/packages/types

 ✓ src/symbol.test.ts (4 tests) 3ms
 ✓ tests/types.test.ts (6 tests) 4ms

 Test Files  2 passed (2)
      Tests  10 passed (10)
   Start at  14:40:00
   Duration  450ms (transform 142ms, setup 0ms, collect 198ms, tests 8ms, environment 0ms, prepare 130ms)

