#!/usr/bin/env python3
"""
Ephemeral Agentic Worktree Creator
Generated by worktree-script-generator agent
Project: ariadne
Description: Node.js/TypeScript monorepo for call graph analysis
"""
# /// script
# requires-python = ">=3.11"
# ///

import argparse
import os
import shutil
import subprocess
import sys
from pathlib import Path

# ============================================================
# CONFIGURATION - Customize for your project
# ============================================================

# Files to deep copy (isolated state per worktree)
STATE_FILES: list[str] = [
    ".env",
    ".env.local",
    ".vscode/launch.json",
]

# Directories to symlink (shared across worktrees for speed)
SHARED_ASSETS: list[str] = [
    "coverage",
    ".cache",
]

# Port configuration (disabled for library/CLI tool)
PORT_CONFIG = {
    "enabled": False,
    "base_port": 3000,
    "port_env_var": "PORT",
    "port_file": ".env.local",
}

# ============================================================
# IMPLEMENTATION
# ============================================================

def get_repo_root() -> Path:
    """Get the git repository root."""
    result = subprocess.run(
        ["git", "rev-parse", "--show-toplevel"],
        capture_output=True, text=True, check=True
    )
    return Path(result.stdout.strip())

def get_current_branch() -> str:
    """Get the current git branch name."""
    result = subprocess.run(
        ["git", "rev-parse", "--abbrev-ref", "HEAD"],
        capture_output=True, text=True, check=True
    )
    return result.stdout.strip()

def sanitize_name(name: str) -> str:
    """Convert task name to safe directory name."""
    return name.replace("/", "-").replace("\\", "-").replace(" ", "-").lower()

def create_worktree(task_name: str, base_branch: str | None = None) -> Path:
    """Create a new worktree for the given task."""
    repo_root = get_repo_root()
    safe_name = sanitize_name(task_name)
    worktrees_dir = repo_root / ".worktrees"
    worktree_path = worktrees_dir / safe_name

    # Default to current branch if not specified
    if base_branch is None:
        base_branch = get_current_branch()

    print(f"Creating worktree for: {task_name}")
    print(f"  Base branch: {base_branch}")

    # Validate
    if worktree_path.exists():
        print(f"Error: Worktree already exists at {worktree_path}", file=sys.stderr)
        print("Use a different task name or remove the existing worktree.", file=sys.stderr)
        sys.exit(1)

    # Create .worktrees directory if needed
    worktrees_dir.mkdir(parents=True, exist_ok=True)

    # Add .worktrees to .gitignore if not present
    gitignore = repo_root / ".gitignore"
    if gitignore.exists():
        content = gitignore.read_text()
        if ".worktrees" not in content:
            with gitignore.open("a") as f:
                f.write("\n# Git worktrees for parallel development\n.worktrees/\n")
            print("  Added .worktrees/ to .gitignore")

    # Determine branch name
    branch_name = f"worktree/{safe_name}"

    # Check if branch exists
    branch_exists = subprocess.run(
        ["git", "rev-parse", "--verify", branch_name],
        capture_output=True, cwd=repo_root
    ).returncode == 0

    # Create the worktree
    print(f"  Creating git worktree...")
    if branch_exists:
        subprocess.run(
            ["git", "worktree", "add", str(worktree_path), branch_name],
            check=True, cwd=repo_root
        )
    else:
        subprocess.run(
            ["git", "worktree", "add", "-b", branch_name, str(worktree_path), base_branch],
            check=True, cwd=repo_root
        )

    # Deep copy state files
    for state_file in STATE_FILES:
        src = repo_root / state_file
        dst = worktree_path / state_file
        if src.exists():
            dst.parent.mkdir(parents=True, exist_ok=True)
            if src.is_file():
                shutil.copy2(src, dst)
                print(f"  Copied: {state_file}")
            else:
                shutil.copytree(src, dst)
                print(f"  Copied directory: {state_file}")

    # Create symlinks for shared assets
    for shared_dir in SHARED_ASSETS:
        src = repo_root / shared_dir
        dst = worktree_path / shared_dir
        if src.exists() and not dst.exists():
            dst.parent.mkdir(parents=True, exist_ok=True)
            # Use relative symlink for portability
            rel_src = os.path.relpath(src, dst.parent)
            dst.symlink_to(rel_src)
            print(f"  Symlinked: {shared_dir}")

    # Install dependencies with pnpm (includes entrypoint-analysis via workspace)
    print("  Installing dependencies with pnpm...")
    subprocess.run(
        ["pnpm", "install"],
        check=True,
        cwd=worktree_path
    )

    # Build the project
    print("  Building project with pnpm...")
    subprocess.run(
        ["pnpm", "build"],
        check=True,
        cwd=worktree_path
    )

    # Handle port configuration
    if PORT_CONFIG["enabled"]:
        existing_worktrees = list(worktrees_dir.iterdir()) if worktrees_dir.exists() else []
        port = PORT_CONFIG["base_port"] + len(existing_worktrees)
        port_file = worktree_path / PORT_CONFIG["port_file"]
        with port_file.open("a") as f:
            f.write(f"\n{PORT_CONFIG['port_env_var']}={port}\n")
        print(f"  Assigned port: {port}")

    print(f"\nWorktree created successfully!")
    print(f"  Location: {worktree_path}")
    print(f"  Branch: {branch_name}")
    print(f"\nTo start working:")
    print(f"  cd {worktree_path}")

    return worktree_path

def main():
    parser = argparse.ArgumentParser(
        description="Create an isolated git worktree for parallel development",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s fix-auth-bug              # Creates from current branch
  %(prog)s feat-dark-mode --base main  # Creates from main branch
  %(prog)s JIRA-1234-user-profile
        """
    )
    parser.add_argument(
        "task_name",
        help="Descriptive name for the task (e.g., fix-auth-bug, feat-dark-mode)"
    )
    parser.add_argument(
        "-b", "--base",
        default=None,
        help="Base branch to create worktree from (default: current branch)"
    )
    args = parser.parse_args()

    try:
        create_worktree(args.task_name, args.base)
    except subprocess.CalledProcessError as e:
        print(f"Git error: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
